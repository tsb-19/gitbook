{"./":{"url":"./","title":"Introduction","keywords":"","body":"Gitbook 这是用gitbook发布的一本在线电子书 "},"docs/":{"url":"docs/","title":"技术文档","keywords":"","body":"技术文档 "},"docs/example.html":{"url":"docs/example.html","title":"示例","keywords":"","body":"示例 信息： [info] For info Use this for infomation messages. 警告： [warning] For warning Use this for warning messages. 危险： [danger] For danger Use this for danger messages. 成功： [success] For success Use this for success messages. "},"docs/git.html":{"url":"docs/git.html","title":"Git","keywords":"","body":"Git 多仓库 将另外一个远程仓库设置为 remote：git remote add origin url 查看本地已经关联的仓库： git remote -v 删除远程库 git remote rm origin 在本地新建一个与远程仓库对应的分支：git checkout -b dev upstream/dev 将更新推送到自己的远程仓库：git push origin ch4 "},"docs/linux.html":{"url":"docs/linux.html","title":"Linux","keywords":"","body":"Linux "},"docs/nodejs.html":{"url":"docs/nodejs.html","title":"Nodejs","keywords":"","body":"Nodejs "},"docs/database.html":{"url":"docs/database.html","title":"数据库","keywords":"","body":"数据库 "},"docs/network.html":{"url":"docs/network.html","title":"网络通信","keywords":"","body":"网络通信 "},"docs/environment.html":{"url":"docs/environment.html","title":"环境配置","keywords":"","body":"环境配置 "},"notes/":{"url":"notes/","title":"课程笔记","keywords":"","body":"课程笔记 "},"notes/计算机网络安全技术.html":{"url":"notes/计算机网络安全技术.html","title":"计算机网络安全技术","keywords":"","body":"计算机网络安全概述 互联网是重要的社会基础设施 互联网中的攻击 蛮力破解 使用数字和字母的任意组合，猜出用户名和口令 花费大量时间，结果往往不理想 撞库攻击 中间人攻击 在两个受害者网络链路之间进行数据监听和数据篡改的攻击方式 数据监听和数据篡改 拒绝服务攻击 企图通过使计算机崩溃或把它压垮来组织提供服务 最为有效、存在最多 SYN洪泛 (SYN flood) /UDP洪泛(UDP flood) /DNS反射攻击 病毒（恶意软件） 互联网中的防守 加解密技术 访问控制和身份认证 防火墙技术 防病毒技术 补丁技术 Enigma 代换密码算法 按键使得滚轮N向前滚动一格，滚轮M和L皆保持不变 大约有一亿亿种可能性 密码学基础 初识密码 密码是一种用来混淆的技术，它希望将正常的、可识别的信息转变为无法识别的信息 密码学的基本概念 两种加密形式 传统加密（对称加密、单钥加密）：代换密码、置换密码、二者组合 现代加密（非对称加密、公钥加密）：把算法和密钥分开，密码算法公开，密钥保密 基本概念 明文：原始可以理解的信息或者数据 密文：加密后的信息 加密：从明文到密文的变换过程 解密：从密文到明文的变换过程 密码算法/密码：用来加密和解密的数学函数，c=E(m),m=D(c),D(E(m))=mc=E(m), m=D(c) , D(E(m))= mc=E(m),m=D(c),D(E(m))=m 密钥（key）：密码算法中的一个变量 密码学的基本模型 密码编码学 转换明文为密文的运算类型 两个原理：置换和代换 置换是将明文中的元素重新排列 代换是将明文中的每个元素映射成另外一个元素 所用的密钥数 发送方和接收方使用相同的密码：对称密码、传统加密 发送方和接收方使用不同的密码：非对称密码、公钥密码 处理明文的方法 分组密码/块密码：每次处理一个输入分组 流密码/序列密码：连续处理输入元素 无条件安全和计算安全 密码分析学 密码学的发展历程 古典密码：数据安全基于算法的保密 近代密码：加密体系的安全性并不依赖于加密的方法本身，而是依赖于所使用的密匙 现代密码：公钥密码使得发送端和接收端无密钥传输的保密通信成为可能 古典密码 代换技术 将明文字母替换成其他字母、数字或者符号的方法 Casear密码：对字母表中的每个字母用它之后的第key个字母代换 单表代换密码：设一个密钥词放在前边，其余字母按顺序 Playfair密码：基于由密钥词构成的5×5矩阵（I和J当作一个字母） Hill密码：将m个连续的明文字母代换成m个密文字母，这是由m个线性等式决定的 加密过程：C=KP(mod26)C = KP(mod 26)C=KP(mod26) 解密过程：P=K−1C(mod26)P = K^{-1}C(mod 26)P=K​−1​​C(mod26) Vigenere密码:具体使用哪一行字母表进行编译是基于密钥进行的 Verman密码和一次一密：一次一密是牢不可破的 实际操作上存在很大困难：产生大规模随机密钥、密钥的分配和保护 置换技术 通过置换形成新的排列 破译举例 单表代换密码的破译：穷举法和频率分析法 对称密码算法 对称密钥简介 加密和解密使用相同的密钥：KE=KDK_E=K_DK​E​​=K​D​​ 密钥必须使用秘密的信道分配 简化DES Feistel密码结构 乘积密码是指依次使用两个或以上的基本密码，所得密码强度将强于所有单个密码的强度 交替使用代换和置换（混淆和扩散） 扩散使明文的统计特征消散在密文中，混淆使密文和加密密钥的统计关系更复杂 每轮迭代都有相同的结构： 代换作用在数据左半部分，它通过轮函数F作用在数据的右半部分后，与左半部分进行异或来完成 每轮迭代的轮函数相同，但是输入的子密钥Ki不同 代换之后，交换数据的左右两半完成置换 影响Feistel具体实现的重要参数： 分组长度和密钥长度 迭代轮数 子密钥产生算法 轮函数 DES算法 分组加密（分组长度64bits），对称密钥算法（密钥长度56bits，加上奇偶校验64bits），16次迭代 常用的对称密码 3DES：密钥长度112bits，两个密钥三重DES Blowfish：分组长度64bits，密钥长度32-448bits RC5：分组长度32、64、128bits，密钥长度0-2040bits AES：分组长度128bits，支持128、192、256bits密钥 非对称密码算法 算法原理 对称密钥密码系统的缺陷 密钥必须经过安全的信道分配 无法用于数字签名 密钥管理复杂 公钥密码基于数学函数而不是代换和置换 公钥密码体制有6个组成部分 明文：可读的信息 加密算法：对明文进行的各种变换 公钥/私钥：一个用于加密，一个用于解密 密文：加密算法的输出，不可读信息 解密算法：根据密文和相应的密钥，产生出明文 符号说明：会话密钥Ks，用户A的公钥KUa，用户A的私钥KRa 公钥密码体制 公钥公开，用于加密和验证签名 私钥保密，用作解密和签名 公钥密码系统的应用：加密/解密、数字签名、密钥交换 RSA算法 密钥产生 加密/解密 对RSA算法的攻击方法：蛮力攻击、数学攻击、计时攻击 DH密钥交换算法 其它公钥密码算法 DSA：只能用于数字签名，基于计算离散对数的难度 椭圆曲线密码系统 密钥的分配 传统的对称密码分配 密钥由A选择，并亲自交给B 第三方选择密钥后亲自交给A和B 如果A和B以前或者最近使用过某个密钥，其中一方可用它加密一个新密钥后再发送给另外一方 A和B与第三方C均有秘密渠道，则C可以将一密钥分别秘密发送给A和B 公钥的分配 公开发布：任一通信方可以将他的公钥发送给另外一个通讯方或者广播给通信各方 公开可访问目录：维护一个动态可访问的公钥目录可以获得更大程度的安全性；某个可信的实体或组织负责这个公开目录的维护和分配 公钥授权 公钥证书 利用公钥分配传统密码的密钥 简单的密钥分配方法 具有保密性和真实性的密钥分配方法 混合方法 消息认证技术 消息认证基本概念 网络环境中的攻击 泄密：将消息透露给没有合法密钥的接收方 传输分析：分析通信双方的通信模式 伪装：欺诈源向网络中插入一条消息 消息认证的概念 消息认证就是验证所收到的消息确实是来自真正的发送方且未被修改的消息 认证函数 产生认证符的函数称为认证函数 消息加密：整个消息的密文作为认证符 对称加密：解决对称加密中消息认证的方法是要求明文具有某种易于识别的结构，而且，不通过加密函数是不能重复这种结构的 公钥加密：如果既要提供保密性，又要提供认证，发送方A可以先用其私钥加密(数字签名)，然后用B的公钥加密 消息认证码MAC：MAC是消息和密钥的公开函数，它产生定长的值，该值作为认证符 消息认证码：MAC=Ck(M)MAC=C_k(M)MAC=C​k​​(M) M：输入消息 C：MAC函数 K：收发双方的共享密钥 MAC：消息认证码 MAC函数与加密类似，区别是MAC算法不要求可逆 MAC认证的过程 A和B共享密码K A向B发送消息时，A计算MAC，将其附加在消息后面，一起发送给接收方 接收方对收到的消息用相同的密钥K进行计算得到MAC，并与收到的MAC进行对比 认证+保密 与明文有关的认证：先将消息作为输入，计算MAC，附加在消息之后，然后对整个消息块加密 与密文有关的认证：先将消息加密，然后将密文作为输入，计算MAC，并将MAC附加在上述密文之后形成待发送的信息块 使用消息认证码MAC的情况 将同一消息广播给很多接收者的情况 在信息交换中，接收者希望可以随机地对消息进行认证 对明文形式的计算机程序进行认证是很有意义的服务 一些应用只关心消息的认证，而不关心消息的保密性 将认证和保密性分开，可以使结构层次更灵活 Hash函数：它是将任意长的消息映射为定长的hash值的公开函数，以该hash值作为认证符 Hash函数 单向的hash函数是消息认证码的一种变形 hash函数的输入是大小可变的消息M，输出是固定大小的hash码H(M) 与MAC不同的是，hash码并不使用密钥，它仅仅作为输入消息的函数，hash码也称为信息摘要 Hash码是所有消息位的函数，它具有错误检测能力 将hash码用于消息认证 用对称密码对消息及附在其后的hash码进行加密 用对称密码仅对hash加密：对不要求保密性的应用，这种方法会减少处理代价 用公钥密码和发送方的私钥对hash码加密 即希望保证保密性又希望有数字签名的，先用发送方的私钥对hash码进行加密，再用对称密码中的密钥对消息和上述加密结果进行加密 假定通信双方共享公共的秘密值S，A将M和S联接后再计算hash值，并将其附加在M后面 对整个消息和hash码加密：提供认证和保密性 不使用加密函数：如果不要求保证保密性，就可以不使用加密函数，从而减少计算代价 Hash算法 安全hash函数的一般结构 Hash函数将输入消息分为L个固定长度的分组，每个分组长度为b位，最后一个分组不足b位时，需要填充成b位 输入中包含长度，增加了攻击的难度 设计安全hash函数可以归纳为设计具有抗碰撞能力的压缩函数问题，并且该压缩函数的输入是定长的 主要的Hash算法概述 MD族：MD2、MD4、MD5 SHA族：SHA-0、SHA-1、SHA-2、SHA-3 其它：HAVAL、Gost MD5 输入是任意长度的消息，对输入按照512位的分组为单位进行处理，算法的输出是128位的消息摘要 设计目标： 安全性 速度 简单和简洁性 倾向于使用低端结构 算法步骤： 增加填充位 填充比特：第1位为1，其后各位皆为0 填充比特后，使之与448模512同余 填充长度 用64位表示填充前的报文长度，附加填充比特的后面 以little-endian方式表示被填充前的消息长度 完成填充后，消息的总长度是512的整数倍 初始化MD缓存 Hash函数的中间结果和最终结果都保存于128位的缓冲区中，缓冲区用4个32位的寄存器(A,B,C,D)表示 以512位的分组(16个字)为单位处理消息 由四轮运算组成的压缩函数是算法的核心， 压缩函数标记为HMD5 使用一个随机矩阵T[i]=232∣sin(i)∣T[i] = 2^{32}|sin(i)|T[i]=2​32​​∣sin(i)∣ 输出：所有的L个512位的分组处理完之后，第L个分组的输出即是128位的消息摘要 MD5的强度 SHA 算法步骤 增加填充位：填充消息使之与448模512同余 填充长度：用64位表示填充前的报文长度，附加在填充后的结果后面 初始化MD缓存：Hash函数的中间结果和最终结果都保存于160位的缓冲区中 以512位的分组(16个字)位单位处理消息 输出：所有的L个512位的分组处理完之后，第L个分组的输出即是160位的消息摘要 RIPEMD-160 输入是任意长的消息，输出是160位的消息摘要；输入以512位的分组单位进行处理，hash值和链接变量是160位 各类算法比较 数字签名算法DSS 数字签名 直接数字签名 直接数字签名只涉及通信双方 发送方可以通过用自己的私钥对整个消息或者消息的hash码加密来产生数字签名 再用接收方的公钥(公钥密码)和共享的密钥(对称密码)对整个消息和签名进行加密，则可以获得保密性 仲裁数字签名 从发送方X到接收方Y的每条已签名的消息都先发给仲裁者A，A对消息及其签名进行检查以验证消息源及其内容，然后给消息加上日期，并发给Y，同时指明该消息已通过仲裁者的检验 数字签名标准DSS DSS是一种公钥方法，与RSA不同，DSS不能用于加密或者密钥分配，只提供数字签名功能 DSS使用hash函数，它产生的hash码和随机数k作为数字签名函数Sig的输入，签名函数依赖于发送方的私钥KRa和一组通信伙伴共同拥有的参数构成的全局公钥KUG 签名函数保证只有拥有私钥的发送方才能产生有效签名 签名由两部分构成：s和r 接收方对接收到的消息产生hash码，这个hash码和签名一起作为验证函数Ver的输入，验证函数依赖于全局公钥KUG和发送方公钥KUa；若验证函数的输出等于签名中的r，则签名有效 （电子）身份认证简介 互联网世界中一切信息（包括各类对象的身份信息）都是用一组特定的数据来表示的，计算机只能识别用户的数字身份，因此身份认证的过程也是针对这组特定的数据进行的 构建安全网站的技术手段 正面 认证 授权 审计 反面 消灭各个层面的漏洞 网站身份认证技术 网站系统的基本构成 基本结构是采用开放式的客户/服务器结构（C/S） 完整的网站系统分为三个部分： 服务器端：Web Server 客户机端：浏览器Browser、专用程序 通信协议：HTTP协议 网站系统中常用的技术： HTML、JavaScript、多媒体技术 服务端技术 HTTP协议 超文本传输协议HTTP（Hyper Text Tansfer Protocol）是基于TCP/IP的应用层协议 主要特点： 典型的C/S工作方式，简单快速，数据传输较少 可以通过HTTP协议传输任意类型的数据对象 HTTP是面向一次连接的无状态网络协议 网站用户认证技术 最简单的网站用户认证：HTTP的Basic认证 用户身份凭证：账号+静态口令 在每次发出HTTP请求时，把用户身份凭证的明文发送到服务器端，服务器与存储在服务器端的用户凭证进行比较 对账号口令（U,P）进行Base64编码(便于文本方式传输)，发送到Web服务器端 服务器端接收后进行Base64解码得到（U,P），并与本地存储的账号口令（U,P）进行比较，认证用户身份 优点： 没有复杂的交互过程 使用非常简单 缺点： 每次都需要传递账号和口令，易于被监听、盗取，安全性低 本地（浏览器）还需要保存账号和口令，存在安全隐患 服务器端处理每个HTTP请求都要进行一次身份验证过程，效率低 改进： 使用加密技术：账号口令加密，把口令作为密钥 使用消息认证技术：客户端和服务器端共享密码K（口令） 采用挑战/响应机制，需要进行两次HTTP请求： 第一次请求：服务器向客户端返回一个挑战码M 第二次请求：客户端使用MAC认证发送MAC码，服务器端进行验证 使用表单验证+session的机制 改进解决Basic认证的问题：基于表单的身份认证 一个Session包括特定的客户端、特定的服务器端以及特定的操作时间段 Session工作原理： 当某个Session首次启用时，服务器会产生一个唯一的标识符发送到客户端，客户端收到后会存储下来 在Session存活期间，客户端每次向服务器发送的HTTP请求都会包含上述唯一标识符，使得服务器能够把前后多次请求关联起来 基于表单的Web身份认证过程通常包括三个步骤： 客户端向服务器发送请求，服务器返回包含表单的页面 用户按要求填写表单的内容完成后，客户端把表单内容发送到服务器；服务器获取表单中的内容后，进行验证，验证通过则启动Session并返回给客户端 客户端后续的请求包含Session的唯一标识符，服务端验证唯一标识符的合法性 优点：简单、方便、易用 缺点：安全性低，账号和口令明文在网络上传输，很大程度上存在被监听盗取的可能 改进： 引入Challenge/Response机制，避免口令明文通过网络传输，并且能避免重放攻击 在第二步传输账号口令时，使用传输层SSL协议传输HTTP请求 常见的不安全做法： 验证成功后，把账号口令以Cookie机制存放在浏览器端 验证成功后，把账号口令进行加密后以Cookie机制存放在浏览器客户端 带来的问题：口令泄露，重放攻击 若干网站身份的增强认证技术 手机短信口令 动态口令 USB KEY 数字证书 其它身份认证应用 操作系统登录身份认证 802.1X网络准入身份认证 TUNet用户登录认证 SSH协议登录验证 互联网安全协议 计算机网络安全体系结构 安全目标：CIA 保密性、机密性 完整性 可用性 安全服务 认证服务 认证服务与保证通信的真实性有关 两个特殊的认证服务：对等实体认证、数据源认证 保密服务 保密服务是防止传输数据遭到被动攻击 保密服务的另一方面是防止流量分析 数据完整性服务 可对消息流、单条消息或消息的选定部分进行保护 访问控制服务 限制实体的访问权限，通常是经过认证的合法实体才可以访问，标识与认证是访问控制的前提 抗抵赖服务 防止发送方或者接收方否认传输或者接收过某条消息 可用性服务 根据系统的性能说明，能够按照授权的系统实体的要求存取或使用系统或系统资源的性质 安全机制 安全机制分为两类： 普通安全机制 可信功能 安全标签 事件检测 审计跟踪 安全恢复 特定安全机制 加密机制 数字签名机制 访问控制机制 数据完整性机制 认证机制 业务流填充机制 路由控制机制 公证机制 安全攻击分为两类： 主动攻击：试图改变系统资源或者影响系统运行 被动攻击：试图了解或者利用系统的信息但不影响系统资源 网络层安全协议 IPsec：IP+安全 概述 IP级安全性：认证、保密、密钥管理 现有IP协议的安全特性： 无连接，不保证顺序到达，存在重复包、丢失包，设备简单、无状态 所提供的安全服务： 认证：无 完整性：无 保密：无 访问控制：基于IP地址，但是不完备 所面临的威胁：窃听、伪造IP地址、篡改、重发 IP协议是无状态、无连接的，IP数据报由20个字节的报头和来自传输层的数据构成 IPSec的原理在于可以在IP层加密和/或认证所有流量 IPSec的应用：虚拟专用网VPN IPSec的实施： 在主机上实现 保障端到端的安全 能够对用户的每个会话提供保障 对应用透明，不必修改用户或服务器系统的软件 IPSec可以对最终用户透明 在防火墙上实施 无需改变操作系统 为内部所有的应用提供安全服务 在路由器上实施 可以对通过公用网络在两个子网之间流动的数据提供安全保护 体系结构 IPSec文档：IPv6必须支持这些特性，IPv4可选 体系结构 认证头AH 封装安全载荷ESP 加密算法 认证算法 密钥管理 解释域 IPSec服务 IPSec在IP层提供安全服务，系统可以选择所需要的安全协议，确定该服务所用的算法，并提供安全服务所需加密密钥 使用AH协议报头的认证协议和为数据包设计的加密/认证协议ESP，提供安全性 ESP可以分为支持和不支持认证两种 AH和ESP均支持基于分布密钥的访问控制，而流量管理则与加密协议相关 它们提供的安全服务包括： 访问控制 无连接完整性 数据源发认证 拒绝重放数据包 保密性（加密） 有限的信息流保密性 安全关联SA 安全关联SA是IPSec通信双方之间对某些要素的一种协商，一组安全信息参数的集合，包括：协议、操作模式、密码算法、认证算法、密钥、密钥生存期等 关联是发送方和接收方之间的单向关系，该关联为双方的通信提供了安全服务 如果需要双方安全交换，则建立两个安全关联 安全服务可由AH或者ESP提供，但不能两者都提供 一组安全关联SA由三个参数唯一确定： 安全参数索引SPI SPI是一个与SA相关的位串，仅在本地有意义 SPI由AH和ESP携带，使得接收方能够选择合适的SA处理接收包 IP目的地址IPDA 只允许使用单一地址，表示SA的目的地址，可以是用户末端系统、防火墙或者路由器 安全协议标识 标识该关联是一个AH安全关联或ESP安全关联 在任何IPSec的实现中，都有一个安全关联数据库SADB，它定义了与每个SA相关联的参数 SA的参数 序数计数器：用于生成AH或ESP头中的序数值 序号溢出标志：表明序列号计数器溢出是否应该产生审查事件并且阻止SA上额外包的传输的标志 反重放窗口：用于决定输入AH或ESP报文是否是重播的32位计数器 AH信息 ESP信息 SA的生存期：一个时间间隔或字节计数；生存期结束时，SA必须终止，或用一个新的SA替换 IPSec协议模式：传输模式或者隧道模式 Path MTU：任何遵从的最大传送单位路径和迟滞变量 由安全关联数据库SADB提供的功能必须在IPSec的任何实现中都存在，但提供功能的方式由实现者决定 在IP包中，安全关联由IPv4或IPv6报头中的目的地址唯一标识，SPI被封装在AH或者ESP扩展头中 SA选择子 IP流量与特定SA相关是通过安全策略数据库SPDB的 每个SPDB入口由一个IP集合和上层协议定义，称为选择子 每个IP包的输出过程如下： 在SPDB中比较相应域的值，寻找匹配的入口，可能是零或多个 如果存在SA，则选定SA和其关联的SPI执行所需的IPSec处理（AH或ESP） 传输模式、隧道模式 AH和ESP均支持两种模式：传输模式和隧道模式 传输模式主要为上层协议提供保护，同时增加了IP包载荷的保护 典型的传输模式用于两台主机之间进行的端到端通信 传输模式的ESP加密和认证(可选)IP载荷，不包括报头 传输模式的AH认证IP载荷和报头的选中部分 隧道模式对整个IP包提供保护 当IP包加上AH/ESP域后，整个数据包和安全域被当作一个新的IP载荷，并拥有一个新的外部IP报头 新的IP数据包利用隧道在网络中传输，途中的路由器不能检查内部IP报头 ESP在隧道模式中加密和认证(可选)整个内部IP包，包括内部IP报头 AH在隧道模式中认证整个内部IP包和外部IP报头的选中部分 认证头AH 认证头AH支持数据完整性和IP包的认证 数据完整性确保包的传输过程中内容不可更改 认证确保末端系统或者网络设备对用户或者应用程序进行认证，并提供相应的流量过滤功能，同时还能防止地址欺诈攻击和重放攻击 认证基于消息认证码MAC，双方必须共享一个公钥 认证头的组成： Next header(邻接头)：标识数据载荷中的封装方式或协议 Payload length(有效载荷长度)：以 32 位字为单位的认证数据字段长度 Reserved(保留字)：保留以供将来使用，发送时必需设置为全零 Security Parameters Index(安全参数索引) Sequence Number(序列号)：单调递增计数器，用于防范重放类型攻击 Authentication Data(认证数据AD)：变长域，包含完整性校验值ICV或者包的MAC 反重放攻击 重放攻击是指攻击者在得到一个经过认证的包后，又将其传送到目的站点的行为 重复接收经过认证的IP包可能会以某种方式中断服务或者产生不可预料的后果，序列号域就可以防止重放攻击 完整性校验值 认证数据AD域包含完整性校验值ICV，ICV是一种报文认证编码MAC或者MAC算法生成的截断代码 有两种途径使用IPSec认证服务 直接在服务器和客户工作站之间提供认证 在服务器不支持认证的情况下，远程工作站向防火墙证明自己身份，以便访问整个内部网络的时候，使用隧道模式SA 封装安全载荷ESP 封装安全载荷ESP提供保密性服务包括报文内容保密和流量限制保密，ESP还可以提供和AH同样的认证服务 ESP格式 Security Parameters Index(安全索引参数) Sequence Number(序列号)：单调递增的计数器，用于防范重放类型的攻击 Padding(填充域)：可变长域，范围在0~255字节 Pad Length：填充域长度 Next Header(邻接头)：标识数据载荷中的封装方式或协议 Authentication Data(认证数据AD)：变长域，包含完整性校验值ICV或者包的MAC ESP的加密算法、认证算法、填充域 可用加密算法有：3DES、RC5、IDEA、CAST、Blowfish ESP支持使用默认为96位的MAC 填充域的功能 扩展明文长度 保证ESP格式需要填充长度和邻接头域为右对齐的32位字 隐藏载荷的实际长度，并提供部分流量保护 安全关联组合 单个SA可以实现AH或者ESP，但是不能两者都实现 安全关联组合是指提供特定的IPSec服务集所需的一个SA序列，SA可通过两种方式组合成束 传输邻接：在不使用隧道的情况下，对一个IP包使用多个安全协议；组合AH和ESP的方法仅允许一级组合 隧道迭代：指通过IP隧道应用多层安全协议；由于每个隧道可以在路径上的不同IPSec节点起始和结束，因此该方法允许多层嵌套 IKE：为IPsec管理密钥 IKE概述 IPSec体系结构支持两种密钥管理类型：手工的、自动的 IKE协议为IPSec提供了自动协商交换密钥、建立了安全关联SA的服务，简化了IPSec的使用和管理 IKE协议解决了在不安全的网络环境中安全地建立或更新共享密钥的问题 其核心技术是DH密钥交换算法，具备了完善的前向安全性 IKE为IPSec提供了如下功能： 降低手工配置复杂度 安全关联SA定时更新 密钥定时更新 允许IPSec提供反重放服务 允许在端与端之间动态认证 IKE = ISAKMP格式 + Oakley模式 + SKEME密钥交换 IKE的报文格式 继承自ISAKMP，也称为ISAKMP报文 可以在任何传输层协议或IP层上实现，利用UDP协议的端口500进行传输 双方交换的信息以“报文头+载荷”的形式传输，每个报文由一个定长的报文头和不定数量的载荷组成 ISAKMP定义了13种载荷，具有相同格式的载荷头 IKE的体系结构 IKE使用了两个阶段的ISAKMP框架 第一阶段：协商IKE SA 建立一个经过验证的安全通道，为后续的协商提供机密性和完整性保护 可以使用主模式和积极模式，这两种模式只能在第一阶段中使用 主模式提供了对通信双方的身份保护 当身份保护不必要时，可以使用积极模式以减少信息传输的数量，提高协商效率 主模式：6个信息交互 SA交换：在协商之前，发起者和响应者必须计算产生cookie，用于唯一的标识每个单独的协商交换过程 密钥交换：发起方和响应方采用Diffie-Hellman密钥交换算法计算共享密钥 身份交换和认证：如果双方在消息⑤和消息⑥中的散列载荷中的hash值相同，那么双方的认证成功 积极模式：3个信息交互 适用于一方地址为动态的情况 快速模式传输的消息更少，效率更高 第二阶段：协商IPSec SA 一个IKE SA协商（第一阶段）可为多个IPsec SA协商（第二阶段）提供服务 第二阶段为IPsec AH和/或IPsec ESP协商安全参数，还可以实现密钥数据的交换 第二阶段中使用快速模式进行信息交换，一个第二阶段协商可以建立多个安全关联 需要协商的参数 加密算法 哈希算法 验证方法 DH组 存活周期类型及长度 密钥长度 快速模式：3个消息交互 IKE的工作模式 端节点到端节点：采用传输模式 两个端节点均实现IPsec，通常使用传输模式 IP头与数据间插入IPsec头，用来保护数据载荷 安全网关到安全网关：采用隧道模式 端系统均不需要实现IPsec，由网络节点完成保护功能 通常采用隧道模式发送，内部IP头包含实际端节点的IP地址 常见的上面两种模式的嵌套组合 IKE的工作过程 IKE在协议实现上，是以守护进程的方式在后台运行 可以通过两种方式来启动IKE服务，由内核提交创建IKE SA请求，或同级IKE守护进程提交协商SA请求 两个守护进程通过UDP来传递消息 IKE协议使用两个数据库：SADB和SPDB SPDB在每个条目中隐藏有指针：无论对于外出IP包还是进入IP包，首先都要对SPDB表进行查询，以决定是否丢弃、绕过或应用IPsec IKE守护进程接收到内核发来的请求后，查询SPDB，得到所有协商参数；然后向远程IKE进程发出协商请求；IKE进程开始协商 如果协商成功，把新协商的SA增加到SADB中 当管理员指示IKE守护进程不再使用某个SA时， IKE守护进程会从SADB中删除掉相应的记录SA，同时会向远地的IKE守护进程发送删除信息，表示本地已经不再使用此SA了 远地IKE进程收到此信息后，根据实际的要求作不同的处理 IKE协议总结 主要用途局限于为IPsec通信双方建立安全关联SA 标准定义的复杂性容易导致理解上的困难和实现上的混乱，最终会导致不同实现间的互操作困难 完成协商的消息往返次数过多，这样会消耗较多的计算以及网络带宽资源 容易受到各种攻击，由于设计缺陷，协议实现容易受到拒绝服务攻击、中间人攻击、重放攻击等多种攻击行为的威胁 传输层安全协议 SSL：为应用层服务 SSL概述 SSL工作在TCP协议上，目前不支持UDP SSL与应用层协议无关，可以支持HTTP、Telnet、FTP等面向连接的应用层协议 SSL为端到端的应用提供保密性、完整性、身份认证等安全服务，具有良好的互操作性、可扩展性和相对高的效率 采用SSL协议，可确保信息在传输过程中不被修改，目前在互联网中广泛用于处理财务等敏感信息 SSL体系结构 会话 SSL会话是客户端和服务器之间的一个关联，即一个虚拟的连接关系 通过握手协议建立，用以协商密码算法、主密钥等信息，一个会话协商的信息可以由多个连接共享 连接 连接是一个特定的通信信道，通常映射成一个TCP连接 连接一般是短暂的 SSL协议由以下协议组成： SSL记录协议 SSL握手协议 SSL警告协议 SSL修改密码规约协议 SSL记录协议 为SSL连接提供两种服务 保密性：使用SSL握手协议定义的共享密钥，用传统密钥算法对SSL载荷进行加密 报文完整性：用握手协议定义的共享密钥计算报文认证码 操作过程： 分段：每个上层报文被分成2142​14​​字节的数据块或更小 压缩：压缩不能丢失信息，并且对于短的数据块，压缩后增加内容不能超过1024字节 增加MAC：使用共享密钥在压缩数据基础上计算MAC 加密：使用对称加密算法对压缩报文加上MAC进行加密 增加首部：内容类型、主要版本、次要版本、压缩长度 SSL握手协议 SSL的部分复杂性来自于握手协议，握手协议在传递应用数据之前使用 SSL握手协议允许客户端和服务器端相互认证、协商加密和MAC算法，保护数据使用密钥通过SSL记录传送 主要功能包括： 协商密码算法 协商主会话密钥 Client和Server之间的相互认证 报文格式：类型、长度、内容 四个阶段： 建立安全能力 客户向服务器发送client_hello报文 服务器向客户端发送sever_hello报文 服务器认证和密钥交换 服务器发送其SSL数字证书 服务器发送sever_hello_done报文，等待客户端响应 客户认证和密钥交换 收到服务器发来的sever_hello_done以后，客户端验证server提供的证书是否有效 客户端发送client_key_exchange，此消息包含pre_master_secret和消息认证码密钥，在后续阶段，pre_master_secret 用来计算master_secret 如果客户端发送了Certificate给服务器，客户端将发出签有客户端专用密钥的certificate_verify，通过验证此消息的签名，服务器可以显示验证客户端数字证书的所有权 主密钥master_secret并不直接用于数据加密和认证，而是用来产生连接所需要的一系列密钥 结束 客户端使用一系列加密运算将pre_master_secret转化为master secret ，派生出用于加密和消息认证的所有密钥 客户端发出change_cipher_spec，服务器转换为新协商的密码对 客户发送在新算法、密钥的finished，验证密钥交换和认证过程是否成功 服务器发送change_cipher_spec，将挂起状态迁移到当前的cipher_spec，并发送结束报文 握手完成，客户和服务器可以交换应用层数据 SSL告警协议 告警协议用于向对等实体传递SSL相关的警报,和使用 SSL的其它应用一样，告警消息按照当前状态压缩和加密 此协议的每个消息由两个字节组成 SSL修改密码规约协议 功能 在握手协议的结束阶段发送，通知接收方，以后的记录将使用刚才协商的密码算法和密钥进行加密/认证 接收方把会话的挂起状态复制到当前状态，使以后的连接使用这些密码参数 报文结构：只有一种报文，只有一个字节，只有一个值(1)是有效的 SSL安全性分析 几乎所有操作平台上的WEB浏览器以及流行的Web服务器都支持SSL协议，因此使用SLL协议开发成本小 但是 SSL协议的数据安全性其实就是建立在RSA等算 法的安全性上，从本质上来讲，攻破RSA等算法就等同于攻破此协议 一个安全协议除了基于其所采用的加密算法安全性以外，更为关键的是其逻辑严密性、完整性、正确性，SSL比较好地解决了这一问题 SSL协议可以很好地防范 “重放攻击” 应用层安全协议 HTTPS：HTTP+SSL WEB及其安全威胁 WWW三项基础技术 用于编写文档的超文本标记语言HTML（支持超文本链接） 用于发布资源的超文本传输协议HTTP 通过互联网引用其它可访问文档或资源的统一资源定位URL WWW技术实际上是运行在互联网和TCP/IP上的一个客户/服务器程序 WEB的安全特点 互联网是双向的 Web服务器容易受到互联网的攻击 Web越来越多地成为商业合作和产品信息的发布窗口和商务交易的平台，如果Web服务器被攻击，就可能金钱失窃或信息受损 Web的使用比较简洁，但底层支持软件却很复杂，容易产生安全漏洞 WEB安全的目标 确保Web服务器存储数据的安全 确保Web客户端的计算机是安全的 确保服务器和浏览器之间的信息传输的安全 Web的安全威胁 按照威胁分类 主动攻击 被动攻击 按照威胁位置分类 Web服务器安全 用户认证 访问控制 日志 Web客户端安全 对服务器的认证 访问控制机制和签名 服务器和客户端之间的通信安全 IPsec SSL/TLS MIME/PGP/SET Web流量安全方法 IP级安全 TCP级安全 应用级安全 针对HTTP的攻击举例 HTTP的缺陷 明文传输，没有数据完整性校验 无状态连接，无法验证双方身份的真实性 常见的针对HTTP的攻击 监听嗅探：由于HTTP采用明文信息传输，可以被直接嗅探到明文 篡改劫持：攻击者可以修改通信数据包，达到篡改信息和劫持回话的目的 伪造服务器：由于HTTP协议并不验证服务器的可信度，故而存在ARP欺骗、DNS欺骗以及钓鱼等风险 中间人攻击：攻击者与通讯双方分别建立独立的联系，并交换其所收到的数据 地址解析协议ARP 工作在数据链路层，实现MAC地址和IP地址的映射 ARP协议通过建立和维护IP-MAC映射表进行工作 ARP欺骗 ARP欺骗是一种中间人攻击的常用手段 攻击者可以通过制造伪造的ARP frame，修改网内任何计算机的映射表，从而切断目标主机的互联网通讯，窃取目标主机关键信息 DNS欺骗 ARP欺骗成功后，可以继续进行DNS欺骗 HTTPS = HTTP + SSL HTTPS是HTTP和SSL/TSL协议的合并，解决了数据加密、完整性校验、对服务器的身份认证等问题 SSL在TCP之上建立了一个加密渠道，通过这一层的数据经过了加密，因此达到保密的效果 SSL能否确保HTTPS安全 SSLStrip：针对HTTPS的攻击 SET：安全电子交易 电子商务安全 需求分析和体系结构 网络支付面临的安全问题 网络支付的安全需求 电子商务安全体系 电子商务对安全的基本要求 授权合法性 信息的保密性 信息的完整性 身份的真实性 不可抵赖性 存储信息的安全性 网络系统安全：针对物理技术系统的安全问题 保证网络设施的正常运行 避免受到外界的恶意攻击 网络信息安全：针对商务逻辑系统的安全问题 信息保密、信息完整 身份认证、不可抵赖 信息有效 网络交易安全 参与对象之间交易过程的安全，如安全嵌套层协议(SSL)、安全电子交易协议(SET)、公钥基础设施(PKI) 安全电子交易协议SET SET协议简介 保证交易的私密性、保密性、完整性、抗抵赖 目标 真实性 保密性 隐私 实时性 关键特征 信息的机密性 数据的完整性 卡用户账号的认证 商家的认证 SET协议参与方 持卡人 收款行 商家 支付网关 发卡方 证书权威 SET协议交易过程 SET协议支付处理过程 购买请求 四个报文组成：发起请求、发起响应、购买请求和购买响应 Payment Information和Order Information： PI和OI必须分开加密和签名，以保证用户的隐私不被泄露 PI和OI必须有联系，以防止商家篡改信息，产生纠纷 双签名 双签名的目的是为了连接两个发送给不同接收者的报文 客户生成购买请求 商家验证用户的订单 支付授权 商家需要通过支付网关、发卡行得到授权，才能给用户发货 支付授权交换由两个报文组成：授权请求和授权响应 支付网关对支付授权请求的处理 验证所有证书的合法性 解密数字信封，获得会话密钥，解密authorization block 验证商家对authorization block的数字签名，解密支付信息 验证双签名 验证transaction ID与PI中的是否一致 从发卡行申请支付 支付获取 商家只有通过支付获取才能完成银行的转账业务 支付获取由获取请求和获取响应报文组成 获取请求报文由以下几部分组成：支付的数量、交易ID、获取权标、商人的签名密钥、证书 获取响应报文由以下几部分组成：网关的签名、加密获取相应数据块、网关签名密钥证书 S/MIME：安全电子邮件 电子邮件系统安全需求 电子邮件系统安全问题 匿名转发 电子邮件欺骗 垃圾邮件和邮件炸弹 邮件病毒 如何解决上述安全问题 端到端的安全电子邮件技术，保证邮件从被发出到被接收的整个过程中，内容保密、无法修改、并且不可否认 在传输过程中也保密，借助传输层安全技术 利用SSL SMTP和SSL POP 利用VPN，将所有的TCP/IP传输封装起来，也包括邮件 邮件服务器本身必须安全可靠，目前对邮件服务器的攻击主要分为： 防范网络入侵主要依赖于软件编程时的严谨程度 对于拒绝服务攻击的防范，主要包括： 防止来自外部网络的攻击 防止来自内部网络的攻击 防止中继攻击 安全需求包括：机密性、完整性、可认证、抗否认 电子邮件系统工作原理 电子邮件系统的构成 电子邮件主要相关协议 SMTP 没有提供任何安全服务 可以拒绝超过一定大小的邮件信息 在ASCII码与EBCDIC码之间转换时没有使用统一的映射 POP3 请求/响应协议 其命令由短关键字构成，后边接着可选的参数，以CR和LF符结束，作为单行文本发送 IMAP4 是一种强有力的邮箱访问方式，它为用户提供了有选择地从邮件服务器接收邮件的功能、基于服务器的信息处理功能和共享信箱功能 RFC822 定义了一种用于电子邮件传输的文本消息格式，是基于互联网传递的文本邮件消息标准 消息包括信封和内容两个部分 一个消息包括若干行的报头和无限制的正文 不能支持非ASCII码字符集信息 不能处理中文、日文、包含格式的文本信息和多媒体信息 MIME 对RFC822框架的一个扩展，以兼容的方式解决现有电子邮件传输协议存在的一些问题和限制 包含了如下要素： 定义了五个新的报头域 定义了若干内容转换，从而标准化地支持多媒体的电子邮件 定义了编码转换方式，使得任何内容格式均可转化为邮件系统认可的格式 安全的电子邮件协议 PEM 主要功能包括加密、源认证和完整性 报文加密采用DES算法，报文认证采用MD5算法 由于PEM依赖于一个即存的、完全可操作的PKI，而建立PKI需要很长的过程，大大限制了PEM的发展，现在几乎没有人使用 MOSS 改变了PEM只支持文本信息的局限性，支持了MIME，将PEM和MIME两者的特性进行了结合 但是MOSS有很多的执行选项，这可能导致两个不同的开发人员提出的两种MOSS邮件无法沟通 MOSS往往被认为是一种框架而不是一个规范，在实现时还要考虑许多实际问题，因此也没有被业界广泛使用 S/MIME 目前常用的端到端安全电子邮件标准：PGP和S/MIME S/MIME侧重于作为商业和团体使用的工业标准 PGP则倾向于为用户提供个人电子邮件的安全 S/MIME是在PEM的基础上建立起来的，使用RSA，与MIME一起来保护电子邮件信息 S/MIME已经成为产业界广泛认可的协议 PGP 既是一个特定的安全电子邮件应用，也是一个安全的电子邮件标准 符合PEM的绝大多数规范，但不要求PKI的存在 创造性地把RSA公钥体系的方便和传统加密体系的高度结合起来，并在数字签名和密钥认证管理机制上有非常巧妙的设计 功能强大，速度快，源代码公开 S/MIME 概述 从PEM和MIME发展而来的，提供统一的方法来接收和发送MIME数据，提供的安全服务包括认证、数据机密性、消息完整性和非否认 目标是实现安全的电子邮件，侧重于作为商业 和团体使用的工业标准 功能 提供了签名和加密消息的能力 封装数据：由任何类型的加密内容和加密该内容所用的加密密钥组成，密钥可以是一个或者多个接收方对应的多个密钥 数字签名： 通过提取待签名内容的数字摘要，用签名者的私钥加密；然后，用base64编码方法重新对内容和签名编码 轻载的透明签名：只有数字签名采用base64编码方法，没有S/MIME能力的接收方虽然无法验证签名，却可以看到消息内容 密码算法 组合三种公钥算法 DSS是其推荐的数字签名算法 Diffie-Hellman是其推荐的密钥交换算法 3DES是其推荐的消息加密算法 加密过程 解密过程 数字签名过程 消息处理过程 使用了一系列新的MIME内容类型，所有新类型都使用PKCS指示 保护MIME实体 封装数据 签名数据 透明签名 入侵检测技术 用户入侵 入侵者 入侵者通常指黑客和解密高手，一般分为： 假冒者 非法者 秘密用户 假冒者一般是外部使用者，非法者一般是内部人员，密码用户内外部用户均有可能 入侵者的攻击可能是友善的，也可能是险恶的 入侵技术 入侵者的动机是获取系统访问权或者扩大在系统中的权限范围 入侵者需要获得系统保护信息，这些信息一般以用户口令的形式存在 常用的获取口令技术有： 使用系统提供的标准账户和默认口令 穷尽所有的短口令 尝试系统在线词典中的单词或类口令单词列表 收集用户的信息 尝试用户的电话号码、房间号码、身份证号码等 尝试本国所有合法的牌照号码 使用特洛伊木马逃避访问控制 窃听远程用户和主机系统之间的线路 口令文件可以采用如下方式进行保护： 单向加密 访问控制 对于入侵者防范的主要措施有：检测和阻止 检测注重掌握攻击成功前后所采用的思路 阻止在于挫败所有可能的攻击 入侵检测 入侵检测建立的前提是假设入侵者的行为在某些情况下不同于合法用户的行为 入侵者的攻击和合法用户正常使用资源的区别不可能十分明显，甚至含有很多相似之处 审计记录 入侵检测的基本工具是审计记录 审计记录有两种方法： 原始审计记录 检测专用的审计记录 每个审计记录可以包含如下几个域： 主体：行为的发起者 动作：主体对一个对象的操作或者联合一个对象完整的操作 客体：行为的接收者 异常条件：若返回有异常，则标识出该异常情况 资源使用：大量元素的列表，每个元素都给出某些资源使用的数量 时间戳：动作发生时用来标识时间的记录 入侵检测方法 常用的入侵检测方法包括： 基于统计的方法 收集一段时间内合法用户的行为，用统计测试来观测其行为，判定该行为是否是合法用户行为 阈值检测 与一段时间间隔内的特殊时间发生的次数有关，如果发生次数超过了期望的合理次数，则认为可能存在入侵 基于轮廓的检测 归纳出每个用户过去的行为特征或者用户组过去行为的特征，用于发现有重大偏差的行为 统计方法能够有效地对付假冒者，因为假冒者不可能模仿他们盗用帐号的行为模式，但统计方法不能防范合法者 基于规则的方法 基于规则的入侵检测系统是通过观察系统中的事件，运用规则集判定一个给定的活动模式是否可疑 基于规则的渗透鉴别建立在专家系统之上，关键在于使用规则去鉴别已知的渗透或利用已知弱点的渗透 基于规则的入侵检测分成两种类型： 异常检测：定义规则，用于检测现在的行为和以前使用的模式的差别 渗透鉴别：用专家系统来查找可以的行为 基于规则的异常检测使用基于规则的方法分析审计记录，确定使用模式，并自动产生描述此模式的规则 蜜罐技术 入侵检测技术中相对较新的创新是蜜罐，蜜罐是诱导潜 在攻击者远离重要系统的一个圈套 蜜罐的功能是： 转移攻击重要系统的攻击者 收集攻击者活动的信息 希望攻击者在系统中逗留足够的时间，使管理员能对此攻击做出响应 蜜罐系统使用的工具包括灵敏的监视器和事件日志 任何对蜜罐的攻击，系统都会给出攻击成功的假相。所以系统管理员可以在不暴露真正在工作的系统条件下，有时间转移、记录、跟踪攻击者 蜜罐系统充满合法用户无法访问、但表面看起来有价值的虚假信息，因此任何对蜜罐的访问都是可疑的 软件入侵 恶意软件 软件入侵就是一些恶意软件，利用计算机系统的弱点进行攻击的恶意程序 这些恶意程序可以分成两类：依赖于宿主程序的和独立于宿主程序的威胁 病毒、蠕虫和木马 陷门 陷门是一个程序的秘密入口，通过它程序员可以不按照通常的访问步骤获得访问权，进行程序调试和测试 从功能上，陷门可以分为三个级别： 系统级：在系统层能访问数据和进程 应用级：逃逸安全机制的合法程序 密码级：能够以某种方式看懂密文 从控制方法上，陷门的分类 本地权限的提升 单个命令的远程执行 远程命令行解释器访问 远程控制GUI 后门的安装与案例 自己植入 软件漏洞 社会工程 逻辑炸弹 逻辑炸弹是最早出现的恶意软件之一，它预先规定了病毒和蠕虫的发作时间。逻辑炸弹是嵌在合法程序中的、只有当待定的事件出现时才会进行破坏的一组程序代码 特洛伊木马 特洛伊木马程序是一种实际上或者表面上看起来有某种有用功能的程序，它内部含有隐蔽代码，当被调用时会产生一些意想不到的后果 特洛伊木马使潜伏者执行非授权的功能 木马系统软件一般由木马配置程序、控制端程序和木马程序(服务器程序)等三部分组成 木马软件的常用手段 名字欺骗 文件捆绑 软件下载 Html传播 Zombie Zombie秘密地接管其它依附在Internet上的计算机，并使该计算机发动攻击，而且这种攻击很难通过追踪Zombie的创建者查出来 Zombie被用在对拒绝服务的攻击上，尤其是对Web站点的攻击。它被放置在成百上千的、属于第三方的计算机中，通过向Internet发送不可抵抗的攻击取得对目标Web站点的控制 病毒 病毒是一种可以通过修改自身来感染其它程序的程序，这种修改包括对病毒程序的复制，复制后生成的新病毒同样具有感染其他程序的功能 通过寄居在宿主程序上，计算机病毒可以暂时控制该计算机的操作系统盘 没有感染的软件一旦在带毒计算机上运行，就会在新程序中产生病毒拷贝，病毒就会通过软盘或者网络传播开来 病毒的生命周期 潜伏阶段 传染阶段 触发阶段 发作阶段 病毒的种类 寄生性病毒 引导扇区病毒 常驻存储器病毒 隐蔽性病毒 多态性病毒 蠕虫 什么是蠕虫 一种能够自我复制的计算机程序，它利用网络上计算机系统的漏洞自主的将自己复制到其它计算机上 一个独立的计算机程序，不需要宿主 自我复制，自主传播 占用系统或网络资源、破坏其它程序 不伪装成其它程序，靠自主传播 蠕虫的危害 蠕虫的传播造成网络拥塞 对计算机系统和信息安全造成波坏 蠕虫的破坏力巨大 网络蠕虫病毒利用以下网络工具进行传播 电子邮件设备 远程执行功能 远程登录功能 Morris Worm 主要攻击方法 rsh，rexec：用户的缺省模式 sendmail的debug模式 finger的缓冲区溢出 口令猜测 "},"notes/计算机网络原理.html":{"url":"notes/计算机网络原理.html","title":"计算机网络原理","keywords":"","body":"计算机网络原理 计算机网络的历史和新进展 计算机网络概述 网络提供的最基本服务：信息传递 不同的网络用所提供的服务区分 网络类型 空间距离：局域网、城域网、广域网、个域网 信息类型：数据网络、电话网络 应用类型：专用网络、通用网络 使用权：私有、公用 协议的所有权：私有、开放 互联网的发展和成功经验 互联网 全球范围、通用、异构的公用计算机网络 开放的标准：IETF 是其他类型网络的技术基础 三大定律 摩尔定律：CPU性能18个月翻番 光纤定律：骨干网带宽9个月翻番 麦特卡菲定律：网络价值随用户数平方成正比 互联网标准化组织：IETF、IRTF、IAB、IESG 互联网的核心思想：分组交换 IP 连接异构的子网 提供两种基本功能 全球唯一地址 分组通过动态路由从源节点发送到目的节点 特性 简单 每个分组携带各自的地址信息 一个路由表可以为所有的流量服务 可以适应爆炸性的增长 灵活 可以在各种底层物理网络上运行 可以支持各种应用类型 可扩展 端系统的增加 流量的增加 网络规模的增长 健壮 动态路由具有自适应的特性 牺牲一定的带宽利用率，提高健壮性 国际高速计算机网络研究计划 NGI：美国下一代互联网研究计划 中国高速计算机网络研究计划 CERNET：我国第一个全国性计算机互联网络，目前我国第二大计算机互联网 计算机网络体系结构 计算机网络的定义和组成 计算机网络的定义 定义：一批独立自治的计算机系统的互联集合体 说明：互联的手段是各种各样的，依据协议进行工作 计算机网络的组成 两级结构的计算机网络 资源子网（或用户子网） 服务器 客户计算机 通信子网 通信线路（或称信道） 网络互联设备（路由器、交换机、HUB等） 基本通信方式 交换式通信 基本特点：需要经过交换设备，转发给一个或一组结点，交换设备根据需要选择输出 典型拓扑结构：star、ring(loop)、tree 关键技术：路由选择 广播式通信 基本特点：多台计算机共享通信线路，任一台计算机发出的信息可以直接被其它计算机接收 典型拓朴结构：bus、ring 关键技术：信道分配 静态分配：分时间片，控制简单，通道利用率低 动态分配：各站点动态使用通道，控制复杂，通道利用率高 局域网络传统主要采用广播式通信技术，近年来交换式通信技术使用逐渐增加；城域网络主要采用交换式通信技术；广域网络主要采用交换式通信技术 计算机网络体系结构 对计算机网络及其部件所完成功能的比较精确的定义，即从功能的角度描述计算机网络的结构，是层次和层间关系的集合 计算机网络体系结构仅仅定义了网络及其部件通过协议应完成的功能，不定义协议的实现细节和各层协议之间的接口关系 网络功能的分层→协议的分层→体系结构的分层 协议分层易于协议的设计、分析、实现和测试 计算机网络功能的分层 计算机网络的基本功能是为地理位置不同的计算机用户之间提供访问通路 采用“层次结构”的方法来描述计算机网络，即：计算机网络中提供的功能是分成层次的 协议和协议的分层结构 协议的定义和组成 位于不同计算机上进行对话的第N层通信各方可分别看成是一种进程，称为对等(同等)进程 协议：计算机网络同等层次中，通信双方进行信息交换时必须遵守的规则 协议的组成：语法、语义、定时关系 协议的分层和层间结构 协议分层 目的主机第N层收到的报文与源主机第N层发出的报文相同 洋葱结构 协议分层要保证整个通信系统功能完备、高效 相邻层之间都有一个接口，它定义了下层向上层提供的原语操作和服务 对于第N层协议来说，它有如下特性： 不知道上、下层的内部结构 独立完成某种功能 为上层提供服务 使用下层提供的服务 计算机网络的体系结构 基本术语与分层结构： 协议、服务、接口 服务访问点SAP 任何层间服务是在接口的SAP上进行的 每个SAP有唯一的识别地址 每个层间接口可以有多个SAP 接口数据单元IDU IDU是通过SAP进行传送数据的层间信息单元 IDU由上层的服务数据单元SDU和接口的控制信息ICI组成 协议数据单元PDU 第N层实体通过网络传送给它的对等实体的信息单元 PDU由上层的服务数据单元SDU或其分段和协议控制信息PCI组成 服务分类和服务原语 面向连接的服务和无连接服务 面向连接的服务 当使用服务传送数据时，首先建立连接，然后使用该连接传送数据，使用完后，关闭连接 特点：顺序性好 无连接服务 直接使用服务传送数据，每个包独立进行路由选择 特点：顺序性差 连接并不意味可靠，可靠要通过确认、重传等机制来保证 服务原语 服务在形式上是由一组接口原语(或操作)来描述的 服务原语可分为四种类型：请求、指示、响应、确认 分层原则 优点：模块化、功能抽象、可重用 缺点：信息隐藏、实现低效 端到端原则 核心简单，边缘复杂 只有对性能有明显提升才可以放在底层 典型计算机网络参考模型 计算机网络的标准化 电信标准：ITU 国际标准：ISO 其它标准化组织：ANSI、NIST、IEEE、OIF、CCSA Internet标准 Internet的标准是自发而非政府干预的，称为RFC 在IAB下成立了IETF和IRTF OSI参考模型 物理层：在物理线路上传输原始的二进制数据位(基本网络硬件) 数据链路层：在有差错的物理线路上提供无差错的数据传输 网络层：控制通信子网提供源点到目的点的数据传送 传输层：为用户提供端到端的数据传送服务 会话层：为用户提供会话控制服务(安全认证) 表示层：为用户提供数据转换和表示服务 应用层：为用户提供各种Internet管理和应用服务功能 TCP/IP参考模型 TCP/IP参考模型把物理层和数据链路层合起来称为：Host-to-Network网络接口层 Internet层(网络层)：控制通信子网提供源点到目的点的IP包传送，实现异构网络互联 传输层：提供端到端的数据传送服务，TCP和UDP 应用层：提供各种Internet管理和应用服务功能 其它网络体系结构 Novell NetWare Novell公司开发的PC上的网络操作系统，C/S结构 基本思想：文件共享 基于XNS，但有很多改进 网络层协议：IPX，不可靠无连接协议 传输层协议：NCP、SPX，面向连接的协议 X.25分组交换网 面向连接，支持交换虚电路和永久虚电路 定义了三层协议 物理层协议：X.21，X.3/X.28/X.29 数据链路层协议：LAP，LAPB 网络层协议：PLP B-ISDN和ATM 宽带业务数字网B-ISDN B-ISDN的技术基础是异步传输模式ATM ATM 异步传输，没有主时钟 传输单元是短的、定长的包，称为信元 面向连接 速率主要有两种：155M，622M 数据通信基本原理 数据通信基础理论 研究信号在通信信道上传输时的数学表示及其所受到的限制 傅里叶分析 时域观 从时间函数的角度来看，电磁信号分为模拟信号和数字信号 模拟信号的信号强度随着时间平滑变化，数字信号的信号强度在一段时间内保持一个恒定值然后又变成另外一个恒定值 频域观 基本定义 当一个信号的所有频率成分是某一个频率的整数倍时，该频率被称为基本频率 信号的周期等于基本频率的周期 傅里叶分析 g(t)=12c+∑n=1∞ansin(2πnft)+∑n=1∞bncos(2πnft)g(t)=\\frac{1}{2}c+\\sum_{n=1}^{\\infty}a_nsin(2\\pi nft)+\\sum_{n=1}^{\\infty}b_ncos(2\\pi nft)g(t)=​2​​1​​c+∑​n=1​∞​​a​n​​sin(2πnft)+∑​n=1​∞​​b​n​​cos(2πnft) c=2T∫0Tg(t)dt,an=2T∫0Tg(t)sin(2πnft)dt,bn=2T∫0Tg(t)cos(2πnft)dtc=\\frac{2}{T}\\int_0^Tg(t)dt,a_n=\\frac{2}{T}\\int_0^Tg(t)sin(2\\pi nft)dt,b_n=\\frac{2}{T}\\int_0^Tg(t)cos(2\\pi nft)dtc=​T​​2​​∫​0​T​​g(t)dt,a​n​​=​T​​2​​∫​0​T​​g(t)sin(2πnft)dt,b​n​​=​T​​2​​∫​0​T​​g(t)cos(2πnft)dt 有限带宽信号 频谱是一个信号所包含的频率的范围 信号的绝对带宽等于频谱的宽度 许多信号的带宽是无限的，然而信号的主要能量集中在相对窄的频带内，这个频带被称为有效带宽，或带宽 信号的信息承载能力与带宽有直接关系，带宽越宽，信息承载能力越强 信号在信道上传输时的特性：信道有截止频率fcf_cf​c​​，0~fcf_cf​c​​的振幅衰减较弱，fcf_cf​c​​以上的振幅衰减厉害，这主要由信道的物理特性决定，0~fcf_cf​c​​是信道的有限带宽 波特率和比特率的关系 波特率：每秒钟信号变化的次数，也称调制速率 比特率：每秒钟传送的二进制位数 波特率与比特率的关系取决于信号值与比特位的关系 信道的最大数据传输速率 奈奎斯特定理 最大数据传输率=2Hlog2V(bps)2Hlog_2V(bps)2Hlog​2​​V(bps) 任意信号通过一个带宽为H的信道，则每秒采样2H次就能完整地重现该信号，信号电平分为V级 香农定理 随机噪声出现的大小用信噪比来衡量：10log10S/N10log_{10}S/N10log​10​​S/N，单位：分贝 带宽为H赫兹，信噪比为S/N的任意信道的最大数据传输率为：Hlog2(1+S/N)(bps)Hlog_2(1+S/N)(bps)Hlog​2​​(1+S/N)(bps) 此式是利用信息论得出的，具有普遍意义 与信号电平级数、采样速度无关 此式仅是上限，难以达到 数据通信技术 研究数据在通信信道上的各种传输方式及其所采用的技术 数据通信系统的基本结构 传输和传输方式 数字传输/模拟传输 并行传输/串行传输 点到点传输/点到多点传输 连接方式：为适应不同的需要，通信线路采用不同的连接方式 单工、半双工和全双工传输 单工传输：信息只能单向传输，监视信号可回送 半双工传输：信息可以双向传输，但在某一时刻只能单向传输 全双工传输：信息可以同时双向传输 同步传输/异步传输 同步方式：接收方必须知道每一位信号的的开始及其持续时间，以便正确的采样接收 异步传输 信息传送以字符为单位 每个字符由发送方异步产生，有随机性 需要辅助位 传输效率低 主要用于字符终端与计算机之间的通信 同步传输 信息传送以报文为单位 传输开始时以同步字符使收发双方同步 从传输信息中抽取同步信息，修正同步，保证正确采样 可以不间断地传输信息，传输效率较高 字符间减少了辅助信息 传输的信息中不能有同步字符出现，需要透明传输处理 基于位的传输，一般采用同步传输 信息以二进制位流为单位发送 传输过程中收发双方以位为单位同步 传输的开始和结束由特定的八位二进制位同步 数据编码技术 数据表示 模拟数据，连续值 数字数据，离散值 数据传输方式 以信号作为载体 模拟信号 数字信号 数字数据的数字传输（基带传输） 基带：基本频带，指传输变换前所占用的频带，是原始信号所固有的频带 基带传输：在传输时直接使用基带信号 基带传输是一种最简单最基本的传输方式，一般用低电平表示0，高电平表示1 适用范围：低速和高速的各种情况 限制：因基带信号所带的频率成分很宽，所以对传输线有一定的要求 常用的几种编码方式 不归零制码（NRZ） 原理：低电平表示0，高电平表示1 缺点： 难以分辨一位的结束和另一位的开始 发送方和接收方必须有时钟同步 若信号中0或1连续出现，信号直流分量将累加 结论：容易产生传播错误 曼彻斯特编码，也称相位编码 原理：每一位中间都有一个跳变，从低跳到高表示0，从高跳到低表示1 优点：克服了NRZ码的不足，每位中间的跳变既可作为数据，又可作为时钟，能够自同步 差分曼彻斯特编码 原理：每一位中间都有一个跳变，每位开始时有跳变表示0，无跳变表示1，位中间跳变表示时钟，位前跳变表示数据 优点：时钟、数据分离，便于提取 逢1变化的NRZ码 原理：在每位开始时，逢1电平跳变，逢0电平不跳变 逢0变化的NRZ码 原理：在每位开始时，逢0电平跳变，逢1电平不跳变 数字信号的模拟传输，也称频带传输 指在一定频率范围内的线路上，进行载波传输，用基带信号对载波进行调制，使其变为适合于线路传送的信号 调制：用基带脉冲对载波信号的某些参量进行控制，使这些参量随基带脉冲变化 解调：调制的反变换 调制解调器MODEM 根据载波的三个特性：幅度、频率、相位，产生常用的三种调制技术： 幅移键控法（调幅） 频移键控法（调频） 相移键控法（调相） 模拟数据的数字传输 解决模拟数据数字化问题，也称为脉冲代码调制PCM 根据奈奎斯特原理进行采样 常用的PCM技术：将模拟信号振幅分为多级(2n2^n2​n​​)，每一级用n位表示 差分脉冲代码调制 原理：不是将振幅值数字化，而是根据前后两个采样值的差进行编码，输出二进制数字 δ\\deltaδ调制 原理：根据每个采样值与前一个值之间的差来决定输出二进制1或0 缺点：编码速度跟不上变化太快的信号 多路复用技术 时分复用TDM 频分复用FDM 波分复用WDM 交换技术 通信网络可以根据其结点交换信息的方式进行分类 动态地接通、断开、切换通信线路，称为交换 交换方式分类 电路交换 原理：直接利用可切换的物理通信线路，连接通信双方 三个阶段：建立电路、传输数据、拆除电路 特点： 在发送数据前，必须建立起点到点的物理通路 建立物理通路时间较长，数据传送延迟较短 复用/解复用 一般采用时分复用 时间被分为帧，帧被分为时槽 时槽在帧内的相对位置决定这个槽所传输数据所属的会话 发送方和接收方需要同步 报文交换 原理：信息以报文(逻辑上完整的信息段)为单位进行存储转发 特点 线路利用率高 要求中间节点(网络通信设备)缓冲大 延迟时间长 分组交换(包交换) 原理 分组：比报文还小的信息段，可定长，也可变长 信息以分组位单位进行存储转发，源结点把报文分为分组，在中间结点存储转发，目的节点把分组合成报文 特点 每个分组头包括源地址和目的地址，独立进行路由选择 网络结点设备中不预先分配资源 线路利用率高 易于重传，可靠性高 易于开始新的传输，让紧急信息优先通过 开销增加 分组交换分为 数据报分组交换 每个分组均带有网络地址(源、目的)，可走不同的路径 虚电路分组交换 电路交换和分组交换的结合 数据以分组形式传输 来自同一流的分组通过一个预先建立的路径(虚电路传输) 确保分组的顺序 但是来自不同虚电路的分组可能会交错在一起 分三个阶段 建立：发带有全称网络地址的呼叫分组，建立虚电路 传输：沿建立好的虚电路传输数据 拆除：拆除虚电路 复用/解复用 采用统计复用，按需分配信道资源 来自任意会话的数据可以立即发送，不需要等待时槽 用附加的分组头来区分数据 电路交换与分组交换的比较 分组交换相比电路交换的最大优势是可以实现统计复用，有效的利用带宽 分组交换需要处理拥塞 实际应用中，这两种方式可以结合在一起 不同交换技术的比较 电路交换适用于实时信息和模拟信号传送，在线路带宽比较低的情况下使用比较经济 报文交换适用于线路带宽比较高的情况，可靠灵活，但延迟大 分组交换缩短了延迟，也能满足一般的实时信息传送，在高带宽的通信中更为经济、合理、可靠，使目前公认较(最)好的一种交换技术 交换结构 crossbar交换：无阻塞的内部交换 空分交换：多个crossbar互联，无阻塞/有阻塞均可 时分交换：使用高效处理解决 物理层接口及其协议 物理层的定义和功能 物理层的定义 ISO/OSI关于物理层的定义：物理层提供机械的、电气的、功能的和规程的特性，目的是启动、维护和关闭数据链路实体之间进行比特传输的物理连接，这种连接可能通过中继系统，在中继系统内的传输也是在物理层 物理层的功能 在两个网络设备之间提供透明的比特流传输 研究内容 物理连接的启动和关闭，正常数据的传输，以及维护管理 物理层有关的传输方式 连接方式（点到点，点到多点） 通信方式（单工，半双工，全双工） 位传输方式（串行，并行） 物理层的四个重要特性 机械特性 电气特性 功能特性 规程特性 物理层的特性 机械特性 主要定义物理连接的边界点，即接插装置，规定物理连接时所采用的规格、引脚的数量和排列情况 电气特性 规定传输二进制位时，线路上信号的电压高低、阻抗匹配、传输速率和距离限制 功能特性 主要定义各条物理线路的功能 线路的功能主要分为四大类 数据 控制 定时 地 规程特性 主要定义了各条物理线路的工作规程和时序关系 典型的物理层标准接口 EIA RS-232-C EIA RS-449/422-A/423-A 传输介质 双绞线 既可用于模拟传输，也可用于数据传输 带宽依赖线的类型和传输距离 3类线，5类线，增强型5类线、6类线、7类线 非屏蔽双绞线UTP，屏蔽双绞线STP 基带同轴电缆 50欧姆，用于数据传输 宽带同轴电缆 75欧姆，用于模拟传输 Cable TV 技术，300MHz或450MHz 光纤 光线分类：单模光纤和多模光纤 能够反射的角度有多个，这种传播称为多模，多模光纤适用于短距离传输 当光纤半径减小到波长的数量级时，只有一个角度(或者一个模式)的光可以进入，这种形式的传播称为单模，单模光纤适用于长距离传输 单模和多模都支持同时传输几个波长的光，支持波分复用 常用的三个波长窗口（光纤波段）：850nm、1310nm、1550nm 光网络 组网方式 点到点：四根线（两根用于保护倒换） 环：两根线（一根用于保护倒换） 中继器：光——电——光，全光 全光网，光因特网论坛OIF 网络传输技术 光线传输 SONET/SDH，采用TDM技术，是同步系统，由主时钟控制，时钟精度10−910^{-9}10​−9​​秒 SONET路径：路径、线路、段 基本SONET帧：810字节/125μs，传输速率51.84Mbps，基本SONET信道称为STS-1 复用：基于字节 移动电话网络 单方向的寻呼系统：需要很小的带宽 蜂窝电话 第一代：模拟蜂窝电话，只能传送话音 第二代：数字蜂窝电话，主要传送话音，GSM，CDMA 3G/4G：可以传送话音和数据 模拟蜂窝电话 早期用于军事通信，一个信道，半双工 IMTS，双频，全双工 AMPS 使用小的蜂窝 在附近(不相邻)的蜂窝中重用传输频率 发射功率小，设备小而便宜 当某个蜂窝内的用户超过系统容量时，将蜂窝划分为几个更小的蜂窝，以便重用频率，并将发射功率减弱 在蜂窝中心有一个基站，基站包括一个计算机和与天线相连的收发器 无线传输 通信卫星 公共交换电话网络 有线电视网络 数据链路控制及其协议 数据链路层概述 定义和功能 如何在有差错的线路上，进行无差错的传输 数据链路层的目的是为了提供功能上和规程上的方法，以便建立、维护和释放网络实体间的数据链路 基本概念 结点：网络中的主机和网络设备(路由器、交换机等) 链路：通信路径上连接相邻结点的通信信道 数据链路层协议定义了一条链路的两个结点间交换的数据单元格式，以及结点发送和接收数据单元的动作 点到点通信：一条链路上两个相邻结点间的通信 端到端通信：从源结点到目的结点的通信，通信路径可能由多个链路组成 实际数据通路与虚拟数据通路 数据链路控制规程 为使数据能迅速、正确、有效地从发送点到达接收点所采用的控制方式 数据链路层协议应提供的基本功能 数据在数据链路层上的正常传输(建立、维护和释放) 组帧：定界与同步，处理透明传输问题 差错控制：检错和纠错 顺序控制(可选) 流量控制(可选)：基于反馈机制 为网络层提供的服务 无确认无连接服务，适用于 误码率很低的线路，错误恢复留给高层 实时业务 大部分局域网 有确认无连接服务，适用于不可靠的信道，如无线网 有确认有连接服务 组帧 将比特流分成离散的帧，并计算每个帧的校验和 组帧方法 字符计数法 在帧头用一个域来表示整个帧的字符个数 缺点：若计数出错，对本帧和后面的帧有影响 带字符填充的字符定界法 起始字符DLE STX，结束字符DLE ETX 字符填充 缺点：局限于8位字符和ASCII字符传送 带位填充的标记定界法 帧的起始和结束都用一个特殊的位串01111110，称为标记 0比特插入删除技术 物理层编码违例法 只适用于物理层编码有冗余的网络 错误检测和纠正 差错出现的特点：随机，连续突发 处理差错的两种基本策略 使用纠错码 使用检错码 纠错码 码字：一个帧包括m个数据位，r个校验位，n=m+r，则此n比特单元称为n位码字 海明距离：两个码字之间不同的对应比特位数目 设计纠错码：(m+r+1)≤2r(m+r+1)\\leq2^r(m+r+1)≤2​r​​ 海明码 码位从左边开始编号，从1开始 位号为2的幂的位是校验位，其余是信息位 每个校验位使得包括自己在内的一些位的奇偶值为偶数(或奇数) 为看清数据位k对哪些校验位有影响，将k写成2的幂的和 检错码 使用纠错码传数据，效率低，适用于不可能重传的场合；大多数情况采用检错码加重传 循环冗余码(CRC码，多项式编码) 生成多项式G(x) 发方、收方事先商定 生成多项式的高位和低位必须为1 生成多项式应该比传输信息对应的多项式短 CRC码基本思想 校验和加在帧尾，使带校验和的帧的多项式能被G(x)除尽；收方接收时，用G(x)去除它，若有余数，则传输出错 基本的数据链路层协议 无约束的单工协议 工作在理想情况，几个前提 单工传输 发送方无休止工作(要发送的信息无限多) 接收方无休止工作(缓冲区无限大) 通信线路(信道)不损失或丢失信息帧 工作过程 发送程序：取数据，构成帧，发送帧 接收程序：等待，接收帧，送数据给高层 单工停等协议 增加约束条件：接收方不能无休止接收 解决方法：接收方每收到一个帧后，给发送方回送一个响应 工作流程 发送程序：取数据，组帧，发送帧，等待响应帧 接收程序：等待，接收帧，送数据给高层，回送响应帧 有噪声信道的单工协议 增加约束条件：信道(线路)有差错，信息帧可能损坏或丢失 解决办法：出错重传 带来的问题 什么时候重传——定时 响应帧坏了怎么办(重复帧)——发送帧头中放入序号 为了使帧头精简，序号取多少位——1位 发方在发下一个帧之前等待一个肯定确认的协议叫做PAR或ARQ 如果确认帧没有序号，则协议3有漏洞 由于确认帧中没有序号，超时时间不能太短，否则协议失败 滑动窗口协议 单工——>全双工 捎带/载答：暂时延迟待发确认，以便附加在下一个待发数据帧的技术 优点：重复利用信道带宽，减少帧的数目意味着减少帧到达中断 带来的问题：复杂 滑动窗口协议工作原理 发送的信息都有一个序号，从0到某个最大值，0~2n2^n2​n​​-1，一般用n个二进制位表示 发送端始终保持一个已发送但尚未确认的帧的序号表，称为发送窗口，发送窗口的上界表示要发送的下一个帧的序号，下界表示未得到确认的帧的最小序号，发送窗口大小=上界-下界，大小可变 发送端没发送一个帧，序号取上界值，上界加1；没接收到一个确认序号=发送窗口下界的正确响应帧，下界+1；若确认序号落在发送窗口之内，则发送窗口下界连续加1，直到发送窗口下界=确认序号+1(累计确认) 接收端有一个接收窗口，大小固定，但不一定与发送窗口相同，接收窗口的上界表示允许接收的最大序号，下界表示希望接收的序号 接收窗口容纳允许接收的信息帧，落在窗口外的帧均被丢弃，序号等于下界的帧被正确接收，并产生一个响应帧，上界、下界都加1，接收窗口大小不变 一比特滑动窗口协议 协议特点 窗口大小：N=1 可进行数据双向传输，信息帧中可含有确认信息 信息帧中包括两个序号域，发送序号和确认序号 存在问题 能保证无差错传输，但是基于停等方式 若双方同时开始发送，则会有一半重复帧 效率低，传输时间长 一般情况下，信道带宽b比特/秒，帧长度L比特，往返传输延迟R秒，则信道利用率为(L/b)/(L/b+R)=L/(L+Rb) 结论：传输延迟大，信道带宽高，帧短时，信道利用率低 退后n帧重传协议 改进 发送窗口大于1，接收窗口为1 接收方从坏帧起丢弃所有后继帧，发送方从坏帧开始重传 对于出错率较高的信道，浪费带宽 发送方有流量控制，为重传设缓冲 发送窗口尺寸 由于有多个未确认帧，需要设多个计时器 启动，发送帧时启动 停止，收到正确确认帧时停止 超时则产生timeout事件 选择重传协议 改进 发送窗口大于1，接收窗口大于1 接收方可暂存坏帧的后继帧，发送方只重传坏帧 接收窗口较大时，需较大缓冲区 目的 采用选择重传技术在不可靠信道上传输时，不会因不必要的重传而浪费信道资源 窗口设置 保证接收窗口移动前后，接收窗口内的帧没有重叠 当发送窗口尺寸 ≥ 接收窗口尺寸时，接收窗口尺寸最大值为(MaxSeq + 1) / 2 当发送窗口尺寸 ＜ 接收窗口尺寸时，要求发送窗口尺寸 + 接收窗口尺寸 ≤ 序号个数 缓冲区设置 发送方和接收方的缓冲区大小应等于各自窗口大小 增加确认计时器，解决两个方向负载不平衡带来的阻塞问题 可随时发送否定性确认帧NAK 协议说明与验证 协议工程与协议的形式化描述技术 协议工程 协议说明 既定义一个协议实体提供给它的用户的服务，又定义该协议实体的内部操作 协议验证 验证协议说明是否完整正确 协议实现 用硬件和/或软件实现协议说明中规定的功能 协议测试 用测试的方法来检查协议实现是否满足要求 一致性测试 互操作性测试 性能测试 协议形式化描述技术 形式化描述技术FDT/形式化方法FM广泛应用于协议工程研究中 一种形式化方法总是以一种形式体系为基础，只是在具体应用时，大都做了便于描述的改进和补充 常用的形式化方法 有限状态机FSM 形式化语言模型 Petri网 进程代数 有限状态机模型 一个有限状态机是一个四元组(S,M,I,T)，其中S是状态的集合，M是标号的集合，I是初始状态的集合，T是变迁的集合 网络协议建模 基本出发点：认为通信协议主要是由响应多个“事件”的相对简单的处理过程组成 事件 命令(来自用户) 信息到达(来自底层) 内部超时 优点：简单明了，比较精确 缺点：复杂协议的事件数和状态数会剧增，状态爆炸 Petri网模型 Petri网定义 结构元素 位置：描述系统状态，用一个圆圈表示 变迁：描述修改系统状态的事件，用一个长方形或线段表示 弧：描述状态与事件之间的关系，包括输入弧和输出弧，用有向弧表示 活动元素——标记 变迁实施规则 Petri网的组成 条件/事件网：每个位置最多一个标记，表示条件 位置/变迁网：每个位置中的标记可以有多个 高级Petri网 常用的数据链路层协议 数据链路层协议分类 面向字符的链路层协议：PPP 面向比特的链路层协议：HDLC、LAPB 高级数据链路层控制规程HDLC 1976年，ISO提出HDLC HDLC的组成 帧结构 规程元素 规程类型 使用HDLC的语法可以定义多种具有不同操作特点的链路层协议 HDLC的适用范围 计算机与计算机通信 计算机与终端通信 终端与终端通信 数据站，由计算机(路由器)和终端组成，负责发送和接收帧，HDLC涉及三种类型的站 主站：主要功能是发送命令，接收响应，负责整个链路的控制 次站：主要功能是接收命令，发送响应，配合主站完成链路的控制 组合站：同时具有主、次站功能，既发送又接收命令和响应，并负责整个链路的控制 HDLC适用的链路构型 非平衡型：适合把智能和半智能的终端连接到计算机 点到点式 点到多点式 平衡型：适合于计算机与计算机之间的连接 主站——次站式 组合式 HDLC的基本操作模式 正规响应模式NRM 异步响应模式ARM 异步平衡模式ABM HDLC帧结构 定界符 01111110 空闲的点到点链路上连续传定界符 地址域 多终端线路，用来区分终端 点到点线路，有时用来区分命令和响应 控制域 数据域 校验和 帧类型：信息帧、监控帧、无序号帧 X.25的链路层协议LAPB X.25协议 分组级：PLP 帧级：LAP，LAPB 物理级：X.21 X.25协议规程使用HDLC规程的原理和术语 X.25 LAP、LAPB是HDLC的子集 LAPB的帧格式与HDLC完全相同 PPP协议 PPP改进了SLIP，提供差错校验、支持多种协议、允许动态分配IP地址、支持认证等 以帧为发送单位，而不是原始IP包 协议包括两部分 链路控制协议LCP：可使用多种物理层服务 网络控制协议NCP：可支持多种网络层协议 帧格式与HDLC相似，区别在于PPP是面向字符的，采用字符填充技术 通常不使用滑动窗口技术，但是也具有利用HDLC帧进行可靠传输的可选功能 局域网与介质访问子层 局域网概述 定义：局域网是一种将小区域内的各种通信设备互联在一起的通信网络 局域网的基本特点：高传输率、短距离、低出错率 局域网发展趋势：高速、无线 局域网拓朴结构 星型结构 环形结构 总线型结构 树型结构 传输介质 双绞线 基带同轴电缆 光纤 无线 局域网技术 信道分配 计算机网络可以分成两类 使用点到点连接的网络——广域网 使用广播信道的网络(多路访问信道，随机访问信道)——局域网 解决信道争用的协议称为介质访问控制协议MAC，是数据链路层协议的一部分 信道分配方法有两种 静态分配 频分多路复用FDM(波分复用WDM) 原理：将频带平均分配给每个要参加通信的用户 优点：适合于用户较少，数目基本固定，各用户的通信量都较大的情况 缺点：无法灵活地适应站点数及其通信量的变化 时分多路复用TDM 原理：每个用户拥有固定的信道传送时槽 优点：适合于用户较少，数目基本固定，各用户的通信量都较大的情况 缺点：无法灵活地适应站点数及其通信量的变化 动态分配 信道分配模型 独立站点假设 单信道假设 冲突假设 确定何时发送：连续时间/时间分槽 确定能否发送：载波监听/非载波监听 多路访问协议 定义：控制多个用户共用一条信道的协议 ALOHA协议 目的：解决信道的动态分配 基本思想可用于任何无协调关系的用户争用单一共享信道使用权的系统 分类 纯ALOHA协议 基本思想：用户有数据要发送时，可以直接发至信道；然后监听信道看是否产生冲突，若产生冲突，则等待一段随机的时间重发 多用户共享单一信道，并由此产生冲突，这样的系统称为竞争系统 信道效率：最高18.4% 分槽ALOHA协议 基本思想：把信道时间分成离散的随机槽，槽长为一个帧所需的发送时间，每个站点只能在时槽开始时才允许发送，其它过程与纯ALOHA协议相同 信道效率：最高36.8% 载波监听多路访问协议CSMA 载波监听 站点在为发送帧而访问传输信道之前，首先监听信道有无载波 若有载波，说明已有用户在使用信道，则不发送帧以避免冲突 多路访问 多个用户共用一条线路 1-坚持型CSMA 原理 若有站点有数据发送，先监听信道 若站点发现信道空闲，则发送 若信道忙，则继续监听直至发现信道空闲，然后完成发送 若产生冲突，等待一随机时间，然后重新开始发送过程 优点：减少了信道空闲时间 缺点：增加了发生冲突的概率 广播延迟对协议性能的影响 广播延迟越大，发生冲突的可能性越大，协议性能越差 非坚持型CSMA 原理 若站点有数据发送，先监听信道 若站点发现信道空闲，则发送 若信道忙，等待一随机时间，然后重新开始发送过程 若产生冲突，等待一随机时间，然后重新开始发送过程 优点：减少了冲突的概率 缺点：增加了信道空闲时间，数据发送延迟增大 随着每个帧时发送帧数量的增加，非坚持型CSMA信道效率比1-坚持CSMA高，传输延迟比1-坚持CSMA大 p-坚持型CSMA 适用于分槽信道 原理 若站点有数据发送，先监听信道 若站点发现信道空闲，则以概率p发送数据，以概率q=1-p延迟至下一个时槽发送，若下一个时槽仍空闲，重复此过程，直至数据发出或时槽被其它站点所占用 若信道忙，则等待下一个时槽，重新开始发送 若产生冲突，等待一随机时间，然后重新开始发送 带冲突检测的载波监听多路访问协议CSMA/CD 引入原因 当两个帧发生冲突时，两个被损坏帧继续传送毫无意义，而且信道无法被其它站点使用，浪费信道 如果站点边发送边监听，并在监听到冲突之后立即停止发送，可以提高信道的利用率，因此产生了CSMA/CD 原理 站点使用CSMA协议进行数据发送 在发送期间如果检测到冲突，立即停止发送，并发出一个瞬间干扰信号，使所有站点都知道发生了冲突 在发出干扰信号后，等待一随机时间，再新开始发送 最坏情况下，一个站点确定发生冲突要花2倍电缆传输时间 无冲突协议 工作状态 传输周期 竞争周期 空闲周期 基本位图协议 工作原理 共享信道上有N个站，竞争周期分为N个时槽，如果一个站有帧发送，则在对应的时槽内发送比特1 N个时槽之后，每个站都知道哪个站要发送帧，这时按站序号发送 像这样在实际发送信息前先广播发送请求的协议称为预留协议 效率 轻负载下，效率为d/(N+d)，数据帧由d个时间单位组成 重负载下，效率为d/d+1 缺点 与站序号有关的不平等性，序号大的站得到服务好 每个站都有1比特的开销 二进制下数法 工作原理 所有站的地址用等长二进制位串表示，若要占用信道，则广播该位串 不同站发的地址中的位做”或”操作，一旦某站了解到比本站地址高位更高的位置被置为”1”，便放弃发送请求 效率：d/(d+log2Nlog_2Nlog​2​​N) 有限竞争协议 占用信道的策略 竞争方法 轻负载下，发送延迟小；重负载下，信道效率高 无冲突方法 轻负载下，发送延迟大；重负载下，信道效率高 有限竞争方法 结合以上两种方法，轻负载下使用竞争，重负载下使用无冲突方法 减少竞争的站的数目可以增加获取信道的概率 基本思路：将站分组，组内竞争 适应树搜索协议 站点组织成二叉树 当系统负载很重时，从根节点开始竞争发生冲突的概率非常大，为提高效率，可以从中间结点开始竞争 无线局域网协议 无线局域网的特点 只有一个信道 短距离传输 一个站点发送的信号，只能被它周围一定范围内的站点接收到 无线局域网与有线局域网不同 隐藏站点问题 由于站点距离竞争者太远，从而不能发现潜在介质竞争者的问题 暴露站点问题 由于非竞争者距离发送站点太近，从而导致介质非竞争者不能发送数据的问题 传统的CSMA协议不适合于无线局域网，需要特殊的MAC子层协议 CSMA 电缆上的信号传播给所有站点 CSMA只判断发送站点周围是否有其它活跃发送站点 冲突被发送站点发现 某一时刻，信道上只能有一个有效数据帧 无线局域网 信号只能被发送站点周围一定范围内的站点接收 需要尽量保证接收站点周围一定范围内只有一个发送站点 冲突被接收站点发现 某一时刻，信道上可以有多个有效数据帧 MACA 是IEEE 802.11无线局域网标准的基础 基本思想：发送站点刺激接收站点发送应答短帧，从而使得接收站点周围的站点监听到该帧，并在一定时间内避免发送数据 基本过程 A向B发送RTS帧，A周围的站点在一定时间内不发送数据，以保证CTS帧返回给A B向A回答CTS帧，B周围的站点在一定时间内不发送数据，以保证A发送完数据 A开始发送 若产生冲突，采用二进制指数后退算法等待随机时间，再重新开始 MACAW 对MACA协议做了改进，提高了性能 主要改进 对每个成功传输的数据帧，都要产生确认帧 增加了发送站点的载波监听 发生冲突后，针对每个数据流(相同源和目的地址)执行后退算法，而不是针对每个站点 发生拥塞时，站点间交互信息 IEEE 802.3和Ethernet 逻辑链路控制子层LLC 引入LLC子层的原因 MAC子层只提供尽力而为的数据报服务，不提供确认机制和流量控制(滑动窗口) 有些情况下，这种服务足够，如支持IP协议；当需要确认和流控的时候，这种服务就不能满足，需要LLC 对于同一个LLC，可以提供多个MAC选择 LLC子层提供确认机制和流量控制 LLC隐藏了不同802MAC子层的差异，为网络层提供单一的格式和接口 LLC提供三种服务选项：不可靠数据报服务、有确认数据报服务、可靠的面向连接的服务 LLC帧头基于HDLC协议 介质访问控制子层MAC MAC子层的功能 数据帧封装、发送和接收 组帧(帧定界、帧同步) 寻址(源和目的MAC地址处理) 差错检测 介质访问管理 介质分配(避免冲突) 冲突解决(处理冲突) IEEE 802.3和Ethernet IEEE定义了采用1-坚持型CSMA/CD技术的802.3局域网标准 IEEE 802.3标准与以太网协议略有差别 802.3采用的电缆标准 10Base5：粗缆，AUI接口 10Base2：细缆，BNC接口，T型头 10Base-T：RJ-45接口 10Base-F：光纤接口 物理层类型用以下域表示 10Base5含义 10：10Mbps Base：基带传输 5：500米 收发器：处理载波监听和冲突检测 布线拓扑结构：总线型、脊椎型、树形、分段 三种电缆布线 扩展网段长度 中继器：物理层设备，只对信号进行接收、放大和双向重传 两个收发器之间最多使用4个中继器，最长2500米 802.3的信号编码 由于曼彻斯特编码简单，所有的802.3基带系统都使用曼彻斯特编码 802.3的MAC子层帧格式 前导序列(7个字节10101010) 帧开始标志(1字节，10101011) 目的地址和源地址 2或6个字节，以太网为6个字节 目的地址第一位为0，表示单地址；为1，表示组地址，支持组播；目的地址全1，为广播地址。源地址第一位为0 地址中的第二位用来区分本地地址和全球地址 帧长度域(2字节，取值在0-1500之间) 数据(0-1500字节) 填充(0-46字节) 校验和：CRC校验(4个字节) 最短帧长 避免帧的第一个比特到达电缆的远端前帧已经发完，帧发送时间应该大于2τ 10Mbps LAN，最大冲突检测时间为51.2微秒，最短帧长为64字节 网络速度提高，最短帧长也应该增大或者站点间的距离要减小 二进制指数后退算法 将冲突发生后的时间划分为51.2微秒的时槽 第i次冲突后，在0至2i−12^i-12​i​​−1间随机地选择一个等待的时间槽数，再开始重传 10次冲突后，选择等待的时槽数固定在0至210−12^{10}-12​10​​−1间 16次冲突后，发送失败，报告上层 交换式802.3 LAN 目的：减少冲突 两种实现方法 一个卡内是一个802.3LAN，构成自己的冲突域，卡间并行 使用端口缓存，无冲突发生 快速以太网 标准：已合并到IEEE 802.3中 对10Mbps 802.3 LAN的改进 一种方法是改进10Base-5或10Base-2，采用CSMA/CD，最大电缆长度减为1/10，未被采纳 另一种方法是改进10Base-T，使用HUB，被采纳 100Base-T4：4对双绞线，1对to the hub，1对from the hub，另外2对根据数据传输方向变换 100Base-TX：2对5类平衡双绞线或150Ω屏蔽平衡电缆，1对to the hub，1对from the hub，全双工 100Base-FX：使用2根多模光纤，全双工 100Bae-T4和100Base-TX统称为100Base-T 两种类型的HUB：共享式HUB、交换式HUB 千兆以太网 标准：已合并到IEEE 802.3中 物理层实体 在一个冲突域内，只允许一个repeater 万兆以太网 标准：IEEE 802.3ae 帧格式与10/100/1000M以太网的帧格式完全相同 不再使用铜线而只使用光纤作为传输介质 只工作在全双工方式，不使用CSMA/CD协议，传输距离大大提高 由两种不同的物理层：局域网物理层、可选的广域网物理层 其它局域网技术 IEEE 802.5和令牌环 IEEE 802.5标准是主要基于IBM的令牌环网络的，但是也有一些细微的差别 技术特点 环实际上并不是一个广播介质，而是不同的点到点链路组成的环，点到点链路有很多技术优势 各个站点是公平的，获得信道的时间有上限，避免冲突发生 基本思想 令牌是一种特殊的比特组合模式，一个站要发送帧时，需要抓住令牌，并将其移出环 环本身必须有足够的时延容纳一个完整的令牌，时延由两部分组成：每站的1比特延迟和信号传播延迟。对于短环，必要时需要插入人工延迟 环接口有两种操作模式：监听模式和传输模式 当一个站点有数据发送时，在令牌通过此站点时，将令牌从环上取下，发送自己的数据，发送站负责将发出的帧从环上移去，然后重新生成令牌，并转入监听模式 确认：帧内一个比特域，初值为0，目的站收到后，将其变为1；对广播的确认比较复杂 重负载下，效率接近100% 环接口引入了1比特的传输延迟 802.5的布线 屏蔽双绞线，速率为1/4/16M，采用差分曼彻斯特编码传输 为解决环断裂导致整个环无法工作的问题，使用线路中心进行布线，线路中心设有旁路中继器 令牌环MAC子层协议 协议基本操作：无信息传输时，3字节的令牌在环上循环；有信息要发送时，站获得令牌，并将第二个字节的某一位由0变成1，将令牌的前两个字节变成帧的起始序列，然后输出帧的其它部分 开始定界符SD和结束定界符ED标志着帧的开始和结束，使用差分曼彻斯特编码模式(HH和LL，物理层编码违例法) 访问控制域AC包括令牌位、监视位、优先级位和保留位 帧控制域FC用于将数据帧和控制帧区别开来和进行环的维护；帧状态字节FS用于报告帧的传送情况，包括地址位A和拷贝位C，帧经过目的站，A置为1，帧被接收，C置为1，A、C位提供了自动确认，为增加可靠性，A、C在FS中出现两次 令牌持有时间，一般为10毫秒 提供优先级控制：访问控制域中的优先级位给出令牌的优先级，只有当要发送的帧的优先级大于等于令牌的优先级时才能获得令牌，站还可以预约某个优先级的令牌 环的维护 环上存在一个监控站，负责环的维护，通过站的竞争产生 监控站的职责 保证令牌不丢失 处理环断开情况 清除坏帧，检查无主帧 光纤分布式数据接口FDDI 特征 使用多模光纤作为传输介质 MAC协议与令牌环类似 100M的速率 采用4B5B编码方法 最大距离200公里 最多1000个站点 通常作为连接LAN的主干网络 FDDI的双环操作 FDDI定义了两类站：A类站连接双环，B类站连接单环 为提高信道利用率，站点发完数据后立即产生新令牌，环上可能同时存在多个帧 DPT Cisco的技术，主要用于城域网 结合了IP带宽利用率高、服务种类丰富的特点和光纤环高带宽、自治愈的特点 DPT环是双环，每个环都同时用于用户数据和控制数据的传输 SRP SRP是一个媒介无关的MAC层协议，用来实现DPT在光纤环情况上的功能 SRP提供基本的寻址，报文封装，带宽控制和控制信息的传输机制 目的地提取报文：报文被目的节点从环上取下，不继续占用带宽，这样DPT环可以提供空间复用，使得多个不同网段可以同时全速使用带宽 DPT结合了SONET/SDH的处理能力和第二层的管理能力，来实现多层性能监视，错误检查和错误隔离功能 网桥技术 定义：网桥是工作在数据链路层的一种网络互连设备，它在互连的LAN之间实现帧的存储和转发 将一个负载很重的大LAN分隔成使用网桥互连的几个LAN以减轻负担，防止出故障的站点损害全网 冲突域：在使用CSMA/CD协议的以太网中，如果两个站点同时发送帧会产生冲突，则这个CSMA/CD网络就是一个冲突域 中继器不能隔离冲突域，网桥/交换机可以隔离冲突域 网桥可以互连不同类型的LAN 网桥可以有助于安全保密 网桥的工作原理 连接k个不同LAN的网桥具有k个MAC子层和k个物理层 连接802.X和802.Y的网桥 互连时需要解决的相同问题 不同LAN帧格式的转换 不同的LAN速率不同，网桥要有缓存能力 高层协议的计时器设置 不同的LAN支持的最大帧长度不同，分别为1500，8191，5000，解决方法：丢弃无法转发的帧 三种不同的LAN互连共有九种组合 透明网桥/生成树网桥 工作原理 网桥工作在混杂方式，接收所有的帧 网桥接收到一帧后，通过查询地址/端口对应表来确定是丢弃还是转发 网桥刚启动时，地址/端口对应表为空，采用洪泛方法转发帧 在转发过程中采用逆向学习算法收集MAC地址，网桥通过分析帧的源MAC地址得到MAC地址与端口的对应关系，并写入地址/端口对应表 网桥软件对地址/端口对应表进行不断的更新，并定时检查，删除在一段时间内没有更新的地址/端口项 帧的路由过程 目的LAN与源LAN相同，则丢弃帧 目的LAN和源LAN不同，则转发帧 目的LAN未知，则洪泛帧 多个网桥(并行网桥)可能产生回路 解决多个网桥产生回路的问题 思想 让网桥之间互相通信，用一颗连接每个LAN的生成树覆盖实际的拓扑结构 构造生成树 每个桥广播自己的桥编号，号最小的桥称为生成树的根 每个网桥计算自己到根的最短路径，构造出生成树，使得每个LAN和桥到根的路径最短 当某个LAN或网桥发生故障时，要重新计算生成树 生成树构造完后，算法继续执行以便自动发现拓扑结构变化，更新生成树 源路由网桥 CSMA/CD和Token Bus选择了透明网桥，令牌环选择了源路由网桥 源路由网桥的原理 帧的发送者知道目的主机是否在自己的LAN内 如果不在，在发出的帧头内构造一个准确的路由序列，包含要经过的网桥、LAN的编号，并将发出的帧的源地址的最高位置1 每个LAN有一个12位的编号，每个网桥有一个4位的编号 网桥只接收源地址的最高位为1的帧，判定是转发还是丢弃 源路由的产生：每个站点通过广播”发现帧”来获得到各个站点的最佳路由 若目的地址未知，源站发送”发现帧“，每个网桥收到后广播，目的站收到后发应答帧，该帧经过网桥时被加上网桥的标识，源站收到后就知道了到目的站的最佳路由 优点 对带宽进行最优的使用 缺点 网桥的插入对于网络是不透明的，需要人工干预 交换机 交换机内的电路让每个计算机位于单独的局域网网段上，并与其它网段通过网桥连接 路由选择和网络层 网络层概述 ISO定义 网络层为一个网络连接的两个传送实体间交换网络服务数据单元提供功能和规程的方法，它使传送实体独立于路由选择和交换的方式 网络层的地位 位于数据链路层和传输层之间，使用数据链路层提供的服务，为传输层提供服务 通信子网的最高层(传统意义) 网络层的功能 屏蔽各种不同类型网络之间的差异，实现互连 了解通信子网的拓扑结构，选择路由，实现报文的网络传输 网络层提供的服务 面向连接服务 传统电信的观点：通信子网应该提供可靠的、面向连接的服务 将复杂的功能放在网络层(通信子网) 无连接服务 互联网的观点：通信子网无论怎么设计都是不可靠的，因此网络层只需提供无连接服务 将复杂的功能放在传输层 网络层的内部结构 数据报子网 采用数据报分组交换 每个分组被独立转发，分组带有全网唯一的地址 虚电路子网 采用虚电路分组交换 先在源节点和目的结点之间建立一条虚电路，所有分组沿虚电路按次序存储转发，最后拆除虚电路 虚电路子网与数据报子网的比较 带宽与状态的权衡 地址查找时间与连接建立时间的权衡 可靠性与服务质量的权衡 可扩展性 路由算法 路由算法是网络层协议的一部分 通信子网采用数据报分组交换方式，每个分组都要做路由选择 通信子网采用虚电路分组交换方式，只需在建立连接时做一次路由选择 路由算法应具有的特性 正确性 公平性 简单性 最优性 健壮性 可扩展性 稳定性 路由算法分类 静态路由算法(非自适应算法) 动态路由算法(自适应算法) 最优化原则 如果路由器J在路由器I到K的最优路由上，那么从J到K的最优路由会落在同一路由上 汇集树 从所有的源节点到一个给定的目的结点的最优路由的集合形成了一个以目的结点为根的树，称为汇集树 路由算法的目的是找出并使用汇集树 最短路径算法 基本思想 构建子网的拓扑图，图中的每个结点代表一个路由器，每条弧代表一条通信线路 为了选择两个路由器间的路由，算法在图中找出最短路径 测量路径长度的方法 结点数量 信道带宽 地理距离 传输延迟 距离、信道带宽等参数的加权函数 洪泛算法 洪泛算法属于静态路由算法 基本思想 把收到的每一个分组，向除了该分组到来的线路外的所有输出线路发送 主要问题 洪泛要产生大量重复分组，可能产生回路 解决措施 每个分组头含站点计数器，每经过一站计数器减1，为0时则丢弃该分组 记录分组经过的路径 选择性洪泛算法 洪泛法的一种改进，将接收的每个分组仅发送到与正确方向接近的线路上 算法特点 对路由器和线路的资源过于浪费，实际很少直接采用 具有极好的健壮性，可用于军事应用 作为衡量标准评价其它路由算法 基于流量的路由算法 基于流量的路由算法属于静态路由算法 基本思想 既考虑拓扑结构，又兼顾网络负载 前提：每对结点间平均数据流相对稳定和可预测 根据网络带宽和平均流量，可得出平均分组延迟，因此路由选择问题归结为找产生网络最小延迟的路由选择算法 提前离线计算 可用于流量工程 需要预知的信息 网络拓扑结构 通信量矩阵Fij 线路带宽矩阵Cij 路由算法(可能是临时的) 距离向量路由算法 属于动态路由算法 最初用于ARPANET，被RIP协议采用 算法步骤 每个路由器维护一张表，通过与相邻路由器交换距离信息来更新表 以子网中其它路由器为表的索引，表项分组括两部分：到达目的结点的最佳输出线路，和到达目的结点所需的时间或距离 每隔一段时间，路由器向所有邻居结点发送它到每个目的结点的距离表，同时它也接收每个邻居结点发来的距离表 邻居结点Ni发来的表中，Ni到路由器D的距离为di，本路由器到Ni的距离为ni，则路由器经过Ni到D的距离为di+ni，根据不同邻居发来的信息，计算di+ni，并取最小值，更新本路由器的路由表 注意：本路由器中的老路由表在计算中不被使用 无穷计算问题 对好消息反应迅速，对坏消息反应迟钝 水平分裂算法 工作过程与距离向量算法相同，区别在于从邻居结点学到的到X的距离不向邻居结点报告，使得坏消息传播的也快 虽然广泛使用，但有时候会失败 主要问题 选择路由时，没有考虑链路带宽 路由收敛速度慢 存在无穷计算问题 路由报文开销大(不是增量更新) 不适合用于大规模网络(RIP协议最大支持15跳) 链路状态路由算法 算法步骤 发现邻居结点，并学习它们的网络地址 路由器启动后，通过发送HELLO分组发现邻居结点 两个或多个路由器连在一个LAN时，引入人工结点(代表路由器DR) 测量到每个邻居结点的延迟或开销 一种直接的方法是：发送一个要对方立即响应的ECHO分组，往返时间除以2即为延迟 另一种方法是根据带宽来设定 将所有学习到的内容封装成一个分组 分组以发送方的标识符开头，后面是序号、年龄和一个邻居结点列表 列表中对应每个邻居结点，都有发送方到它们的延迟或开销 链路状态分组定期创建或发生重大事件时创建 将这个分组发送给所有其它路由器 洪泛链路状态分组，为控制洪泛，每个分组含一个序号，每次发送新分组时加1 路由器记录信息对(源路由器，序号)，当一个链路状态分组到达时，若是新分组，则处理；若是重复分组或过时分组，则丢弃 问题 序号循环使用会混淆 路由器崩溃后，序号重置 序号出错 改进 第一个问题的解决方法：使用32位序号 第二、三个问题的解决办法：增加年龄域，每秒钟年龄减1，为零则丢弃(OSPF协议规定，age初始值为0，递增，超过MaxAge要丢弃) 链路状态分组到达后，延迟一段时间，并与其它已到达的来自同一路由器的链路状态分组比较序号，丢弃重复分组，保留新分组 链路状态分组需要应答 计算到所有其它路由器的最短路径(Dijkstra算法) 实用协议：OSPF、IS-IS 链路状态算法(LS)和距离向量算法(DV)的比较 路由信息的复杂性 LS 路由信息向全网发送 N个节点，E个链路的情况下，发送O(NE)个报文 DV 仅在邻居节点之间交换 注意 LS发送的是链路信息，DV发送的是到所有结点的向量信息 LS信息定期创建或发生重大事件时创建，DV定期创建 LS发布增量信息，DV发布全部信息 收敛速度 LS 使用最短路径优先算法，算法复杂度为O(nlogn) 可能存在路由震荡 DV 收敛时间不确定：路由循环、无穷计算 健壮性 LS 结点会广播错误的链路开销 每个结点只计算自己的路由表 DV 结点会广播错误的路径开销 每个结点的路由表被别的结点使用，错误会传播到全网 分层路由 网络规模增长带来的问题 路由器中的路由表增大 路由器为选择路由而占用的内存、CPU时间和网络带宽增大 路由收敛慢 分层路由 分而治之的思想 根据需要，将网络分成若干域 路由表规模大幅减少 分层路由带来的问题 分层后计算得到的路由不一定是最优路由 移动主机的路由 需要解决的问题 为了能够将分组转发给移动主机，网络必须首先要找到移动的主机 网络结构示意图 一些基本概念 移动用户：位置发生变化，包括通过固定方式或移动方式与网络连接的两类用户 家乡位置：所有用户都有一个永久的家乡位置，用一个地址来标识 家乡代理：每个区域有一个家乡代理，负责记录家乡在该区域，但是目前正在访问其他区域的用户 外部代理：每个区域有一个或多个外部代理，它们记录正在访问该区域的移动用户 移动用户进入一个新区域时，必须首先向外部代理注册 外部代理定期广播声明自己的存在和地址的分组，新到达的移动主机接收该信息；若移动用户未能收到该信息，则移动主机广播分组，询问外部代理的地址 移动主机向外部代理注册，告知其家乡地址、目前的数据链路层地址和一些安全信息 外部代理与移动主机的家乡代理联系，告知移动主机的目前位置、自己的网络地址和一些安全信息 家乡代理检查安全信息，通过，则给外部代理确认 外部代理收到确认后，在登记表中加入一项，并通知移动主机注册成功 移动用户的路由转发过程 当一个分组发给移动用户时，首先被转发到用户的家乡局域网 该分组到达用户的家乡局域网后，被家乡代理接收，家乡代理查询移动用户的新位置和与其对应的外部代理的地址 家乡代理采用隧道技术，将收到的分组作为净负荷封装到一个新分组中，发给外部代理 家乡代理告诉发送方，发给移动用户的后续分组作为净负荷装成分组直接发给外部代理(发送方要修改协议栈) 外部代理收到分组后，将净负荷封装成数据链路帧发给移动用户 拥塞控制算法 拥塞 网络上有太多的分组时，性能会下降，这种情况称为拥塞 拥塞产生的原因 网络设备处理器性能低 高速端口输入，低速端口输出 多个输入对应一个输出 解决办法 针对某个因素的解决方案，只能对提高网络性能起到一点点好处，甚至可能仅仅是转移了影响性能的瓶颈，因此需要全面考虑各个因素 目前，主要在网络层和传输层进行控制 拥塞控制与流控制的差别 拥塞控制需要确保通信子网能够承载用户提交的数据流，是一个全局性问题，涉及主机、路由器等很多因素 流控制与端到端的传输有关，主要解决快速发送方与慢速接收方的问题，是局部问题，一般都是基于反馈进行控制的 拥塞控制的基本原理 根据控制论，拥塞控制方法分为两类 开环控制 通过好的设计来解决问题，避免拥塞发生 拥塞控制时，不考虑网络当前状态 闭环控制 基于反馈机制 工作过程 监控系统，发现何时何地发生拥塞 把发生拥塞的消息传给能采取动作的站点 调整系统操作，解决问题 衡量网络是否拥塞的参数 缺乏缓冲区造成的分组丢失率 平均队列长度 超时重传的分组的数目 平均分组延迟 分组延迟变化 反馈方法 向负载发生源发送一个告警分组 分组头中保留一个位或域用来表示发生拥塞，一旦发生拥塞，路由器将对应的端口的所有输出分组置位 主机或路由器主动地、周期性地发送探报，查询是否发生拥塞 流量整形 开环控制 基本思想 造成拥塞的主要原因是网络流量通常是突发性的 强迫分组以一种可预测的速率发送 典型算法 漏桶算法 令牌桶算法 拥塞控制算法 漏桶算法 将用户发出的不平滑的数据分组流转变成网络中平滑的数据分组流 可用于固定分组长的协议，如ATM；也可用于可变分组长的协议，如IP，使用字节计数 无论负载突发性如何，漏桶算法强迫输出按平均速率进行，不灵活 令牌桶算法 基本思想：漏桶存放令牌，每ΔT秒产生一个令牌，令牌累积到超过漏桶上界时就不再增加，分组传输之前必须获得一个令牌，传输之后再删除该令牌 漏桶算法与令牌桶算法的区别 流量整形策略不同 漏桶算法不允许空闲主机积累发送权 令牌桶算法允许空闲主机积累发送权，最大为桶的大小，可以发送突发数据 漏桶维护策略不同 漏桶算法中，漏桶存放的是数据分组，桶满了丢弃数据分组 令牌桶算法中，漏桶存放的是令牌，桶满了丢弃令牌 虚电路子网中的拥塞控制 流说明 一个数据流的发送方、接收方和通信子网三方认可的、描述发送数据流的模式和希望得到的服务质量的数据结构 对发送方的流说明，子网和接收方可以做出三种答复：同意、拒绝、其它建议 准入控制 根据流说明和网络资源分配情况，进行准入控制 一旦发生拥塞，在问题解决之前，不允许建立新的虚电路 另一种方法是发生拥塞控制后可以建立新的虚电路，但要绕开发生拥塞控制的地区 资源预留：建立虚电路时，主机与子网达成协议，子网根据协议在虚电路上为此连接预留资源 抑制分组 路由器监控输出线路及其它资源的利用情况，超过某个阈值，则此资源进入警戒状态 每个新分组到来，检查它的输出线路是否处于警戒状态 若是，则向源主机发送抑制分组，分组中指出发生拥塞的目的地址。同时将原分组打上标记（为了以后不再产生抑制分组），正常转发 源主机收到抑制分组后，按一定比例减少发向特定目的地的流量，并在固定时间间隔内忽略指示同一目的地的抑制分组。然后开始监听，若此线路仍然拥塞，则主机在固定时间内减轻负载、忽略抑制分组；若在监听周期内没有收到抑制分组，则增加负载 通常采用的流量增减策略是：减少时，按一定比例减少，保证快速解除拥塞；增加时，以常量增加，防止很快导致拥塞(AIMD) 逐跳抑制分组 在高速、长距离的网络中，由于源主机响应太慢，抑制分组算法对拥塞控制的效果并不好，可采用逐跳抑制分组算法 基本思想 抑制分组对它经过的每个路由器都起作用 能够迅速缓解发生拥塞处的拥塞 上游路由器要求有更多的缓冲区 公平队列算法 路由器的每个输出线路有多个队列 路由器循环扫描各个队列，发送队头的分组 所有队列具有相同优先级 一些ATM交换机、路由器使用这种算法 一种改进：对于变长分组，由逐分组轮询改为逐字节轮询 加权公平队列 给不同队列以不同的优先级 优先级高的队列在一个轮询周期内获得更多的时间片 负载丢弃 上述算法都不能消除拥塞时，路由器只得将分组丢弃 针对不同的服务，可采用不同的丢弃策略 文件传输，优先丢弃新分组 多媒体服务，优先丢弃新分组 早期丢弃分组，会减少拥塞发生的概率，提高网络性能 网络互连 互连网络：两个或多个网络构成互连网络 多种不同网络(协议)存在的原因 历史原因：不同公司的网络产品大量使用 价格原因：网络产品价格低，更多的人有权决定使用何种网络 技术原因：不同网络采用不同技术、不同硬件、不同协议 网络互连设备 中继器 物理层设备，在电缆段之间拷贝比特 对弱信号进行放大或再生，以便延长传输距离 网桥 数据链路层设备，在局域网之间存储转发帧 网桥可以改变帧格式 多协议路由器 网络层设备，在网络之间存储转发分组 必要时，做网络层协议转换 传输网关 传输层设备，在传输层转发字节流 应用网关 应用层设备，在应用层实现互连 无连接网络互连 无连接网络互连的工作过程与数据报子网的工作过程相似 每个分组单独路由，提高网络利用率 根据需要，连接不同子网的多协议路由器做协议转换，包括分组格式转换和地址转换等 隧道技术 源和目的主机所在的网络类型相同，连接它们的是一个不同类型的网络，这种情况下可以采用隧道技术 互联网络路由 互连网络路由工作过程 互连网络的路由与单独子网的路由过程相似，只是复杂性增加 两级路由算法 自治系统AS 内部网关协议IGP RIP，OSPF，IS-IS 外部网关协议EGP BGP 分片 每种网络都对最大分组长度有限制，有以下原因 硬件，例如TDM的时槽限制 操作系统 协议，例如分组长度域的比特个数 与标准的兼容性 希望减少传输出错的概率 希望避免一个分组占用信道时间过长 大分组经过小分组网络时，网关要将大分组分成若干片段，每个片段作为独立的分组传输 分组重组策略 分组重组过程对其它网络透明 网关将大分组分片后，每个片段都要经过同一出口网关，并在那里重组 带来的问题 出口网关需要知道何时所有片段都到齐 所有片段必须从同一出口网关离开 大分组经过一系列小分组网络时，需要反复分片重组，开销大 分片重组过程对其它网络不透明 中间网关不做重组，而由目的主机做 带来的问题 对主机要求高，能够重组 每个片段都要有一个分组头，网络开销大 标记片段 树型标记法 分组0分成三段，分别标记为0.0，0.1，0.2，片段0.0构成的分组被分成三片，分别标记为0.0.0，0.0.1，0.0.2 存在的问题 段标记域要足够长 分片长度前后要一致 偏移量法 定义一个基本片段长度，使得基本片段能够通过所有网络 分片时，除最后一个片段小于等于基本片段长度外，所有片段长度都等于基本片段长度 分片后的分组头中包括：原始分组序号，分组中的第一个基本片段的偏移量，最后片段指示位 防火墙 什么情况下使用防火墙 为防止网络中的信息泄露出去或不好的信息渗透进来，在网络边缘设置防火墙 防火墙的一种早期配置 两个路由器，根据某种规则表，进行分组过滤 一个应用网关，审查应用层信息 互联网网络层协议 在网络层，互联网可以看成是自治系统的集合，是由网络组成的网络 网络之间互连的纽带是IP协议 IPv4协议 IPv4头格式 IPv4头包括20个字节的固定部分和变长(最长40字节)的可选部分，从左到右传输 版本域 IHL：IPv4分组头长度，最小为5，最大为15，单位为32-bit-word 服务类型域 总长度域 标识域 DF：Don‘t Fragment 所有机器必须能够接收小于等于576字节的片段 MF：More Fragments 除最后一个片段外的所有片段都要置MF位 片段偏移量 除最后一个片段外的所有片段的长度必须是8字节的倍数 生存期 实际实现中，IPv4分组每经过一个路由器TTL减1，为0则丢弃，并给源主机发送一个告警分组 最大值为255，源主机设定初始值，UNIX操作系统一般为255，Windows操作系统一般为128，Linux一般为64 协议域：上层为哪种协议 头校验和 源地址和目的地址 选项 变长，长度为4字节的倍数，不够则填充，最长为40字节 IPv4地址 地址组成：网络号+主机号 有类地址划分 地址表示采用用点分隔的十进制表示法 全0和全1有特殊含义 全0：表示本网络或本主机 全1：表示广播地址 子网 分而治之的思想：为了便于管理和使用，可以将网络分成若干供内部使用的部分，称为子网 ICMP协议 互联网控制消息协议ICMP 主要用来报告错误和测试 报文类型 ICMP报文封装在IP分组中 ARP协议 地址解析协议ARP 解决网络层地址(IP地址)与数据链路层地址(MAC地址)的映射问题 工作过程 建立一个ARP表，表中存放(IP地址，MAC地址)对 若目的主机在同一子网内，用目的IP地址在ARP表中查找，否则用缺省网关的IP地址在ARP表中查找 若未找到，则发送广播分组，目的主机收到后给出应答，ARP表增加一项 每个主机启动时，广播它的(IP地址，MAC地址)映射 ARP表中的表项有生存期，超时则删除 ARP攻击 ARP攻击：攻击者持续不断的发出伪造的ARP响应包，更改目的主机ARP缓存中的IP-MAC表项，造成网络中断或中间人攻击 ARP攻击存在于局域网 RARP协议 反向地址解析协议RARP 解决数据链路层地址(MAC地址)与网络层地址(IP地址)的映射问题 主要用于无盘工作站启动 缺点：由于路由器不转发广播帧，RARP服务器必须与无盘工作站在同一子网内 一种代替协议BOOTP(使用UDP) RIP协议 属于内部网关协议IGP 采用距离向量算法 距离的衡量采用跳数(max=15hops) 距离向量：每30秒交换一次 故障处理 如果180秒内没有收到来自邻居的路由声明，则认为邻居/链路失效 经过该邻居的路由无效 新的路由声明发往其它邻居 邻居依次发出新的路由声明 链路失效的信息迅速传播到全网 使用毒性反转避免路由循环 OSPF协议 开放最短路径优先OSPF 属于内部网关协议IGP 支持多种距离衡量尺度，例如，物理距离、延迟、带宽等 采用链路状态算法 支持基于服务类型的路由 支持负载均衡 支持分层路由 适量的安全措施 支持隧道技术 分层路由 自治系统可以划分为区域 每个自治系统有一个主干区域，称为区域0 所有其它区域都与主干区域相连 其它区域之间不能相连 一般情况下，有三种路由 区域内 区域间 从源路由器到主干区域 穿越主干区域到达目的区域 到达目的路由器 自治系统间 四类路由器，允许重叠 完全在一个区域内的内部路由器 连接多个区域的区域边界路由器ABR 主干路由器 自治系统边界路由器ASBR BGP协议 为什么域间和域内的路由有所不同 策略 域间路由跨越不同管理域，要控制流量如何路由 域内路由属于同一管理域，不需要定义策略 规模 分层路由降低了路由表的大小，减小了路由更新的流量 性能 域内路由：着重于性能 域间路由：策略更为重要 边界网关协议BGP 通过TCP连接传送路由信息 采用路径向量算法，路由信息中记录路径的轨迹 与距离向量协议相似 每个BGP网关向邻居广播所有通往目的地的路径 网关X发送它通往Z的路径：Path(X,Z)=X,Y1,Y2,Y3,……,Z 假设：网关X把它的路径发送给peer网关W W可以选择是否使用X提供的路径，依据是开销、策略、防止出现路由循环等 如果W使用X提供的路径，则Path(W,Z)=w,Path(X,Z) 注意：X能通过其发往peers的路径声明来控制进入的流量，不想转发到Z的流量，可以通过不通告通往Z的路径来实现 BGP消息 OPEN：建立与对等方的TCP连接并认证身份 UPDATE：声明新的路径或撤销旧的路径 KEEPALIVE：在没有UPDATE消息的时候保持连接有效，也用来回应OPEN请求 NOTIFICATION：报告上一个消息的错误，也用来关闭连接 无类域间路由CIDR CIDR的提出 Internet指数增长，IPv4地址已经分配完毕 基于分类的IP地址空间的组织浪费了大量的地址 CIDR 基本思想：将剩余的C类地址分成大小可变的地址空间 已推广到所有单播地址，用掩码确定其前缀长度 路由表中增加一个32位的掩码域 最长前缀匹配原则：路由查找时，若多个路由表项匹配成功，选择掩码最长的路由表项 CIDR思想可用于所有IP地址，没有A、B、C类之分 地址格式：a.b.c.d/x，其中x地址中网络号的位数 IPv6协议 IPv6的目标 即使在不能有效分配地址空间的情况下，也能支持数十亿的主机 减少路由表的大小 简化协议，使得路由器能够更快的处理分组 提供比IPv4更好的安全性 更多的关注服务类型，特别是实时数据 支持Multicast 支持移动功能 协议具有很好的可扩展性 增强安全性 在一段时间内，允许IPv4和IPv6共存 与IPv4相比，IPv6的主要变化 地址变长，由32位变成128位 IP头简化，由13个域减少为7个域，提高路由器处理速度 由于IPv6分组头定长，取消IHL域 Protocol域取消，用Next header域表示 取消与分片有关的域，IPv6的分片方法：所有主机和路由器必须支持1280字节的分组，当主机发送一个大分组时，路由器不做分片，而是给主机发一个错误信息，由主机做分片 取消Checksum域 更好的支持选项功能 安全性提高 IPv6分组头 Version，值为6 Priority，用来区分源端可以流控或不能流控的分组，值越大优先级越低 Flow label，用来允许源和目的建立一条具有特殊属性和需求的伪连接 Payload length，用来指示IP分组中40字节分组头后面部分的长度，与IPv4的total length域不同 Next header，指示扩展分组头，若是最后一个分组头，则指示传输协议类型(TCP/UDP) Hop limit，IP分组的最大跳数 Source address，destination address，16字节定长地址 IPv6扩展分组头 目前定义了六种类型的扩展分组头 hop-by-hop header，用来指示路径上所有路由器必须检查的信息 routing header，列出路径上必须要经过的路由器 fragmentation header，与IPv4相似，扩展头中分组括IP分组标识号、片段号和判断是否还有片段的位，只有源主机可以分片 IPv4向IPv6过渡 所有路由器不可能同时升级 没有一个确定的期限 IPv4和IPv6路由器混合的网络如何操作 有三种方案 双栈：实现IPv4/v6两套协议栈，主机根据DNS返回的结果或对方发来的报文的版本号决定采用哪个协议，路由器根据收到IP分组的版本号决定采用哪个协议 翻译：有些路由器同时运行两套协议栈，可以在这两套之间进行协议翻译和地址翻译，例如NAT-64 隧道：IPv6的报文作为IPv4报文的净负荷在IPv4网络中传输 端到端访问与传输层 传输服务 引入传输层的原因 消除网络层的不可靠性 提供从源端主机的进程到目的主机的进程的可靠的、与实际使用的网络无关的数据传输 传输服务 传输实体：完成传输层功能的硬软件 传输层实体利用网络层提供的服务向上层提供有效、可靠或尽力而为的服务 传输层提供两种服务 面向连接的传输服务：连接建立，数据传输，连接释放 无连接的传输服务 1~4层称为传输服务提供者，4层以上称为传输服务用户 传输服务原语 传输用户(应用程序)通过传输服务原语访问传输服务 一个简单的传输服务的原语 Client/Server模式 简单连接管理 拆除连接方式有两种 不对称方式：任何一方都可以关闭双向连接 对称方式：每个方向的连接单独关闭，双方都执行DISCONNECT才能关闭整条连接 简单连接管理状态图 伯克利套接字 连接释放是对称的 应用举例 一个服务程序和几个远程客户程序利用面向连接的传输层服务完成通信 建立连接 服务程序 客户程序 数据传输 双方使用send和receive完成数据的全双工发送 释放连接 每一方使用close原语单独释放连接 传输层寻址 传输层编址 编址 方法：定义传输服务访问点TSAP，将应用进程与这些TSAP相连 在互联网中，TSAP为(IP address，local port) 远方客户程序如何获得服务程序的TSAP 方法1：预先约定、广为人知的，例如telnet是(IP地址，端口23) 方法2：从名称服务器或目录服务器获得TSAP 名称服务器 一个特殊的进程称为名称服务器或目录服务器 协议工作过程 客户进程与名称服务器建立连接，发送服务名称，获得服务进程的TSAP，释放与名称服务器的连接 客户进程与服务进程建立连接 进程服务器 当服务程序很多时，可以使用进程服务器 进程服务器是一个同时在多个端口上监听的进程 客户进程向它实际想访问的服务进程的TSAP发出连接建立请求 如果没有服务进程在此TSAP上监听，则客户进程和进程服务器建立连接 进程服务器产生所请求的服务进程，并使该进程继承和客户进程的连接 进程服务器返回继续监听 客户进程与所希望的服务进程进行数据传输 连接管理 建立连接 网络可能丢失、重复包，特别是延迟重复包的存在，导致传输层建立连接的复杂性 两次握手不能满足要求 两次握手：A发出连接请求CR TPDU，B发回连接确认CC TPDU 失败的原因：网络层会丢失、存储和重复包 解决延迟重复包的关键是丢弃过时的包 采用三次握手 A发出序号为X的CR TPDU B发出序号为Y的CC TPDU，并确认A的序号为X的CR TPDU A发出序号为X+1的第一个数据TPDU，并确认B的序号为Y的CR TPDU 三次握手方案解决了由于网络层会丢失、存储和重复包带来的问题 释放连接 非对称式：一方释放连接，双向连接断开，存在丢失数据的危险 对称式：每个方向的连接单独关闭，不会丢失数据，但是存在两军问题 由于存在两军问题，可以证明不存在安全的通过N次握手实现对称式连接释放的方法 但是在实际的通信过程中，使用三次握手+定时器的方法释放连接在绝大多数情况下是成功的 缓存和流控 缓存 由于网络层服务是不可靠的，传输层实体必须缓存所有连接发出的TPDU，而且为每个连接单独做缓存，以便用于错误情况下的重传 接收方的传输层实体可以做也可以不做缓存 缓存的设计有三种 固定大小缓存 可变大小缓存 缓存池 流控 传输层利用可变滑动窗口协议来实现流控 可变滑动窗口协议：是指发送方的发送窗口大小是由接收方根据自己的实际缓存情况给出的 为了避免控制TPDU丢失导致死锁，端系统应该周期性的发送TPDU 互联网传输协议 传输控制协议TCP 面向连接的、可靠的、端到端的、基于字节流的传输协议 用户数据协议UDP 无连接的端到端传输协议 TCP协议 TCP协议 应用程序访问TCP服务是通过在收发双方创建套接字来实现的 套接字地址用(IP地址，端口号)来表示，256以下的端口号被标准服务保留，例如FTP(21)，TELNET(23) 每条连接用(套接字1，套接字2)来表示，是点到点的全双工信道 TCP不支持组播和广播 TCP连接是基于字节流的，而非消息流，消息的边界在端到端的传输中不能得到保留 对于应用程序发来的数据，TCP可以立即发送，也可以缓存一段时间以便一次发送更多的数据，为了强迫数据发送，可以使用PUSH标记 对于紧急数据，可以使用URGENT标记 按字节分配序号，每个字节有一个32位的序号 传输实体之间使用的TPDU称为段 每个段包含一个20字节的头(选项部分另加)和0个或多个数据字节 段的大小必须满足65535字节的IP包数据净荷长度限制，还要满足数据链路层最大传输单元(MTU)的限制 TCP实体使用滑动窗口协议，确认序号等于接收方希望接收的下一个字节序号 TCP协议需要解决的主要问题 连接管理 建立连接：三次握手 释放连接：三次握手+定时器 可靠传输 滑动窗口 流控制和拥塞控制 可变滑动窗口 慢启动、拥塞避免 TCP头 源端口和目的端口：各16位 序号和确认号：以字节为单位编号，各32位 TCP头的长度：4位，长度单位为32位字，包含选项域 6位的保留域 6位的标识位：置1表示有效 URG：和紧急指针配合使用，发送紧急数据 ACK：确认号是否有效 PSH：指示发送方和接收方将数据不做缓存，立刻发送或接收 RST：由于不可恢复的错误重置连接 SYN：用于连接建立指示 FIN：用于连接释放指示 窗口大小：用于基于可变滑动窗口的流控，指示发送方从确认号开始可以再发送窗口大小的字节流 校验和：为增加可靠性，对TCP头，数据和伪头计算校验和 选项域 TCP连接管理 三次握手建立连接 服务器方执行LISTEN和ACCEPT原语，被动监听 客户方执行connect原语，产生一个SYN为1和ACK为0的TCP段，表示请求连接 服务器方的传输实体接收到这个TCP段后，首先检查是否有服务进程在所请求的端口上监听，若没有，回答RST置位的TCP段 若有服务进程在所请求的端口上监听，该服务进程可以决定是否接受该请求，在接受后，发出一个SYN置1和ACK置1的TCP段表示连接确认，并请求与对方的连接 客户方收到确认后，发出一个SYN置0和ACK置1的TCP段表示给对方的连接确认 若两个主机同时试图建立彼此间的连接，则只能建立一条连接 对称方式连接释放 释放连接时，发出FIN位置1的TCP段并启动定时器，在收到确认后关闭连接，若无确认并且超时，也关闭连接 TCP传输策略 TCP的窗口管理机制 基于确认和可变窗口大小 窗口大小为0时，正常情况下，发送方不能再发送TCP段，但有两个例外 紧急数据可以发送 为防止死锁，发送方可以发送1字节的TCP段，以便让接收方重新声明确认号和窗口大小 改进传输层的性能 策略1：发送方缓存应用程序的数据，等到形成一个比较大的段再发出 策略2：在没有可能进行”捎带“的情况下，接收方延迟发送确认段 策略3：使用Nagle算法 当应用程序每次向传输实体发出一个字节时，传输实体发出第一个字节并缓存所有其后的字节直至收到对第一个字节的确认 然后将已缓存的所有字节组段发出并对再收到的字节缓存，直至收到下一个确认 策略4：使用Clark算法解决傻窗口症状 傻窗口症状：当应用程序一次从传输层实体读出一个字节时，传输层实体会产生一个一字节的窗口更新段，使得发送方只能发送一个字节 解决办法：限制收方只有在具备一半的空缓存或最大段长的空缓存时，才产生一个窗口更新段 TCP拥塞控制 导致拥塞的两个潜在因素是：网络转发能力和接收方接收能力 出现拥塞的两种情况 快网络小缓存接收者 慢网络大缓存接收者 TCP处理第一种拥塞的措施 采用可变滑动窗口 在确认中声明最大可接收窗口 TCP处理第二种拥塞的措施 采用拥塞窗口 拥塞窗口按照慢启动和拥塞避免等算法变化 TCP按两个窗口的最小值发送 慢启动算法 连接建立时拥塞窗口初始值为该连接允许的最大发送段长MSS，阈值为64K 发出一个最大段长的TCP段，若收到正确确认，则拥塞窗口变为两个最大段长 发出(拥塞窗口/最大段长)个最大长度的TCP段，若都得到确认，则拥塞窗口加倍 重复上一步，直至发生丢包产生的超时事件，或拥塞窗口大于阈值 窗口大小在每个RTT周期内指数增长 拥塞避免算法 当拥塞窗口大于阈值时，拥塞窗口开始线性增长，一个RTT周期增加一个最大段长，直至发生丢包产生的超时事件 超时事件发生后，阈值设定为当前拥塞窗口大小的一半，拥塞窗口重新设置为一个最大段长 执行慢启动算法 检测丢包 计时器超时 收到3个重复确认ACK 快速重传算法 连续收到3个重复确认后，不再等待计时器超时 阈值设定为当前拥塞窗口大小的一半，拥塞窗口重新设置为一个最大段长 执行慢启动算法 TCP拥塞控制分析 有效分配 太慢则浪费带宽 太快则导致拥塞 公平分配 共享相同瓶颈链路的流获得相同带宽 如何选择拥塞控制函数 MIAD 公平性不收敛，也不稳定 有效性不收敛，有条件稳定 AIAD 公平性不收敛，但是稳定 有效性不收敛，有条件稳定 MIMD 公平性不收敛，但是稳定 有效性条件收敛 AIMD 公平性收敛 有效性收敛 UDP协议 为什么会有UDP 不需要建立连接，延迟小 简单，没有连接状态 报文头小 没有拥塞控制，可以尽快的发送 UDP协议的特点 简单的传输协议 尽力而为的服务，UDP报文可能会丢失、乱序 无连接 收发双方不需要握手 每个UDP报文的处理都独立于其它报文 经常用于流媒体应用 可以容忍丢包 速率敏感 UDP的其它应用范围 RIP，路由信息周期发送 DNS，避免TCP连接建立延迟 SNMP，当网络拥塞时，网管也要运行，网管信息带内传输，用UDP比用可靠的、具有拥塞控制的TCP效果更好 基于UDP的可靠传输：应用程序自己定义错误恢复 网络应用 应用层概述 应用层概述 网络应用程序：互相通信的分布式进程 在网络主机上的用户空间运行 互相交换消息 比如email、ftp和web 应用层协议 应用程序的一部分 定义应用程序之间交换的信息以及相应的动作 利用底层协议提供的服务 应用层通信 一个进程(线程)是运行于主机上的一个程序 在同一主机上的进程(线程)利用操作系统提供的IPC进行通信 在不同主机上运行的进程利用应用层协议进行通信 用户代理是指用户和网络应用程序间的接口，比如web浏览器，流媒体播放器等 应用程序编程接口 应用程序编程接口API 定义应用程序和传输层的接口 socket：Internet API 进程如何指明要与之通信的另一个进程 IP地址指明该进程所在的主机 端口号指明该主机应该把收到的数据交给哪个当地进程 应用程序所需的传输服务 数据丢失容忍度 有的应用可以容忍一定程度的数据丢失，例如音频应用 有的应用要求100%的可靠传输，例如文件传输 带宽容忍度 有的程序需要一定的带宽才能工作，例如多媒体 有的程序则使用它所能得到的全部带宽，例如文件传输 延迟容忍度 有的程序要求低延迟，例如IP电话和交互游戏 有的程序可以容忍较大延迟，例如电子邮件 互联网传输协议提供的服务 TCP服务(smtp，telnet，http，ftp) 面向连接：用户端和服务器需要建立连接 接收和发送进程间的可靠传输 流量控制：发送方不会淹没接收方 拥塞控制：网络拥塞时限制发送方发送 不提供：延迟保证，最小带宽保证 UDP服务(流媒体，NFS，网络电话) 接收和发送进程间的不可靠传输 不提供：连接建立，可靠性、流量控制、拥塞控制和带宽保证 客户/服务器模型 基本概念 客户/服务器模型是网络应用的基础 客户/服务器分别指参与一次通信的两个应用实体，客户方主动地发起通信请求，服务器被动地等待通信的建立，并提供服务 客户软件 任何一个应用程序当需要进行远程访问时成为客户，这个应用程序也要完成一些本地的计算 一般运行于用户的个人计算机上 向服务器主动发起通信请求 不需要特殊的硬件和复杂的操作系统 服务器软件 是专用的提供某种服务的特权程序，可以同时处理多个远程客户的请求 一般在系统启动时被执行，并连续运行以处理多次会话 被动地等待远程客户发起通信 需要特殊的硬件和复杂的操作系统 数据在客户和服务器之间是双向流动的，一般是客户发出请求，服务器给出响应 服务器软件的并发性 由于服务器软件要支持多个客户的同时访问，必须具备并发性 服务器软件为每个新到的客户创建一个进程或线程来处理与这个客户的通信 服务器软件的组成 服务器软件一般分为两部分：一部分用于接受请求并创建新的进程或线程，另一部分用于处理实际的通信过程 客户/服务器之间使用的传输层协议 基于连接的TCP协议 要求建立和释放连接，适用于可靠的交互过程 无连接的UDP协议 适用于可靠性要求不高的或实时的交互过程 同时使用TCP和UDP的服务 有两种服务器软件的实现或服务器软件同时和TCP、UDP协议交互，不对客户做限制 域名服务 产生原因 32比特的IP地址难于记忆，符号地址便于记忆，因此需要一个完成二者之间相互转换的机制 当网络规模比较小时，每台主机只需查找一个文件，该文件列出了主机与IP地址的对应关系 当网络规模很大时，上述方法就不适用了，因此产生了域名系统DNS DNS概述 域名系统是一个典型的客户/服务器交互系统 域名系统是一个多层次的、基于域的命名系统，并使用分布式数据库实现这种命名机制 操作过程 当应用程序需要进行域名解析时，它成为域名系统的一个客户，它向本地域名服务器发出请求，请求以UDP段格式发出 本地域名服务器找到对应的IP地址后，给出响应 当本地域名服务器无法完成域名解析时，它临时变成其上级域名服务器的客户，继续解析，直到该域名解析完成 域名的结构 互联网的顶级域名分为组织结构和地理结构两种，每个域对它下面的子域和机器进行管理 DNS中，域名是由”.“所分开的字符、数字串组成的 域名是大小写无关的，域名最长255个字符，每部分最长63个字符 资源记录 在DNS的数据库中用资源记录来表示主机和子域的信息，当应用程序进行域名解析时，得到的便是域名所对应的资源记录 资源记录是一个五元式 Domin_name Time_to_live Type Class Value Type=A Name：主机名 Value：IP地址 Type=MX Value：与name对应的邮件服务器的主机名 Type=NS Name：域名 Value：该域权威域名服务器的IP地址 Type=CNAME Name：规范名称的别名 Value：规范名称 域名服务器 区域划分 DNS将域名空间划分为许多区域，每个区域覆盖了域名空间的一部分 区域的边界划分是人工设置的 每个区域有一个主域名服务器和若干个备份域名服务器 简单网络管理协议 SNMP的产生 早期网络规模很小，可以通过执行ping等命令来发现网络故障 网络规模变大，需要一个好的工具来管理网络 网络管理的五个基本管理功能：性能管理、故障管理、配置管理、记账管理和安全管理 SNMP是基于UDP的 SNMP模型 被管理节点 运行SNMP代理程序，维护一个本地数据库，描述节点的状态和历史，并影响节点的运行 管理工作站 运行专门的网络管理软件，使用管理协议与被管理节点上的SNMP代理通信，维护管理信息库 管理信息 每个站点使用一个或多个变量描述自己的状态，这些变量称为”对象“，所有的对象组成管理信息库MIB 管理协议 管理协议用于管理工作站查询和修改被管理节点的状态，被管理节点可以使用管理协议向管理站点产生”陷阱“报告 抽象语法表示法1(ASN.1) 抽象语法表示法1 是一种标准的对象定义语言 分为数据描述定义和传输语法定义两部分 可以作为异种计算机设备之间”对象“描述和传输的表示方法 ASN.1的基本数据类型 对象命名树 对象命名树使用编码，唯一地确定每个标准中的对象，基于对象命名树，任何标准中的任意对象都可以用如下的对象表示符表示 {iso(1) identified-organizations(3) dod(6) internet(1) mgmt(2) mib-2(1) ..tcp(6)..} ASN.1定义了5种方法构造新的类型 SEQUENCE：多种类型的有序序列 SEQUENCE OF：一种类型的一维有序序列 SET：多种类型的无序集合 SET OF：一种类型的无序集合 CHOICE：创建一些类型的共同体 构造新类型的另一种方法是重新标记一个老的类型 类似C语言中定义新的类型 标签有四类：universal，application-wide，context-specific，private ASN.1的传输语法 基本编码规则BER定义了如何将ASN.1类型的值表示为无二义的字节序列 需要传输的内容 标志符 包括三个子域 当tag值在0~30之间时，用低5位表示 当tag值大于30时，低五位为11111，用后面的字节表示，每个标识字节包括7个数据位，最后一个字节高位为1，其它字节高位为0 数据长度域 当长度＜128字节时，用一个字节表示长度，高位为0 当长度≥128字节时，第一个字节高位为1，低7位表示后面表示长度的字节个数，后面的若干个(≤127)字节表示长度 数据域 INTEGER：二进制编码 BIT STRING：编码表示不变，长度域表示字节个数，并在传位串前先传一个字节表示位串最后一个字节不用的位数 OCTET STRING：编码表示不变 NULL：长度域为0，不传数据 OBJECT IDENTIFIER：按照命名树的编码整数序列编码，前两个数a，b可用一个字节编码，值为40a+b 如果数据长度未知，需要有结束标志 管理信息结构和管理信息库 管理信息结构SMI和管理信息库MIB 定义 SNMP在ASN.1的基础上，定义了四个宏，八个新数据类型来定义SNMP的数据结构，被称为管理信息结构SMI SNMP使用SMI首先将变量定义为”对象“，相关的对象被集合成”组“，组最后被汇集成”模块“ 管理信息库 SNMP的MIB包含10个组，网络管理工作站通过使用SNMP协议，向被管理节点中的SNMP代理发出请求，查询这些对象的值 每个对象有以下四个属性 对象类型：定义了对象的名字 语法：指定了数据类型 存取：表示了对象的存取级别，合法的值有只读、只写、读写和不可存取 状态：定义了对象的实现需要 必备的：被管理结点必须实现该对象 可选的：被管理结点可能实现该对象 已经废弃的：被管理结点不需要实现该对象 SNMP协议 定义了网络管理工作站和SNMP代理之间的通信过程和协议数据单元 网络管理工作站发往SNMP代理的数据请求Get-request，Get-next-request，Get-bulk-request 网络管理工作站发往SNMP代理的数据更新请求Set-request 网络管理工作站与网络管理工作站之间的MIB交换Infrom-request SNMP代理发往网络管理工作站的陷阱报告SnmpV2-trap 电子邮件 体系结构 用户代理：允许用户阅读和发送电子邮件，一般为用户进程 消息传输代理：将消息从源端发送至目的端，一般为系统的后台进程 简单邮件传输协议SMTP 电子邮件系统提供的五大基本功能 撰写：指创建消息或回答消息的过程 传输：指将消息从发送者传出至接收者 报告：将消息的发送情况报告给消息发送者 显示：使用相应的工具软件将收到的消息显示给接收者 处理：接收者对接收到的消息进行处理，存储/丢弃/转发等 其它高级功能 自动转发、自动回复 mailbox，创建邮箱存储邮件 mailing list 抄送、高优先级、加密 电子邮件的组成 信封：接收方的信息，如名字、地址、邮件的优先级和安全级别 信件内容：由信头和信体组成，信头包含了用户代理所需的控制信息，信体是真正的内容 用户代理 发送电子邮件 email地址 mailing list X.400地址 阅读电子邮件 用户代理在启动时检查用户的mailbox，通知用户是否有新邮件到来，并摘要性的显示邮件的主题、发送者及其邮件的状态 信件格式 RFC822 信件包括信封、若干信头域和信体 电子邮件的扩展 MIME，增加了对图像、声音、视频、可执行文件等的支持，使用不同的编码方法将信息转化为ASCII字符流 消息传送协议 INTERNET使用简单邮件传输协议SMTP完成电子邮件的交换 过程如下 消息传输代理在源端主机和目的主机的25号端口之间建立一条TCP连接，使用简单邮件传输协议SMTP协议进行通信 在TCP连接建立好之后，作为客户的邮件发送方等待作为服务器的邮件接收方首先传输信息 服务器首先发出准备接收的SMTP消息，客户向服务器发出HELLO消息，服务器回答以HELLO消息，双方进入邮件传输状态 邮件传输过程：客户首先发出邮件的发信人地址，然后发出收信人的地址，服务器确认收信人存在后，发出可以继续发送的指示，客户发送真正的消息，以CRLF.CRLF作为结束 当客户方邮件发送完后，服务器开始发送邮件至客户，过程同上 两个方向的发送完成后，释放TCP连接 持久方式 注意 消息以7-比特ASCII码为单位 某些特殊字符串不允许在消息中出现，需要编码 其它协议 POP3，用户代理和邮箱不在同一机器上，用户代理使用此协议将邮箱中的信件取回本地 IMAP，收信人使用多个用户代理访问同一邮箱，邮件始终保持在邮箱中 加密电子邮件协议：PGP与PEM协议 WWW WWW是用于访问遍布于互联网上的相互链接在一起的超文本的一种结构框架 一方面用户可以按需获取信息，另一方面为信息发布提供方便途径 WWW模型 Web页面(网页) 由对象组成 用URL标示地址 协议类型(HTTP、FTP、TELNET等) 对象所在的服务器的地址(域名或IP地址) 包含对象的路径名 大部分网页包括基本的HTML页面和引用的对象 浏览器：用户访问网页的客户端 Web服务器：存储Web对象 超文本传输协议http Web的应用层协议 使用TCP，80端口 客户/服务器模型 客户：浏览器，发送请求，接收、显示Web对象 服务器：Web服务器，接收请求，发送Web对象 无状态协议：Web服务器不保存客户信息 非持久连接和持久连接 非持久连接 HTTP/1.0 服务器解析请求，发出响应报文后关闭连接 每个object的取得都需要两个RTT 每个object的传输都要经历慢启动 采用并行TCP连接 持久连接 HTTP/1.1 在同一个TCP连接上：服务器解析请求并响应，再解析新的请求 客户端一旦得到基本的HTML文件就发出请求索取全部object 较少的RTT和慢启动时间 Web缓存 用户设置浏览器通过Web缓存来访问Web 浏览器将所有http请求发给Web缓存 如果所请求object在缓存中，该object被立即通过http回答返回 否则Web缓存向原服务器发请求获得该object，再响应浏览器的请求 为什么需要Web缓存 较小的响应时间 减轻通往远端服务器的连接的流量 文件传输协议 在两个主机之间传输文件 客户/服务器模式：由客户端发起文件传输(上传或下载) 客户端连接到FTP服务器TCP的21号端口 建立两个并行的TCP连接 控制：在客户端和服务器之间交换命令、响应 数据：传递文件数据 FTP服务器维护状态：当前目录，身份认证 FTP模型 数据连接可以双向使用 数据连接不必始终存在 控制连接采用的是telnet "},"notes/管理学基础.html":{"url":"notes/管理学基础.html","title":"管理学基础","keywords":"","body":"管理学基础 导论 什么是管理 管理的定义 泰勒的定义 管理是一门关于怎样建立目标，然后用最好、最经济的方法来实现目标的艺术 法约尔的定义 管理就是计划，组织，控制，指挥，协调 美国管理协会的定义 管理是通过他人的努力来达到目标 我们的定义 管理是为了达到组织目标而对组织内的各种资源(人财物)进行合理分配，并在一定的环境条件下采取最优的方法，领导、协调、激励、监督下属完成工作实现目标的综合性活动 管理的效率和效果 谁是管理者 管理者的定义 管理者就是从事管理工作的员工，他们确定目标，制定计划，协调资源，领导、激励、监督下属完成工作实现既定目标 管理者的层次 高层经理、中层经理、基层经理、非经理雇员 管理者做什么 管理工作内容 计划：确定目标、制定战略、制定具体实施计划、协调资源 组织：组织人员、下达任务、分工 领导：领导激励人员实施计划 控制：观测效果、监督检查工作，确保目标实现 管理者的角色 人际关系角色 首脑形象 领导者 联络者 信息联系角色 监听者 传播者 发言人 决策角色 麻烦处理者 资源分配者 谈判者 管理技能 概念性技能：综合考虑复杂多样的因素形成一个思路、框架和目标 技术性技能：专业管理技能 人际关系技能：与他人共事的技能 什么是组织 组织和企业的定义 组织是对人员的一种精心的安排，以实现某些特定的目的 组织的三大特征：明确的目的、由人组成、精细的结构 企业是从事生产、流通和服务等活动的独立的经济核算单位 企业的分类 可以通过不同的方法进行划分 根据企业所属的经济部门(行业门类) 根据所有制形式：国有、民营、集体、合资、外资 根据企业规模：大、中、小 企业所属行业 行业规模、行业增长率 行业集中度 行业劳动/资本密集度 管理学的特性 一门综合性学科 经济学：关心如何分配和配置稀缺资源 心理学：理解、引导自身和下属的行为 社会学：研究人们相互之间的关系 既是科学又是艺术 管理学的系统观念 管理学的昨天和今天 管理的历史背景 早期的管理思想 亚当·斯密的思想 亚当·斯密在《国富论》中认为劳动分工能大大提高生产效率 工业革命的发展使得企业规模不断扩大，劳动产品的复杂程度与工作专业化程度日益提高，开始出现专门从事管理的经理人 科学管理 科学管理之父：泰勒 《科学管理原理》的四条主要原则 进行时间和动作的研究，找到最优的方法，替代经验方法，标准化 科学的选择、培训，发展工人，使其能胜任工作 充分协调，激励工人，使用计件工资 合理分配管理者和工人的职责 泰勒制的贡献 泰勒在历史上第一次使管理从经验上升为科学 讲求效率的优化思想和调查研究的科学方法 泰勒制的局限性 过于机械，重视技术性，忽视人群社会因素 把工人看作是一个生产机器，仅受金钱激励 仅解决了个别具体工作的作业效率问题，而没有解决企业作为一个整体如何经营和管理的问题 生产模式的变迁 规模化生产 精益化生产 智能制造 一般行政管理理论 亨利·法约尔 泰勒极为重视作业阶层和技术能力；法约尔更为重视一般性的管理工作和职能 最早提出管理的一般性职能：计划、组织、指挥、协调及控制 组织理论和组织行为学派 官僚行政组织理论 马克斯·韦伯 组织行为的学派 早期的倡导者 罗伯特·欧文 胡戈·芒茨伯格 工业心理学的早期创始人之一 运用心理学的方法研究组织中员工的行为 第一个提出将心理测试运用于招聘甄选，将社会学习理论运用于培训，将激励理论运用于员工激励 玛丽·福莱特 第一个提出组织可以看作是个人、小组行为的总和 霍桑实验 计件制激励效果有限 社会规范，小组准则对员工个人绩效的影响也很大 人群关系理论 组织文化与外部环境 外部环境 外部环境的定义 外部环境是指能够对组织绩效造成潜在影响的外部力量和机构 可以从两个层面来分析 具体外部环境：包括那些对管理者的决策和行动直接影响并与实现组织目标直接相关的要素 一般外部环境：包括了可能影响组织的广泛的经济条件、政治/法律条件、社会文化条件、人口条件、技术条件等 外部环境的图示 一般外部环境因素(PEST分析) 政治层面分析：政策、法律、税收、环保、贸易章程、稳定性、安全规定 经济层面分析：经济增长、货币政策、汇率、通货膨胀、消费模式、生产率 社会层面分析：收入分布、人口统计、生活方式变革、教育、潮流风尚、生活条件、消费结构和水平 技术层面分析：产业技术关注、技术转让率、信息技术变革、互联网变革、移动技术、劳动生产率变化等 外部环境的不确定性 可以从两个维度来评价环境的不确定性 环境的变化程度 动态的——经常变动，难以预测 稳定的——变化很小，易于预测 环境的复杂程度 组织环境中的要素数量 组织所拥有的与这些要素相关的信息广度 与利益相关者的关系 谁是利益相关者 受组织决策和行动影响的任何相关者 包括内部和外部群体 能够对组织施加影响 全球环境中的管理 三种看待全球业务的观念 民族中心论 认为母国的工作方式和惯例是最好的 不放心让外国雇员掌握关键的决策权和技术 多国中心论 东道国的管理人员知道经营业务的最佳工作方式和惯例 由外国雇员掌握决策权 全球中心论 在世界范围内选用最佳方式和最优秀的人才 组织如何走向全球化 在全球环境下进行管理 他国政治/法律环境 他国经济环境 他国文化环境 霍夫斯泰德国家文化观 五个维度 个人主义/集体主义 权力差距 不确定性规避 男权主义/女性主义 长期/短期 技术与管理 技术 技术如同全球一体化也是企业面临的一个重要的环境因素 企业要对新技术敏感 新技术可以改造传统企业，也产生机会创建高科技新企业 组织文化 组织文化的定义 组织文化就是组织全体成员共同信奉并遵从的一种价值观、思维方式和行为准则 无形性 软约束性 相对稳定性和连续性 个性 组织文化的形成 组织的创始人 价值观、目标、使命、思维模式 组织一直以来的作法 组织里高层领导的示范作用和影响力 组织文化的延续 招聘进来的新员工是认同适应组织文化的人 介绍给新员工组织的文化 组织成员学习组织文化 故事 仪式 器物符号 语言 强文化和弱文化 强文化 组织文化被广泛和深刻的认同和遵守，并且很大程度上影响成员的行为 强文化的形成 组织成立时间的长短 组织核心价值观和准则是否清晰、具体、有力 员工离职是否频繁 强文化的利弊 利 凝聚力、规范导向作用 激励、提高业绩 吸引、甄选合适的成员 弊 可能会阻滞组织变革 可能会排除异己，不利于组织中的多样性 限制了组织管理者的自由度 决策——管理者工作的本质 决策的普遍性 决策制定过程 决策 决策的本质是在两个或者更多的方案中做出选择 决策过程 决策制定过程 8个步骤 识别决策问题 问题——现状和期望状态之间的差异 确定决策标准 决策标准——什么与制定决策有关 为决策标准分配权重 开发备择方案 列出所有可能解决决策问题的方案，无需进行评估 分析备择方案 根据决策标准评估备择方案 选择备择方案 从所有备择方案中选择最佳方案 实施备择方案 实施——包括了将决策传送给有关的人员和部门，并要求他们对实施的结果作出承诺 评估决策的结果 决定是否问题得到了解决 作为决策者的管理者 有限理性 管理者往往是在信息不完全的情况下作决策 也无法列出所有可能的方案 即便列出所有的可能方案，也可能无法做出全面科学地分析 即便这样做了，也会因为决策的成本太高而得不偿失 满意——接受的方案是“足够好”的，而非“最好” 决策过程中容易犯的错误 过分自信 厌恶损失 沉没成本 锚定效应 刻板印象 直觉性决策与科学决策 直觉性决策 管理者凭借自己的经验、感觉和积累的判断力做出决策 科学性决策 搜集信息，依据科学决策的流程，做出决策 问题和决策的类型 结构良好的问题——直接的、熟悉的和易于定义的 程序化决策——用来解决结构良好的问题 程序——相互关联的一系列顺序的步骤，管理者遵循这些步骤对结构化的问题做出响应 规则——明确的说明能做什么和不能做什么 政策——引导管理者沿着特定方向思考的指南 结构不良问题——新颖的、不经常发生的、信息模糊的和不完整的 非程序化决策——用来解决结构不良问题 现实世界中，很少有哪个管理政策是完全程序化或是完全非程序化的 决策制定条件 确定性——每一种方案是已知的 一种理想化的特征 风险性——能够估计出每一种备择方案的可能性或结果 期望值——每种可能情况下的回报 不确定性——不能肯定它的结果，以及不能对概率做出合理的估计 决策者的心理定位 最大最大选择——乐观的 最大化最大可能的收益 最大最小选择——悲观的 最大化最小可能的收益 最小最大选择 最小化最大遗憾 盈亏平衡 对管理决策的总结 计划 什么是计划 什么是计划 包含定义组织的目标、制定全局战略以实现目标，以及开发一组广泛的相关计划以整合和协调组织的工作 非正式计划——不把事情写下来 很少或几乎不讨论目标 通常缺乏连续性 正式计划——书面的形式表达出来 有具体的目标 实现目标的具体行动计划 计划的内容 做什么：目标和内容 为什么做：原因 谁去做：人员 何地做：地点 何时做：时间 怎样做：方式、手段 为什么管理者要制定计划 计划的目的 计划是主要的管理职能之一，它是其它职能的基础 计划建立了协调和努力方向 计划可以降低不确定性 计划可以减少活动的重叠和浪费 计划设立目标和标准，可以用于控制 计划和绩效 一般来说，正式的计划和以下因素有关 更高的利润 更高的投资回报率 计划工作的有效执行和实施，往往要比计划工作本身对绩效的贡献更大 正式计划并不必然导致高绩效，外部环境的影响通常是更关键的 计划的类型 计划的类型 层次 战略计划——应用于整个组织 建立组织的全局目标 寻求组织在环境中的定位 运营计划——具体规定如何实现全局目标的细节的规划 趋向于覆盖较短的时间 时间架构 长期计划——超过3年的计划 由于组织环境越来越不确定，因此长期计划的期限也在做相应的调整 短期计划——1年或短于1年的计划 具体性 具体计划——清晰定义的计划 方向性计划——具有灵活性，设立了一般的指导原则 使用频率 一次性计划——为满足特定情况需要而设计的一次性的计划 持续性计划——对重复进行的活动的持续指导 管理者如何制定计划 计划工作的一般步骤 组织目标 组织目标就是组织在一个时期内通过努力而期望获得的成果 组织目标的类型 所有的组织都有多重目标 没有单一的目标可以度量组织是否成功 平衡计分卡 目标设定的步骤 审视组织的使命 评估可获得的资源 目标层层分解 应该和组织的使命以及其它领域的目标相协调 写下你的目标，并且与相关的人员充分沟通 评估结果以判断目标是否达到 良好目标的特征(SMART) specific：具体、清晰 measurable：是可度量和定量化的 attainable：具有挑战性但是可达到的 relevant：相关性 time-bound：具有清楚的时间框架 计划工作当前面临的问题 对计划工作的批评 计划可能造成刚性 当环境发生变化时，仍然遵循原来的行动路线可能导致灾难 在动态的环境中难以计划 要求灵活性 不能被约束在正式的计划上 正式计划不能代替直觉和创造性 机械式的分析会扼杀创造性的远见 战略与战略管理 商业模式、战略、战略管理 商业模式 也叫做盈利模式、经营模式 核心问题：企业如何盈利 目标客户 独特价值 利润点 战略与战略管理 什么是战略 一组管理决策和行动，它决定了组织的长期绩效 什么是战略管理 管理人员制定战略的过程和方法 战略管理的目的 包含了许多重要的管理决策 具有正式战略管理体系的公司，其财务回报要高于那些没有战略管理系统的公司 对营利组织和非营利组织都非常重要 战略管理过程 步骤1：确定组织当前的使命、目标、战略 使命——对组织目的的陈述 对营利和非营利组织都重要 搞清组织目前的目标和战略也是重要的 步骤2：分析环境 成功的战略将是与环境吻合的战略 应当考察具体的、特定的和一般的环境，以发现正在发生的趋势和变化 步骤3：识别机会和威胁 机会——外部环境中的积极趋势 威胁——外部环境中的负面因素 步骤4：分析组织的资源和能力 考察组织的内部 每个组织都在某种程度上受到它所拥有的资源和能力的限制 核心能力——独特的能力或资源 组织主要的价值创造来源，竞争的武器 步骤5：识别优势和劣势 优势——组织擅长的活动或特有的资源 劣势——组织不擅长的活动或非特有的资源 理解组织文化的长处和短处 强文化——新员工能容易地识别核心能力 改变起来更困难 影响管理者对某些战略的偏好 SWOT分析——分析组织的优势、劣势、机会和威胁 步骤6：构造战略 需要在公司层面、事业部层面和组织的职能层面上分别建立 遵循决策制定过程的步骤 步骤7：实施战略 一个过程的战略取决于成功的实施 步骤8：评估结果 对战略的有效性进行评估 战略的类型 组织战略的层次 组织战略的类型 公司层战略 公司战略主要是决定公司应该经营什么业务，生产什么产品，退出还是进入某个行业 决定组织的方向 公司层战略类型 稳定战略 基本上不进行重大的变革 组织的绩效是令人满意的 环境是稳定的和安全的 今天很少有公司遵循该战略 增长战略：寻求扩大组织的经营规模 直接扩张方式——通过扩大原有的业务来扩张 兼并收购 横向一体化(横向收购)——通过合并同一行业中的其他组织的方式来实现增长 横向一体化的目的在于 迅速扩大生产 扩大市场份额，获得规模效益或垄断利润 消灭竞争 进入另一个国家的市场 纵向一体化(纵向收购) 后向——并购自己的供应商 目的在于稳定供应，减少经营风险 前向——并购自己的分销商 目的在于节省销售费用，减少经营风险 多元化(混合收购) 相关多元化——通过合并或收购相关产业不同业务的公司而实现增长 非相关多元化——通过收购和兼并不同产业、不同业务的公司而实现增长 调整战略 收缩战略——退出一些行业、市场，裁减一些产品线 原因可能是前期扩张速度太快，管理水平跟不上，有些边缘事业部门效率低，成本高，利润差 扭转战略——主营业务经营效率低下，收入增长缓慢，成本高居不下，利润为负，分析问题，采取一些策略扭转局势 调整的目的在于激活组织的资源和资本、重新恢复竞争力 SWOT分析与公司战略 公司业务分析——当公司战略包括多种业务时使用 波士顿咨询集团矩阵——提供了一个理解多样化业务的框架 帮助管理者建立资源分配决策的优先目标 业务根据两个维度来划分 市场份额 预期的增长率 BCG矩阵 矩阵的战略意义 现金牛 用现金投资于明星和问号 明星——需要大量投资 最终将变成现金牛 问号——两个战略 可能通过投资转化为明星业务 出售 瘦狗——出售或者清算 事业层战略 事业层战略关系企业具体在某一项产品、业务和某一个市场上的战略 战略事业单位：每一种业务可能相对独立，有各自的战略，称为一个战略事业单位 一个成功的战略事业单位一定要有自己的竞争优势，即一种与众不同的核心能力，保证企业在竞争中立于不败 长期的竞争优势 竞争优势很难保持，很多做法可以被模仿 若要保持竞争优势，必须 长期不懈的投入，比如研发、服务、质量管理 稳定的高素质的员工队伍 企业文化 竞争战略——基于五种竞争力的行业分析 新加入者的威胁——受进入堡垒的影响 替代品的威胁——受购买者忠诚和转换成本的影响 购买者的议价能力——受客户数量以及替代品的影响 供应商的议价能力——受供应商集中度的影响 现有的竞争者——收行业增长率、对公司产品或服务的需求，以及产品差异的影响 波特的竞争战略 成本领先——目标是成为行业中的低成本制造商 积极寻求在所有运营领域中的高效率 管理费用保持在尽可能低的水平 产品或服务在质量上必须不低于竞争对手 差异化——寻求提供与众不同的产品，并得到顾客的广泛认同 使公司有别于它的竞争对手 差异化的来源可以是与众不同的质量、独树一帜的服务、创新的设计、技术或是杰出的品牌 顾客愿意对产品和服务付出溢价，这种溢价超出了差异化所增加的成本 聚焦战略——目的是在狭窄的市场间隔上寻求成本优势，或者差异化优势 不是试图服务于广阔的市场 战略是否可行取决于市场区隔的规模，以及组织能否支撑聚焦战略所支出的成本 职能层战略 需要支持事业层的战略 对于组织中的每一个职能部门，创造合适的支持角色 组织结构与设计 基本术语 组织结构——组织中正式确定的使工作任务得以分解、组织和协调的框架体系 组织设计——建立和变革组织结构的过程 组织设计的要素 组织设计的六个要素 分工与工作专门化 组织中的任务被划分为各项专门工作的程度 各个员工都仅专门从事某一部分的活动而不是全部活动 分工过细的优点 熟练程度提高 减少任务切换之间的时间损失 发明新机器 提高劳动生产率 分工过细的缺点 工作单调，员工感到厌倦疲劳 能力畸形 管理跨度 管理跨度也叫管理幅度指直接管理的下属数量 管理跨度在很大程度上决定了组织中管理层次的数目与管理人员的数量 管理跨度也关系到效率 管理幅度过宽 监督不严 下级等上级，浪费时间 下级感到不被重视 上级劳累过度 幅度过窄 管理层次增加，费用增加 信息流通慢，效率低 管理太严，下属不满 下级自由度太小，无聊 影响管理跨度的因素 管理者和下属的技能和能力 下属工作的相似性 任务的复杂性 下属工作地点的相近性 组织管理信息系统的先进程度 组织文化的凝聚力 管理者的偏好的管理风格 部门化 部门化的五种基本方法——将若干职位组合在一起的依据和方式 工作的性质：职能部门化 传统方法 优势 职能之间的分工，提高效率，加强每一职能内的知识技术水平 劣势 职能间缺乏合作、互相不支持 缺乏对组织整体目标的认识 所提供的产品或服务：产品部门化(事业部) 多元化经营的企业的通常采用按产品划分的方法 优点 产品和服务的部门成为战略中心、专门化经营、强调结果——事业部经理对特定产品或服务的经营负责 缺点 职能重复配置 活动和资源重复配置导致成本上升、效率降低 目标顾客或客户：顾客部门化 服务性的企业通常采用此方法 优点 更好满足不同种类客户的需求 有针对性地按需生产、按需促销 缺点 职能重复配置 划分太机械、不适时调节、反而无法满足顾客 所涵盖的地理范围：地区部门化 很多企业的销售部都采用了按地区划分的方法 有的企业采用按地区划分建立总-分公司结构 优点 可以更有效的服务地区市场 责任到区域，每个区域都是一个利润中心，区域经理负责盈亏 缺点 职能部门重复配置 地区间竞争 将投入转换成产出的过程：流程部门化 很多企业生产部门都采用了按流程划分的方法 优点 生产流程顺畅，每一道工序专人负责保证效率、质量 充分利用专业技术和技能，简化培训 缺点 应用有限 部门间协作困难 指挥链 是指从组织高层延伸到基层的一条持续的职权线，它界定了谁向谁报告工作 职权为管理职位所赋予的权力，可以发号施令且可预期命令会被遵守，与组织中的职位有关，而与管理者的个人特质无关——支配资源权力 职责为当管理者被授予职权的同时，也被赋予相称的职责，当员工接受职权时，也就肩负起执行的义务——对后果负责 职权和职责必须对等：职权可以下授，职责无法下授：授权者仍须为其授予的行动负责 统一指挥：每个下属应当而且只能向一个上级主管直接报告工作 集权与分权 集权：决策权集中在高层管理者的程度 分权：决策权下授到组织的低层管理者的程度 目的：最适切、最有效地利用员工，分权以解决问题、分权以快速因应环境变化、分权以提高员工的投入与对组织的认同 影响集权与分权度的因素 正规化 是指组织中员工行为受规则和程序约束的程度，如着装要求，上班打卡，午餐、休息时间 在生产和提供标准化产品时，需要正规化；在强调设计、创新的工作中，强调个性，减少正规化 组织设计的决策 机械式与有机式组织 影响组织结构的权变因素 权变因素 公司战略 组织结构的设计以及调整都是为了组织的战略目标服务 成本领先战略通常伴随机械结构；有机式结构有助创新 组织的大小 很多时候，在组织人员逐渐壮大的同时，组织结构不得不从有机结构转换为机械结构 技术生产 传统制造业要求机械式结构；IT、金融、服务业可以尝试有机结构 环境的不确定性 在环境经常变换、不确定性高的时候，越需要有机结构 传统组织结构与现代组织结构 基于团队的结构 整个组织是由执行组织的各项任务的工作小组或团队组成 这种组织不存在高层到基层的管理职权链 团队成员自己安排工作，对负责领域的工作活动和结果负责 优点：员工参与，发挥创造力，解决问题；减少跨职能之间的隔断 缺点：没有明晰的指挥链；小组的绩效问题 矩阵型结构 从各职能部门抽调有关专家，分派到由项目经理领导的项目组中 优点：职能部门可以更好的服务项目组 缺点：违背了“统一指挥”的原则，双重指挥链，多头领导；如何对职能部门的人员的绩效进行考核、定薪 无边界组织 横向的、纵向的或外部的边界不由某种预先设定的结构所限定或定义的一种组织设计 横向边界是由工作专门化和部门化形成的 纵向边界是将员工划分为不同组织层级的结果 外部边界是将组织与其顾客、供应商及其它利益相关者分离开来的隔墙 人力资源管理 人力资源管理的目标 发现和聘用那些能够充分胜任工作的员工 不断更新员工的知识和技能，保证员工持续的胜任力 用各种物质的和非物质的方法吸引保留优秀员工 人力资源管理内容 环境因素 劳动政策、劳动立法 人力资源管理的各个职能都受到劳动政策、劳动立法的约束 人力资源管理的基础：岗位分析 包括岗位设计和岗位描述 从岗位和人(任职资格)两方面入手 岗位主要职责、工作内容、直接上下级 从事岗位工作的员工所需的知识、技能 岗位说明书 岗位说明书是明确岗位目的、主要职责、工作关系、任职要求、岗位权限等的说明性文件，也是最基本的管理工具之一 岗位职责是岗位说明书中最重要的一部分 不同岗位的职责不应有重叠 各岗位职责的汇总构成所在部门的职责 个体行为与激励 组织行为学的焦点和目的 OB的焦点 个体行为——态度、人格、认知、动机等 群体行为——群体规范、领导和冲突等 群体中的个体行为与个体单独活动时的行为并不一致 OB的目的 理解组织里人在个体和团队模式下的行为、从而可以预测并影响行为，鼓励加强有利于组织的行为、减少不利于组织的行为 正面行为：积极投入本职工作 负面行为：迟到早退；消极怠工；离职 影响个体行为的要素 态度 态度的定义 是指物体、人物和事件的评价性陈述 工作满意度：员工对自己工作的总体态度，以及对工作各个维度(如薪酬、福利)的态度 性格 个人具备的独特的心理特点的总合 性格可以预测绩效 “大五人格” 内向/外向 开放/封闭 责任意识 随和性 敏感性 MBTI职业人格 第一个维度：外倾 vs 内倾 它指我们与外部世界或内心世界相处时，获取能量的方式 第二个维度：感觉 vs 直觉 它指接受信息与认知世界的方式 第三个维度：情感 vs 思维 这是我们做决策的方式，用感性还是理性 第四个维度：判断 vs 知觉 这个维度的名词非常不直观，因为它通常被阐释为“生活方式的偏好”或者“你希望你的外部世界如何组织” 动机与激励理论 什么是动机 动机——行为的驱动力 需要——一种内部状态，它使人感到某种结果具有新引力 不满足的需求引起紧张，紧张激发内驱力 内驱力导致个体寻求特定目标的行为 需求层次理论 美国心理学家马斯洛1954年提出 赫茨伯格的激励——保健理论 美国学者赫茨伯格1968年提出 保健因素 这些因素具备时，不会产生激励，但不具备时，会产生不满 激励因素 这些因素具备时，会产生激励，但不具备时，不会产生不满 激励员工的一些建议 因人而异、按需激励 物质激励与精神激励相结合 正激励与负激励相结合 关注员工的态度、感知 确保员工了解对其行为的期望，以及行为与绩效的关系 团队与领导 理解群体行为 什么是群体 两个或两个以上相互作用、相互依赖的个体，为了实现特定的目标而组合在一起的集合体 正式群体——由组织建立的工作群体 有着明确的工作分工和具体的工作任务 存在不同类型 非正式群体——自然而然出现，反映了人们对于社会交往与接触的需要 基本的群体概念 角色 地位系统 规范和遵从 群体内聚力 冲突管理 领导理论 管理者与领导者 领导者与领导力 领导——能够带领、影响、激发下属为实现组织目标而工作的人 领导力——领导者的行为、领导大家实现组织目标的过程 理想情况下，所有管理者都应当是领导者 领导学研究：什么样的领导是好领导？有效的领导行为是什么？ 早期的领导理论 领导特质理论 品质理论、性格理论，这种理论着重研究领导者的品质和特性，是整个领导领域研究的开端 关注领导者与非领导者在个性、特质或智力因素方面是否存在显著差异 领导特质 内在驱动力 领导愿望 诚实与正直 自信 智慧 工作相关知识 领导行为理论 独裁型风格 民主型风格 民主风格可以提高工作的质与量 放任型风格 领导行为的两个维度 定规 领导者界定和构造自己和员工的角色，以达成目标的程度，规划工作，界定任务，明确目标，制定规章制度 关怀 领导者在工作中尊重下属的看法与情感并与下属建立相互信任的程度 定规和关怀程度均高的领导，可以得到正向的结果，员工的绩效和满意程度都比较高，有时有例外发生，所以必须考虑其它的情境因素 两项与领导行为有关的维度 员工导向 重视人际关系，关心员工的需求，接受员工间的个人差异 生产导向 强调工作的技术方面和任务方面，关心群体任务的完成情况，视群体成员为达到目的的手段和工具 员工导向的领导者，群体的生产力和满意度都比较高 管理方格 有关领导的最新观点 魅力型与愿景型领导 魅力型 能清晰生动地描述一个愿景目标，并愿意为之冒风险 对环境限制和下属需要十分敏感 行为表现常常超乎常规 愿景型 向他人解释愿景的能力 不但通过言语更要通过行动表达愿景的能力 在不同领导情景中施展并运用愿景的能力 自恋型与谦卑型领导 自恋型 有魅力，高度自信 追求自我影响力，渴望成为焦点 追求宏伟及自利目标 对他人表现的抑制和表面的关心 谦逊型 有更加准确的自我概念 认识到自身的弱点与缺陷 擅长听取建议，也擅长发现他人的优点及贡献 表现出对同事的尊重 控制 控制的基本概念 控制的定义 控制就是检查工作是否按既定的计划、标准和方法进行，发现偏差，分析原因，进行纠正，以确保组织目标的实现 控制过程一般假定工作的标准总是存在的，该标准必须在计划过程中产生 控制的重要性 控制的类型 控制的过程 衡量 要决定实际的工作绩效，管理者必须先搜集信息，再衡量绩效，主要包括衡量什么和如何衡量 衡量什么 计划工作中制定的目标 财务：利润；资产回报率；股票回报率 顾客、市场与战略：市场份额；新增客户；老客户保有率 内部流程：生产、质量、库存 人事：员工绩效、满意度、离职率 如何衡量 管理者衡量实际工作绩效有四种常见方法：个人观察、统计报告、口头汇报和书面报告 一手资料：个人观察 二手资料：统计报表，口头、书面报告 比较 确定实际工作成绩与标准之间的偏差 采取管理行动 管理者可以在三种行动方案中选择：什么也不做、改进实际工作、修订标准 改进实际工作：具体方式很多，包括调整管理策略、组织结构、培训计划等 直接纠正行为：立即修正问题，以使绩效恢复常轨 彻底纠正行为：先找出绩效如何偏离、为什么偏离，再加以改善 修订标准：现实的标准要坚持 控制的内容 常见的控制内容为：财务控制、生产和库存控制、质量控制、成本控制、人员控制 常见的财务控制有预算控制、财务审计和财务分析 "},"notes/机器学习概论.html":{"url":"notes/机器学习概论.html","title":"机器学习概论","keywords":"","body":"机器学习概论 "},"notes/博弈论1.html":{"url":"notes/博弈论1.html","title":"博弈论(上)","keywords":"","body":"博弈论(上) Introduction Three mathematical models: Extensive Form, Strategic Form, Coalition Form. Two Person 0-Sum Games Games with only two players in which one player wins what the other player loses. Strategic Form The strategic form, or normal form, of a two-person zero-sum game is given by a triplet (X, Y, A), where (1) X is a nonempty set, the set of strategies of Player I (2) Y is a nonempty set, the set of strategies of Player II (3) A is a real-valued function defined on X × Y. (Thus, A(x, y) is a real number for every x X and every y ⊆ Y) The interpretation is as follows: Simultaneously, Player I chooses x ⊆ X and Player II chooses y ⊆ Y, each unaware of the choice of the other. Then their choices are made known and I wins the amount A(x, y) from II. If A is negative, I pays the absolute value of this amount to II. Thus, A(x, y) represents the winnings of I and the losses of II. Matrix Games A finite two-person zero-sum game in strategic form, (X, Y, A), is sometimes called a matrix game because the essential information of the game, the payoff function A, can be represented by a matrix. If X = x1,...,xm{x_1, . . . , x_m}x​1​​,...,x​m​​ and Y = y1,...,yn{y_1, . . . , y_n}y​1​​,...,y​n​​, then by the game matrix or payoff matrix we mean the matrix A=(a11⋯a1n⋮⋮am1⋯amn)A=\\begin{pmatrix} a_{11} & \\cdots & a_{1n}\\\\ \\vdots & & \\vdots\\\\ a_{m1} & \\cdots & a_{mn} \\end{pmatrix}A=​⎝​⎛​​​a​11​​​⋮​a​m1​​​​​⋯​​⋯​​​a​1n​​​⋮​a​mn​​​​​⎠​⎞​​ where aij=A(xi,yj),a_{ij} = A(x_i, y_j),a​ij​​=A(x​i​​,y​j​​), In this form, Player I chooses a row, Player II chooses a column, and II pays I the entry in the chosen row and column. Note that the entries of the matrix are the winnings of the row chooser and losses of the column chooser. Player I: the Row choser. Player II: the Column chooser. Dominated Strategies Definition: We say the ithi^{th}i​th​​ row of a matrix A=(aij)A = (a_{ij})A=(a​ij​​) dominates the kth row if aij≥akja_{ij} \\geq a_{kj}a​ij​​≥a​kj​​ for all j. We say the ithi^{th}i​th​​ row of A strictly dominates the kthk^{th}k​th​​ row if aijakja_{ij} a_{kj}a​ij​​a​kj​​ for all j. Similarly, the jthj^{th}j​th​​ column of A dominates (strictly dominates) the kthk^{th}k​th​​ column if aij≤aika_{ij} \\leq a_{ik}a​ij​​≤a​ik​​ (resp. aijaika_{ij} a​ij​​a​ik​​) for all i. Best Response Definition: Let (X, Y, A) be a matrix game. Let x ⊆ X be a strategy of Player I. Then, y ⊆ Y is called a Best Response (BR) to x if A(x, y) ≤ A (x, y’) for any y’ ⊆ Y. Equivalently, Let y ⊆ Y be a strategy of Player II. Then, x ⊆ X is called a Best Response (BR) to y if A(x, y) ≥ A (x’, y) for any x’ ⊆ X. Equilibrium Principle: Best Responses to each other. Maximum Principle: Safety First. Saddle points Pure Strategic Equilibrium, PSE, for 2-person 0-sum games. If some entry aija_{ij}a​ij​​ of the matrix A has the property that (1) aija_{ij}a​ij​​ is the minimum of the ithi^{th}i​th​​ row, and (2) aija_{ij}a​ij​​ is the maximum of the jthj^{th}j​th​​ column, then we say aija_{ij}a​ij​​ is a saddle point. If aija_{ij}a​ij​​ is a saddle point, then Player I can then win at least aija_{ij}a​ij​​ by choosing row i, and Player II can keep her loss to at most aija_{ij}a​ij​​ by choosing column j. is then an equilibrium pair, i.e. BR to each other. Maximin Principle Maximin Principle means to find the “risk” for each strategy and then find the strategy, called the safety strategy, with minimum risk. Mixed Strategies Consider a finite 2-person zero-sum game, (X, Y, A), with m×n matrix, A. Let us take the strategy space X to be the first m integers, X = {1, 2, . . .,m}, and similarly, Y = {1, 2, . . . , n}. A mixed strategy for Player I may be represented by a column vector, (p1,p2,...,pm)T(p_1, p_2, . . . , p_m )^T(p​1​​,p​2​​,...,p​m​​)​T​​ of probabilities that add up to 1. Similarly, a mixed strategy for Player II is an n-tuple q=(q1,q2,...,qn)T\\mathbf q = (q_1, q_2, . . . , q_n)^Tq=(q​1​​,q​2​​,...,q​n​​)​T​​. The sets of mixed strategies of players I and II will be denoted respectively by X*, Y*: X* = {p\\{ \\mathbf p{p = (p1,...,pm)T(p_1, . . . , p_m )^T(p​1​​,...,p​m​​)​T​​ : pip_ip​i​​ ≥ 0, for i = 1, . . . , m and p1+...+pmp_1 +...+ p_mp​1​​+...+p​m​​ =1}\\}} Y* = {q\\{ \\mathbf q{q = (q1,...,qn)T(q_1, . . . , q_n)^T(q​1​​,...,q​n​​)​T​​ : qjq_jq​j​​ ≥ 0, for j = 1, . . . , n and q1+...+qnq_1 +...+ q_nq​1​​+...+q​n​​ =1}\\}} p=(p1,p2,...,pm)T\\mathbf p = (p_1, p_2, . . . , p_m)^Tp=(p​1​​,p​2​​,...,p​m​​)​T​​ means playing Row 1 with probability p1p_1p​1​​, playing Row 2 with probability p2p_2p​2​​, ... , playing Row m with probability pmp_mp​m​​. The m-dimensional unit vector ek\\mathbf e_ke​k​​ ⊆ X* with a one at the kthk^{th}k​th​​ component and zeros elsewhere may be identified with the pure strategy of choosing row k. We may consider the set of Player I’s pure strategies, X, to be a subset of X*. Similarly, Y may be considered to be a subset of Y*. We could if we like consider the game (X, Y, A) in which the players are allowed to use mixed strategies as a new game (X*, Y*,A), where A(p,q)=pTAq=∑i∑jpiaijqjA(\\mathbf p, \\mathbf q) = \\mathbf p^T\\mathbf A \\mathbf q = \\sum\\limits_i\\sum\\limits_j p_ia_{ij}q_jA(p,q)=p​T​​Aq=​i​∑​​​j​∑​​p​i​​a​ij​​q​j​​. Safety Strategies For each p ⊆ X*, the worst payoff is minq∈Y∗pTAq\\min\\limits_{q\\in Y*}p^TAq​q∈Y∗​min​​p​T​​Aq. The minimum is achieved at a pure strategy of Player II. Lemma: For each fixed p, the minimum of A(p, q) as a function of q on Y* is achieved at a vertex of Y*, or, equivalently, at a pure strategy. Theorem: There exists p~∈X∗\\tilde p\\in X^*​p​~​​∈X​∗​​ such that minq∈Y∗p~TAq=maxp∈X∗minq∈Y∗pTAq\\min\\limits_{q\\in Y^*}\\tilde p^TAq = \\max\\limits_{p\\in X^*}\\min\\limits_{q\\in Y^*}p^TAq​q∈Y​∗​​​min​​​p​~​​​T​​Aq=​p∈X​∗​​​max​​​q∈Y​∗​​​min​​p​T​​Aq, p~\\tilde p​p​~​​ is called the safety strategy of Player I and V‾=minq∈Y∗p~TAq=maxp∈X∗minq∈Y∗pTAq\\underline V = \\min\\limits_{q\\in Y^*}\\tilde p^TAq = \\max\\limits_{p\\in X^*}\\min\\limits_{q\\in Y^*}p^TAq​​V​​=​q∈Y​∗​​​min​​​p​~​​​T​​Aq=​p∈X​∗​​​max​​​q∈Y​∗​​​min​​p​T​​Aq is called the lower value of the game. Theorem: There exists q~∈Y∗\\tilde q\\in Y^*​q​~​​∈Y​∗​​ such that minp∈X∗pTAq~=minq∈Y∗maxp∈X∗pTAq=V‾\\min\\limits_{p\\in X^*}p^TA\\tilde q = \\min\\limits_{q\\in Y^*}\\max\\limits_{p\\in X^*}p^TAq = \\overline V​p∈X​∗​​​min​​p​T​​A​q​~​​=​q∈Y​∗​​​min​​​p∈X​∗​​​max​​p​T​​Aq=​V​​​. q~\\tilde q​q​~​​ is called the safety strategy of Player II and V‾\\overline V​V​​​ is called the upper value of the game. Theorem: V‾≤V‾\\underline V \\leq \\overline V​​V​​≤​V​​​ . MiniMax Theorem minq∈Y∗maxp∈X∗pTAq=maxp∈X∗minq∈Y∗pTAq,i.e.V‾=V‾\\min\\limits_{q\\in Y^*}\\max\\limits_{p\\in X^*}p^TAq = \\max\\limits_{p\\in X^*}\\min\\limits_{q\\in Y^*}p^TAq, i.e. \\underline V = \\overline V​q∈Y​∗​​​min​​​p∈X​∗​​​max​​p​T​​Aq=​p∈X​∗​​​max​​​q∈Y​∗​​​min​​p​T​​Aq,i.e.​​V​​=​V​​​. Then, V=V‾=V‾V = \\underline V = \\overline VV=​​V​​=​V​​​ is called the value of the game. Because of the MiniMax Theorem, the safety strategies are also called the optimal strategies. 2-strategy games safety strategies: A=(abdc)A=\\begin{pmatrix} a & b \\\\ d & c \\end{pmatrix}A=(​a​d​​​b​c​​) p=∣c−d∣∣c−d∣+∣a−b∣,1−p=∣a−b∣∣c−d∣+∣a−b∣p=\\frac{|c-d|}{|c-d|+|a-b|}, 1-p=\\frac{|a-b|}{|c-d|+|a-b|}p=​∣c−d∣+∣a−b∣​​∣c−d∣​​,1−p=​∣c−d∣+∣a−b∣​​∣a−b∣​​ q=∣c−b∣∣c−b∣+∣a−d∣,1−q=∣a−d∣∣b−c∣+∣a−d∣q=\\frac{|c-b|}{|c-b|+|a-d|}, 1-q=\\frac{|a-d|}{|b-c|+|a-d|}q=​∣c−b∣+∣a−d∣​​∣c−b∣​​,1−q=​∣b−c∣+∣a−d∣​​∣a−d∣​​ Solving 2×n and m×2 games: (i) Check for saddle point first. If there is a saddle point then we solve the game already. (ii) Suppose there is no saddle point. Using the graphical method, we can find the safety strategy of Player I for 2 × n games. Since the Maximin occurs at the intersection of two lines, Player II, knowing that Player I will play his/her safety strategy, will play the two Columns giving rise to the two lines. The situation then reduces to 2 × 2 games. Maximin Principle ⇔\\Leftrightarrow⇔ Equilibrium Principle Lemma: Let p belong to X* and we let JpJ_pJ​p​​={j: Column j is a BR to p}, the set of best response columns to p. Then, q=(q1,...,qn)T\\mathbf q=(q_1,...,q_n)^Tq=(q​1​​,...,q​n​​)​T​​ a BR to p iff qjq_jq​j​​>0 implies j belongs to JpJ_pJ​p​​. Let q belong to Y* and we let IqI_qI​q​​={i: Row i is a BR to q}, the set of best response rows to q. Then, p=(p1,...,pm)T\\mathbf p=(p_1,...,p_m)^Tp=(p​1​​,...,p​m​​)​T​​ a BR to q iff pip_ip​i​​>0 implies i belongs to IqI_qI​q​​. Theorem(Principle of Indifference): Let p=(p1,...,pm)T\\mathbf p=(p_1,...,p_m)^Tp=(p​1​​,...,p​m​​)​T​​ lie in X* and q=(q1,...,qn)T\\mathbf q=(q_1,...,q_n)^Tq=(q​1​​,...,q​n​​)​T​​ lie in Y* such that is an equilibrium pair, i.e. BR to each other. Let pTAq=Vp^TAq=Vp​T​​Aq=V. Then, ai1q1+...+ainqn=Va_{i1}q_1+...+a_{in}q_n=Va​i1​​q​1​​+...+a​in​​q​n​​=V for all i for which pip_ip​i​​>0 and a1jp1+...+amjpm=Va_{1j}p_1+...+a_{mj}p_m=Va​1j​​p​1​​+...+a​mj​​p​m​​=V for all j for which qjq_jq​j​​>0. Theorem(Exchange Principle): Let p1p_1p​1​​, q1q_1q​1​​>, p2p_2p​2​​, q2q_2q​2​​> be equilibrium pairs. Then, p1p_1p​1​​, q2q_2q​2​​> is also an equilibrium pair. Definition: p belong to X* is called an equalizing strategy whenever A(p,q)=A(p,q’) for any q, q’ in Y*. q belong to Y* is called an equalizing strategy whenever A(p’,q)=A(p,q) for any p, p’ in X*. Theorem: Suppose p, q are equalizing strategies for Player I, Player II respectively. Then, p, q are BR to each other and hence is an equilibrium pair. Finding safety (Optimal) strategies when the value is given Theorem: Let A=(aija_{ij}a​ij​​) be a matrix game with value V. The p is a safety strategy for Player I iff the following n inequalities are satisfied: p1a11+...+pmam1≥Vp_1a_{11}+...+p_ma_{m1}\\geq Vp​1​​a​11​​+...+p​m​​a​m1​​≥V ⋮⋮⋮\\vdots \\qquad \\vdots \\qquad \\qquad \\vdots⋮⋮⋮ p1a1n+...+pmamn≥Vp_1a_{1n}+...+p_ma_{mn}\\geq Vp​1​​a​1n​​+...+p​m​​a​mn​​≥V Theorem: A finite symmetric game(A=−ATA=-A^TA=−A​T​​) has value zero. Any strategy optimal (safety) for one player is also optimal for the other. It is equivalent to study the following optimization problem: minimize (x1+...+xmx_1+...+x_mx​1​​+...+x​m​​) subject to the constraints: 1≤x1a11+...+xmam11\\leq x_1a_{11} + ... + x_ma_{m1}1≤x​1​​a​11​​+...+x​m​​a​m1​​ ⋮⋮⋮\\vdots \\qquad \\vdots \\qquad \\qquad \\vdots⋮⋮⋮ 1≤x1a1n+...+xmamn1\\leq x_1a_{1n} + ... + x_ma_{mn}1≤x​1​​a​1n​​+...+x​m​​a​mn​​ xi≥0 for i=1,...,mx_i \\geq 0\\ for\\ i = 1,...,mx​i​​≥0 for i=1,...,m This is the Primal Problem of a linear programming problem. The optimal value of this problem is 1/V. Games in Extensive Form The Extensive Form of a Game The extensive form, is built on the basic notions of position and move. This is a most detailed description of a game. It tells exactly which player should move, what are the choices, the outcomes, the information of the players at every stage, and so on. In the extensive form, games are sequential, interactive processes which moves from one position to another in response to the wills of the players or the whims of chance. It will justify and give meaning to more abstract concepts such as strategy. Three new concepts make their appearance in the extensive form of a game: the game tree, chance moves, and information sets. The Game Tree The Kuhn tree of a game: When a tree is used to define a game, the vertices are interpreted as positions and the edges as moves. Each nonterminal position is assigned either to the player responsible to choosing the next move or to chance. Chance Moves: To incorporate chance moves in the Kuhn tree, we introduce a new player called Chance (Dame Fortune). The moves from Chance carry different probabilities. The probabilities assigned to the edges leading out of each chance vertex must be displayed. Information: When a player choosing a move is uninformed about some of the previous moves (concealed moves, simultaneous moves etc.), we draw little “balloons” around set of vertices which the player making the choice cannot discriminate. These are called information sets, and the player in question must make the same choice for all vertices in the set. Edges issuing from vertices in the information set must be labeled the same. Game of Perfect Information A game of perfect information is a game in extensive form in which each information set of every player contains a single vertex. Games in which players remember all past information they once knew and all past moves they made are called games of perfect recall. Games in which both players know the rules of the game, that is, in which both players know the Kuhn tree, are called games of complete information. Games in which one or both of the players do not know some of the payoffs, or some of the probabilities of chance moves, or some of the information sets, or even whole branches of the tree, are called games with incomplete information. Reduction of a Game in Extensive Form to Strategic Form Reduced pure strategy: Specification of choices at all information sets except those that are eliminated by the previous moves. Random payoffs: The actual outcome of the game for given pure strategies of the players depends on the chance moves selected, and is therefore a random quantity. We represent random payoffs by their expected values. Pure Strategic Equilibrium: A vector of Pure Strategy choices (x1,x2,...,xn)(x_1, x_2, ... , x_n)(x​1​​,x​2​​,...,x​n​​) with xi∈Xix_i \\in X_ix​i​​∈X​i​​ for i = 1, . . . , n is said to be a Pure Strategic Equilibrium, or PSE for short, if for all i = 1, 2, . . . , n, and for all x∈Xix \\in X_ix∈X​i​​, ui(x1,...,xi−1,xi,xi+1,...,xn)≥ui(x1,...,xi−1,x,xi+1,...,xn)u_i (x_1, ... , x_{i-1}, x_i, x_{i+1}, ... , x_n) \\geq u_i (x_1, ... , x_{i-1}, x, x_{i+1}, ... , x_n)u​i​​(x​1​​,...,x​i−1​​,x​i​​,x​i+1​​,...,x​n​​)≥u​i​​(x​1​​,...,x​i−1​​,x,x​i+1​​,...,x​n​​). Extensive Games of perfect information always have at least one PSE that may be found by the method of backward induction. Method of Backward Induction: Starting from any terminal vertex and trace back to the vertex leading to it. The player at this vertex will discard those edges with lower payoff. Then, treat this vertex as a terminal vertex and repeat the process. Then, we get a path from the root to a terminal vertex. Definition: A subgame of a game presented in extensive form is obtained by taking a vertex in the Kuhn tree and all the edges and paths originated from this vertex. Definition: A PSE of a game in extensive form is called a Perfect Pure Strategy Equilibrium (PPSE) if it is a PSE for all subgames. Theorem: The path obtained by the method of backward induction defines a PPSE. Behavior Strategy: A behavior strategy is obtained if the Player makes a randomized choice independently at each of his/her information sets. Dimension of behavior strategies: Suppose the Player has m information sets such that there are kik_ik​i​​ choices at the ithi^{th}i​th​​ information set. Then, the dimension of behavior strategies for this player is (k1−1)+(k2−1)+...+(km−1)(k_1-1) + (k_2-1) + ... + (k_m-1)(k​1​​−1)+(k​2​​−1)+...+(k​m​​−1). Note that the space of mixed strategies is (k1k2...km−1)(k_1k_2...k_m-1)(k​1​​k​2​​...k​m​​−1). Theorem (Harold Kuhn): For a game of perfect recall, mixed strategies are equivalent to behavior strategies. Bimatrix Games Two-Person General-Sum Games/General-Sum Strategic Form Games The normal or strategic form of a two person game is given by two sets X and Y of pure strategies of the players, and two real-valued functions u1(x,y)u_1(x, y)u​1​​(x,y) and u2(x,y)u_2(x, y)u​2​​(x,y) defined on X × Y, representing the payoffs to the two players. If Player I chooses x ⊆ X and Player II chooses y ⊆ Y, then Player I receives u1(x,y)u_1(x, y)u​1​​(x,y) and Player II receives u2(x,y)u_2(x, y)u​2​​(x,y). A finite two-person game in strategic form can be represented as a matrix of ordered pairs, sometimes called a bimatrix. The first component of the pair represents Player I’s payoff and the second component represents Player II’s payoff. If m and n representing the number of pure strategies of the two players, the game may be represented by two m × n matrices A = (aija_{ij}a​ij​​) and B = (bijb_{ij}b​ij​​). The interpretation here is that if Player I chooses row i and Player II chooses column j, then Player I wins aija_{ij}a​ij​​ and Player II wins bijb_{ij}b​ij​​, where aija_{ij}a​ij​​ and bijb_{ij}b​ij​​ are the elements in the ithi^{th}i​th​​ row, jthj^{th}j​th​​ column of A and B respectively. The game of bimatrix in the above is represented as [A,B]. The theory is generally divided into two branches, the noncooperative theory and the cooperative theory. In the non-cooperative theory, either the players are unable to communicate before decisions are made, or if such communication is allowed, the players are forbidden or are otherwise unable to make a binding agreement on a joint choice of strategy. The main non-cooperative solution concept is the strategic equilibrium (SE). In the cooperative theory, it is assumed that the players are allowed to communicate before the decisions are made. They may make threats and counter-threats, proposals and counter-proposals, and hopefully come to some compromise. They may jointly agree to use certain strategies, and it is assumed that such an agreement can be made binding. The cooperative theory itself breaks down into two branches, depending on whether or not the players have comparable units of utility and are allowed to make monetary side payments in units of utility as an incentive to induce certain strategy choices. The corresponding solution concept is called: • TU(transferable utility) cooperative value if side payments are allowed. • NTU(non-transferable utility) cooperative value if side payments are forbidden or otherwise unattainable. Safety Levels In a bimatrix game with m×n matrices A and B, Player I can guarantee winning on the average at least vI=maxpminj(p1a1j+...+pmamj)=Val(A)v_I = \\max\\limits_p \\min\\limits_j (p_1a_{1j}+...+p_m a_{mj})= Val(A)v​I​​=​p​max​​​j​min​​(p​1​​a​1j​​+...+p​m​​a​mj​​)=Val(A). This is called the safety level of Player I. Player I can achieve this payoff without considering the payoff matrix of Player II. A strategy, p, that achieves the maximum is called a maxmin strategy for Player I. Strategic Equilibrium A finite n-person game in strategic form is given by n nonempty finite sets, X1,X2,...,XnX_1, X_2, ... , X_nX​1​​,X​2​​,...,X​n​​, and n real-valued functions u1,u2,...,unu_1, u_2, ... , u_nu​1​​,u​2​​,...,u​n​​, defined on X1×X2×...×XnX_1 \\times X_2 \\times ... \\times X_nX​1​​×X​2​​×...×X​n​​. The set XiX_iX​i​​ represents the pure strategy set of player i and ui(x1,x2,...,xn)u_i(x_1, x_2, ... , x_n)u​i​​(x​1​​,x​2​​,...,x​n​​) represents the payoff to player i when the pure strategy choices of the players are x1,x2,...,xnx_1, x_2, ... , x_nx​1​​,x​2​​,...,x​n​​, with xj∈Xjx_j \\in X_jx​j​​∈X​j​​ for j = 1, 2, . . . , n. We denote the set of probabilities over k points by PkP_kP​k​​: PkP_kP​k​​ = {p=(p1,...,pk)\\{ \\mathbf p = (p_1, ... , p_k){p=(p​1​​,...,p​k​​) : pi≥0p_i \\geq 0p​i​​≥0 for i = 1, ... , k, and p1+...+pk=1}p_1 + ... + p_k = 1\\}p​1​​+...+p​k​​=1}. Let mim_im​i​​ denote the number of pure strategy choices of player i, so that the set XiX_iX​i​​ has mim_im​i​​ elements. Then the set of mixed strategies of player i is just PmiP_{m_i}P​m​i​​​​. It is denoted by Xi∗X^*_iX​i​∗​​ where Xi∗=PmiX^*_i = P_{m_i}X​i​∗​​=P​m​i​​​​. We denote the set of elements of XiX_iX​i​​ by the first mim_im​i​​ integers, Xi={1,2,...,mi}X_i = \\{1, 2, ..., m_i\\}X​i​​={1,2,...,m​i​​}. Suppose that for i = 1, 2, ... , n, Player i uses pi=(pi1,pi2,...,pimi)∈Xi∗\\mathbf p_i = (p_{i1}, p_{i2}, ... , p_{im_i}) \\in X^*_ip​i​​=(p​i1​​,p​i2​​,...,p​im​i​​​​)∈X​i​∗​​. Then the average payoff to player j is uj(p1,...,pn)=∑i1...∑inp1i1...pninuj(i1,...,in)u_j(\\mathbf p_1,...,\\mathbf p_n)=\\sum\\limits_{i_1}...\\sum\\limits_{i_n}p_{1i_1}...p_{ni_n}u_j(i_1,...,i_n)u​j​​(p​1​​,...,p​n​​)=​i​1​​​∑​​...​i​n​​​∑​​p​1i​1​​​​...p​ni​n​​​​u​j​​(i​1​​,...,i​n​​) Definition: A vector of mixed strategy choices (also called a strategy profile) (p1,p2,...,pn)(\\mathbf p_1, \\mathbf p_2, ... , \\mathbf p_n)(p​1​​,p​2​​,...,p​n​​) with pi∈Xi\\mathbf p_i \\in X_ip​i​​∈X​i​​ for i =1, . . . , n is said to be a strategic equilibrium, or SE for short, if for all i = 1, 2, . . . , n, and for all p∈Xi∗,ui(p1,...,pi−1,pi,pi+1,...,pn)≥ui(p1,...,pi−1,p,pi+1,...,pn)\\mathbf p \\in X^*_i, u_i(\\mathbf p_1, ... , \\mathbf p_{i-1}, \\mathbf p_i, \\mathbf p_{i+1}, ... , \\mathbf p_n) \\geq u_i(\\mathbf p_1, ... , \\mathbf p_{i-1}, \\mathbf p, \\mathbf p_{i+1}, ... , p_n)p∈X​i​∗​​,u​i​​(p​1​​,...,p​i−1​​,p​i​​,p​i+1​​,...,p​n​​)≥u​i​​(p​1​​,...,p​i−1​​,p,p​i+1​​,...,p​n​​).(*) Any mixed strategy pi\\mathbf p_ip​i​​ that satisfies (*) for all p∈Xi∗\\mathbf p \\in X^*_ip∈X​i​∗​​ is a best response of player i to the mixed strategies of the other players. Theorem(Nash Equilibrium): Every finite n-person game in strategic form has at least one strategic equilibrium. Theorem: Let [A, B] be a bimatrix game. Let be a SE. Then, pTAq≥vI,pTBq≥vIIp^TAq \\geq v_I , p^TBq \\geq v_{II}p​T​​Aq≥v​I​​,p​T​​Bq≥v​II​​. Theorem: is a SE whenever the following two conditions are valid: (i) pi>0p_i>0p​i​​>0 implies Row i is a BR to q. (ii) qj>0q_j>0q​j​​>0 implies Column j is a BR to p. Labeling algorithm to check for SE’s: • Put the label BR to the best response rows to q • Put the label + at the ithi^{th}i​th​​ row where pip_ip​i​​ is positive • Put the label BR to the best response columns to p • Put the label + at the jthj^{th}j​th​​ column where qjq_jq​j​​ is positive • is a SE whenever a + label is accompanied by a BR label Proposition: p is a BR to q whenever p, α\\alphaα satisfy the following optimization problem: Max (pTAq−αp^TAq - \\alphap​T​​Aq−α) subject to the following constraints: Aq−α1m≤0,pT1m−1=0,0≤pAq - \\alpha \\mathbf 1_m \\leq 0, p^T \\mathbf 1_m - 1=0, 0 \\leq pAq−α1​m​​≤0,p​T​​1​m​​−1=0,0≤p Theorem: is a SE iff p,q, α, β satisfy the following optimization problem: Max(pT(A+B)q−α−β)Max (p^T(A+B)q - \\alpha - \\beta)Max(p​T​​(A+B)q−α−β) subject to the following constraints: Aq−α1m≤0,pT1m−1=0,pTB−β1nT≤0,qT1n−1=0,0≤q,0≤pAq - \\alpha \\mathbf 1_m \\leq 0, p^T \\mathbf 1_m - 1=0, p^TB - \\beta \\mathbf 1_n^T \\leq 0, q^T \\mathbf 1_n - 1=0, 0\\leq q, 0\\leq pAq−α1​m​​≤0,p​T​​1​m​​−1=0,p​T​​B−β1​n​T​​≤0,q​T​​1​n​​−1=0,0≤q,0≤p Tetraskelion Method to find all SE’s for 2 × 2 games: • For each mixed strategy (p, 1-p) of Player I, we use the method as in 0-zero sum games to find the best response columns. • Plot this in the unit square as a graph parameterized by p, 0 ≤ p ≤ 1, on x-axis. • For each mixed strategy (q, 1-q) of Player II, we use the method as in 0-zero sum games to find the best response rows. • Plot this in the unit square in the above as a graph parameterized by q, 0 ≤ q ≤ 1, on y-axis. • The SE’s are the intersections of the two graphs. Duopoly Cournot Duopoly: Two firms produce the same product. Cost function for Firm 1: C1(q1)=q1C_1(q_1)=q_1C​1​​(q​1​​)=q​1​​ Cost function for Firm 2: C2(q2)=q2C_2(q_2)=q_2C​2​​(q​2​​)=q​2​​ q1,q2q_1, q_2q​1​​,q​2​​ are the quantities produced. Price function: P(q)=25-q, where q is the total amount in the market. Monopoly: Profit = P(q)=(25−q)q−q=24q−q2P(q) = (25-q)q - q = 24q - q^2P(q)=(25−q)q−q=24q−q​2​​ Find q to maximize profit. Duopoly: Profit to Firm 1: P1(q1)=(25−q)q1−q1P_1(q_1)=(25-q)q_1-q_1P​1​​(q​1​​)=(25−q)q​1​​−q​1​​, where q=q1+q2q=q_1+q_2q=q​1​​+q​2​​. Profit to Firm 2: P2(q2)=(25−q)q2−q2P_2(q_2)=(25-q)q_2-q_2P​2​​(q​2​​)=(25−q)q​2​​−q​2​​. Firm 1 will find q1q_1q​1​​ to maximize profit. Firm 2 will find q2q_2q​2​​ to maximize profit. Stackelberg Leader and Follower: Suppose Firm 1 moves first. Firm 1 announces the quantity q1q_1q​1​​ (strategy) that it will produce. Knowing this, Firm 2 will choose its quantity q2q_2q​2​​ to maximize profit (as BR). Firm 1 is called the Stackelberg Leader and Firm 2 called the follower. Bertrand Duopoly: In economics, there is also a concept of Bertrand Equilibrium for duopoly. In this case, the firms will choose price as strategies. Potential Games Congestion Games: Any game where a collection of homogenous agents have to choose from a finite set of alternatives, and where the payoff of a player depends on the number of players choosing each alternative, is a congestion game. Potential Game: We consider a finite n-person game in startegic form. Let {1, ..., n} be the set of players. For Player I, i=1, ..., n, let XiX_iX​i​​ be its set of pure startegies and let ui=X1×...×Xn→Ru_i = X_1 \\times ... \\times X_n \\rightarrow Ru​i​​=X​1​​×...×X​n​​→R be the payoff function. A function P: X1×...×Xn→RX_1 \\times ... \\times X_n \\rightarrow RX​1​​×...×X​n​​→R, is called a potential function iff for any x1∈X1,...,xi−1∈Xi−1,x,z∈Xi,xi+1∈Xi+1,...,xn∈Xnx_1 \\in X_1,...,x_{i-1}\\in X_{i-1},x,z\\in X_i,x_{i+1}\\in X_{i+1},...,x_n\\in X_nx​1​​∈X​1​​,...,x​i−1​​∈X​i−1​​,x,z∈X​i​​,x​i+1​​∈X​i+1​​,...,x​n​​∈X​n​​, we have ui(x1,...,xi−1,x,xi+1,...,xn)−ui(x1,...,xi−1,z,xi+1,...,xn)=P(x1,...,xi−1,x,xi+1,...,xn)−P(x1,...,xi−1,z,xi+1,...,xn)u_i(x_1,...,x_{i-1},x,x_{i+1},...,x_n)-u_i(x_1,...,x_{i-1},z,x_{i+1},...,x_n)=P(x_1,...,x_{i-1},x,x_{i+1},...,x_n)-P(x_1,...,x_{i-1},z,x_{i+1},...,x_n)u​i​​(x​1​​,...,x​i−1​​,x,x​i+1​​,...,x​n​​)−u​i​​(x​1​​,...,x​i−1​​,z,x​i+1​​,...,x​n​​)=P(x​1​​,...,x​i−1​​,x,x​i+1​​,...,x​n​​)−P(x​1​​,...,x​i−1​​,z,x​i+1​​,...,x​n​​) A game with a potential function is called a potential game. Theorem: Any potential game admits a PSE. Correlated Equilibrium Solution Concept for games with communication but no binding agreement. In general, let [A, B] be a an m×n bimatrix game where A=(aija_{ij}a​ij​​), B=(bijb_{ij}b​ij​​). A probability distribution of the outcomes of this game is given by pij,pij≥0,∑i,jpij=1p_{ij}, p_{ij}\\geq0, \\sum\\limits_{i,j}p_{ij}=1p​ij​​,p​ij​​≥0,​i,j​∑​​p​ij​​=1. This means that the instruction of playing (Row i, Column j) to the players with probability pijp_{ij}p​ij​​. This probability distribution is called a Correlated Equilibrium (CE) if it is for the best interest for players to comply with the instruction. Inequalities characterizing CE: Prob(Column j for II∣Row i for I)=Prob(Column j for II,Row i for I)Prob(Row i for I)=pij∑kpikProb(Column\\ j\\ for\\ II | Row\\ i\\ for\\ I) = \\frac{Prob(Column\\ j\\ for\\ II, Row\\ i\\ for\\ I)}{Prob(Row\\ i\\ for\\ I)} =\\frac{p_{ij}}{\\sum\\limits_k p_{ik}}Prob(Column j for II∣Row i for I)=​Prob(Row i for I)​​Prob(Column j for II,Row i for I)​​=​​k​∑​​p​ik​​​​p​ij​​​​. For Player I to comply with the instruction to play Row i, the payoff must be better than deviating the instruction in playing Row r instead. This means ∑jpij∑kpikaij≥∑jpij∑kpikarj\\sum\\limits_j\\frac{p_{ij}}{\\sum\\limits_k p_{ik}}a_{ij} \\geq \\sum\\limits_j\\frac{p_{ij}}{\\sum\\limits_k p_{ik}}a_{rj}​j​∑​​​​k​∑​​p​ik​​​​p​ij​​​​a​ij​​≥​j​∑​​​​k​∑​​p​ik​​​​p​ij​​​​a​rj​​, for r =1,...,m. Equivalently, ∑jpij(aij−arj)≥0\\sum\\limits_j p_{ij} (a_{ij} - a_{rj})\\geq0​j​∑​​p​ij​​(a​ij​​−a​rj​​)≥0, for r=1,...,m. Definition of CE: A probability distribution pijp_{ij}p​ij​​ over the outcomes of the m×n bimatrix game [A, B] is called a Correlated Equilibrium whenever ∑jpij(aij−arj)≥0\\sum\\limits_j p_{ij} (a_{ij} - a_{rj})\\geq0​j​∑​​p​ij​​(a​ij​​−a​rj​​)≥0 for i, r=1,...m and ∑ipij(bij−bis)≥0\\sum\\limits_i p_{ij} (b_{ij} - b_{is})\\geq0​i​∑​​p​ij​​(b​ij​​−b​is​​)≥0 for j, s=1,...n. Theorem: Let p=(pip_ip​i​​), q=(qjq_jq​j​​) be mixed strategies for Player I and Player II respectively. Then, (piqjp_iq_jp​i​​q​j​​) is a CE if and only if is a SE. Corollary: Suppose (pijp_{ij}p​ij​​) is a CE such that pijp_{ij}p​ij​​=1 for i=k and j=r, and pijp_{ij}p​ij​​=0 otherwise. Then, is a PSE. Theorem: The convex combination of two CE’s is a CE. Theorem: Let (u1,u2),(u1′,u2′)(u_1, u_2), (u_1', u_2')(u​1​​,u​2​​),(u​1​′​​,u​2​′​​) be payoffs to two SE’s. Then, any convex combination of these two payoffs is the payoff of a certain CE. Theorem: The payoff of each player from a CE is better than their own safety level. Theorem: Let [A, -A] be a 2-person 0-sum game with value V. For any CE of [A, -A], the payoff vector is (V, -V). Theorem: The Principle of Elimination of Dominated Strategies is valid for computing CEs. Theorem: Let [A, -A] be a 2-person 0-sum game. Then, all CE of [A, -A] are derived from SE. "},"notes/博弈论2.html":{"url":"notes/博弈论2.html","title":"博弈论(下)","keywords":"","body":"博弈论(下) Evolutionarily Stable Strategies Payoff: fitness of individuals(the ability to pass on its genes to the next generation). Pure Strategy: certain behavior determined by the gene mixed strategy: (i) a random mechanism that trigger off each of the behaviors or (ii) the proportion of population with certain behavior gene. Consider a large population of ESS players playing pESSp^{ESS}p​ESS​​. A mutation occurs, producing a small numbers of players with mutant strategy pMp^Mp​M​​, pM≠pESSp^M \\neq p^{ESS}p​M​​≠p​ESS​​. The proportion of the population with this mutant strategy is ϵ\\epsilonϵ. Then for a player using pESSp^{ESS}p​ESS​​ the expected payoff is (1−ϵ)π(pESS,pESS)+ϵπ(pESS,pM)(1-\\epsilon)\\pi(p^{ESS},p^{ESS})+\\epsilon\\pi(p^{ESS},p^M)(1−ϵ)π(p​ESS​​,p​ESS​​)+ϵπ(p​ESS​​,p​M​​). A player using pMp^Mp​M​​ the payoff is πM=(1−ϵ)π(pM,pESS)+ϵπ(pM,pM)\\pi^M = (1-\\epsilon)\\pi(p^M,p^{ESS})+\\epsilon\\pi(p^M,p^M)π​M​​=(1−ϵ)π(p​M​​,p​ESS​​)+ϵπ(p​M​​,p​M​​). We want πMπESS\\pi^M π​M​​π​ESS​​, this is guaranteed if for pM≠pESSp^M \\neq p^{ESS}p​M​​≠p​ESS​​: (i): π(pESS,pESS)≥π(pM,pESS)\\pi(p^{ESS},p^{ESS})\\geq\\pi(p^M,p^{ESS})π(p​ESS​​,p​ESS​​)≥π(p​M​​,p​ESS​​) (ii): π(pESS,pESS)=π(pM,pESS)⇒π(pM,pM)π(pESS,pM)\\pi(p^{ESS},p^{ESS}) = \\pi(p^M,p^{ESS}) \\Rightarrow \\pi(p^M,p^M) π(p​ESS​​,p​ESS​​)=π(p​M​​,p​ESS​​)⇒π(p​M​​,p​M​​)π(p​ESS​​,p​M​​) This is called an Evolutionary Stable Strategy. Theorem: Suppose the payoff matrix is (aij,aji)(a_{ij}, a_{ji})(a​ij​​,a​ji​​). Suppose for the jthj^{th}j​th​​ column of (aij)(a_{ij})(a​ij​​) is such that its diagonal element, ajja_{jj}a​jj​​, is the largest (strictly) of the column. Then playing the jthj^{th}j​th​​ strategy is an ESS. Theorem: Let [A,ATA, A^TA,A​T​​] be a given bimatrix game, where A is an n × n matrix. Let p=(p1,...,pn)(p_1,...,p_n)(p​1​​,...,p​n​​) be a mixed strategy. Then p is an ESS iff (*) pjp_jp​j​​>0 implies jthj^{th}j​th​​ strategy is a BR row to p. (**) Let B be the matrix (bij)(b_{ij})(b​ij​​) such that bij=aijb_{ij}=a_{ij}b​ij​​=a​ij​​ if i, j are BR rows to p and bij=0b_{ij}=0b​ij​​=0 otherwise. Then, ZTBZZ^TBZZ​T​​BZ ZT=(z1,...zn)≠0Z^T=(z_1,...z_n) \\neq 0Z​T​​=(z​1​​,...z​n​​)≠0 satisfies (i) ziz_iz​i​​ = 0 if i is not a BR row to p and (ii) z1+...+znz_1+...+z_nz​1​​+...+z​n​​= 0. Theorem: Let [A,AT][A, A^T][A,A​T​​] be a symmetric bimatrix game. There exists a mixed strategy p such that is a SE. Theorem: Let A be the Scissor-Rock-Paper payoff matrix. Then [A,AT][A, A^T][A,A​T​​] does not have an ESS. The Evolution of Cooperation Prisoner's Dilemma: Cooperate Defect Cooperate R,R S,T Defect T,S P,P T: Temptation, R: Reward, P: Punishment, S: Sucker's payoff T > R > P > S ensures is a PSE. 2R S + T is necessary for cooperation. Repeated Prisoner's Dilemma: Playing Prisoner's Dilemma infinite number of times, $x at the nthn^{th}n​th​​ game is worth $ βn−1x\\beta^{n-1}xβ​n−1​​x, then it makes sense to compute total payoff. Finite Automata: Input: Some “history” of the game. Player II's action at the nthn^{th}n​th​​ stage. Output: Player I's action at the (n+1)th(n+1)^{th}(n+1)​th​​ stage. A finite automata can only remember a finite number of things. 1-memory automata: The player can only remember what happened in the previous move and make decision based on that. We have to input the first move. Then, the player will make a move based on the 4 possibilities: CC, CD, DC, DD, where the first letter denotes the move of the player concerned and the second letter denotes the move of the opponent. Then, a pure strategy with 1-memory is given by f: {CC, CD, DC, DD} → {C, D}. Examples: All D: Defect all the times. First move=D, f(CC)=D, f(CD)=D, f(DC)=D, f(DD)=D. PR: Permanent Retaliation. Cooperate, until, if ever, the opponent defects, then defect for ever. First move=C, f(CC)=C, f(CD)=D, f(DC)=D, f(DD)=D. Tit-for-Tat: Cooperate first, then do what your opponent's previous move. First move=C, f(CC)=C, f(CD)=D, f(DC)=C, f(DD)=D. AltDC: Start with D and then alternatively playing C and D. First move=D, f(CC)=D, f(CD)=D, f(DC)=C, f(DD)=C. Expressing Mixed Strategies: When both players are using a 1-memory automata, we can use the technique of transition matrix in expressing the strategies. Each row of the matrix is a probability vector giving the probability of transiting to one of the 4 possible states (CC, CD, DC, DD). Theorem 1: is a SE. Theorem 2: is a SE if β is large enough (Assume T > R > P > S, β≥(T−R)/(T−S)\\beta\\geq(T-R)/(T-S)β≥(T−R)/(T−S)). Theorem 3: When β is large enough, is a SE (Assume T > R > P > S , 2R T + P, β≥(T−R)/(R−P)\\beta\\geq(T-R)/(R-P)β≥(T−R)/(R−P)). A strategy is said to be • Nice: Start cooperating and never the first to defect. • Retaliatory: It should reliably punish defection by its opponent. • Forgiving: Having punished defection, it should be willing to try to cooperate again. • Clear: It's pattern of play should be consistent and easy to predict. Theorem 4: Let S be a nice strategy and that is a SE. Then β is sufficiently large. Theorem 5: Let S be a nice strategy and that is a SE. Then S should be provoked (when the opponent plays D, S must retaliate by playing D at some later move) by the defection of the opponent. Cooperative Games The cooperative theory is divided into two classes of problems depending on whether or not there is a mechanism for transfer of utility from one player to the other: Transferable utility (TU) or Nontransferable utility (NTU). Feasible Sets of Payoff Vectors: For any game it is important to know the set of feasible payoffs vectors for the players. For a noncooperative game, this set is called the noncooperative feasible set. The set of payoff vectors that the players can achieve if they cooperate is called the Cooperative Feasible Set. Definition: The NTU feasible set is the convex hull of the mn points, (aij,bij)(a_{ij}, b_{ij})(a​ij​​,b​ij​​) for i =1, ... , m and j = 1, ... , n. The distinguishing feature of the TU case is that the players may make side payments of utility as part of the agreement: by making a side payment, the payoff vector (aij,bij)(a_{ij}, b_{ij})(a​ij​​,b​ij​​) can be changed to (aij+s,bij−s)(a_{ij} +s, b_{ij} - s)(a​ij​​+s,b​ij​​−s). Definition: The TU feasible set is the convex hull of the set of vectors of the form (aij+s,bij−s)(a_{ij} + s, b_{ij} - s)(a​ij​​+s,b​ij​​−s) for i = 1, ... , m and j = 1, ... , n and for arbitrary real numbers s. Definition: A feasible payoff vector, (v1,v2v_1, v_2v​1​​,v​2​​), is said to be Pareto optimal if for any feasible payoff vector (v1′,v2′v_1', v_2'v​1​′​​,v​2​′​​) such that v1′≥v1v_1' \\geq v_1v​1​′​​≥v​1​​ and v2′≥v2v_2' \\geq v_2v​2​′​​≥v​2​​ implies (v1′,v2′)=(v1,v2)(v_1', v_2') = (v_1, v_2)(v​1​′​​,v​2​′​​)=(v​1​​,v​2​​). Cooperative Games with Transferable Utility The TU Solution: If the players come to an agreement, then rationality implies that they will agree to play to achieve the largest possible total payoff, call it σ, σ=max{(aij+bij):i,j}\\sigma,\\ \\sigma = max\\{(a_{ij} + b_{ij}): i, j\\}σ, σ=max{(a​ij​​+b​ij​​):i,j} as the payoff to be divided between them. That is they will jointly agree to use some row i0i_0i​0​​ and column j0j_0j​0​​ such that ai0j0+bi0j0=σa_{i_0j_0} + b_{i_0j_0} = \\sigmaa​i​0​​j​0​​​​+b​i​0​​j​0​​​​=σ. Such a joint choice (i0,j0)(i_0, j_0)(i​0​​,j​0​​) is called their cooperative strategy. Suppose now that the players have selected their threat strategies, say p for Player I and q for Player II. Then if agreement is not reached, Player I receives pTAqp^TAqp​T​​Aq and Player II receives pTBqp^TBqp​T​​Bq. The resulting payoff vector, D=D(p,q)=(pTAq,pTBq)=(D1,D2)D = D(p, q) = (p^TAq, p^TBq) = (D_1,D_2)D=D(p,q)=(p​T​​Aq,p​T​​Bq)=(D​1​​,D​2​​). This point is in the NTU feasible set and is called the disagreement point or threat point. They will split evenly the excess of σ over D1+D2D_1+D_2D​1​​+D​2​​. This is called the Egalitarian Principle. The resolution point is then ϕ=(ϕ1,ϕ2)=((σ+D1−D2)2,(σ−D1+D2)2)\\phi = (\\phi_1, \\phi_2) = (\\frac{(\\sigma+ D_1 - D_2)}{2}, \\frac{(\\sigma- D_1 + D_2)}{2})ϕ=(ϕ​1​​,ϕ​2​​)=(​2​​(σ+D​1​​−D​2​​)​​,​2​​(σ−D​1​​+D​2​​)​​). To select the threat optimally, Player I wants to maximize D1−D2D_1 - D_2D​1​​−D​2​​ and Player II wants to minimize it. This is in fact a zero-sum game with matrix A-B: D1−D2=pTAq−pTBq=pT(A−B)qD_1 - D_2 = p^TAq - p^TBq = p^T(A - B)qD​1​​−D​2​​=p​T​​Aq−p​T​​Bq=p​T​​(A−B)q. Let p* and q* denote optimal strategies of the 0-sum game A - B for Players I and II respectively, and let δ denote the value, δ=Val(A−B)=pT(A−B)q\\delta = Val(A - B) = p^T (A - B)qδ=Val(A−B)=p​T​​(A−B)q. When these strategies are used, the disagreement point or threat point becomes D=(D1,D2)=D(p∗,q∗)D = (D_1,D_2)=D(p^*, q^*)D=(D​1​​,D​2​​)=D(p​∗​​,q​∗​​). Since δ=pTAq−pTBq=D1−D2\\delta= p^T Aq - p^T Bq = D_1 - D_2δ=p​T​​Aq−p​T​​Bq=D​1​​−D​2​​, we have as the TU solution: ϕ=(ϕ1,ϕ2)=((σ+D1−D2)2,(σ−D1+D2)2)=((σ+δ)2,(σ−δ)2)\\phi = (\\phi_1, \\phi_2) = (\\frac{(\\sigma+ D1- D2)}{2}, \\frac{(\\sigma- D1 + D2)}{2})= (\\frac{(\\sigma+\\delta)}{2}, \\frac{(\\sigma- \\delta)}{2})ϕ=(ϕ​1​​,ϕ​2​​)=(​2​​(σ+D1−D2)​​,​2​​(σ−D1+D2)​​)=(​2​​(σ+δ)​​,​2​​(σ−δ)​​). Cooperative Games with Non-Transferable Utility Nash Bargaining Model: A bargaining problem is given by (S, u*, v*) such that (i) S is a compact (i.e. bounded and closed), convex set, in the plane. (ii) (u∗,v∗)∈S(u^*, v^*) \\in S(u​∗​​,v​∗​​)∈S, is called the threat point, disagreement point or status-quo point. Nash Solution to all bargaining problems: In the approach of Nash, “fair and reasonable” is defined by a few axioms: (1) Feasibility. (u#,v#)∈S(u^\\#, v^\\#) \\in S(u​#​​,v​#​​)∈S. (2) Pareto Optimality. (u#,v#)(u^\\#, v^\\#)(u​#​​,v​#​​) is Pareto optimal in S. (3) Symmetry. If S is symmetric about the 45° line u = v, and if u∗=v∗u^* = v^*u​∗​​=v​∗​​, then u#=v#u^\\# = v^\\#u​#​​=v​#​​. (4) Independence of irrelevant alternatives. If T is a closed convex subset of S, and if the threat point (u∗,v∗)∈T(u^*, v^*) \\in T(u​∗​​,v​∗​​)∈T and f(S,u∗,v∗)=(u#,v#)∈Tf(S, u^*, v^*) = (u^\\#, v^\\#) \\in Tf(S,u​∗​​,v​∗​​)=(u​#​​,v​#​​)∈T, then f(T,u∗,v∗)=(u#,v#)f(T, u^*, v^*) = (u^\\#, v^\\#)f(T,u​∗​​,v​∗​​)=(u​#​​,v​#​​). (5) Invariance under change of location and scale. If T={(u_,v_):u_=α1u+β1,v_=α2v+β2 for (u,v)∈S}T = \\{(u\\_,v\\_):u\\_=\\alpha_1u + \\beta_1, v\\_= \\alpha_2v + \\beta_2 \\ for \\ (u,v)\\in S\\}T={(u_,v_):u_=α​1​​u+β​1​​,v_=α​2​​v+β​2​​ for (u,v)∈S}, where α10,α20,β1,\\alpha_10, \\alpha_2 0, \\beta_1,α​1​​0,α​2​​0,β​1​​, and β2\\beta_2β​2​​ are given numbers, then f(T,α1u∗+β1,α2v∗+β2)=(α1u+β1,α2v+β2)f(T,\\alpha_1u^* + \\beta_1, \\alpha_2v^* + \\beta_2) = (\\alpha_1u+ \\beta_1, \\alpha_2v+ \\beta_2)f(T,α​1​​u​∗​​+β​1​​,α​2​​v​∗​​+β​2​​)=(α​1​​u+β​1​​,α​2​​v+β​2​​). Then it is shown that these axioms lead to a unique solution, denoted as f(S,u∗,v∗)f(S, u^*, v^*)f(S,u​∗​​,v​∗​​) for any (S,u∗,v∗)(S, u^*, v^*)(S,u​∗​​,v​∗​​). Theorem: There exists a unique function f satisfying the Nash axioms. Moreover, if there exists a point (u, v) ⊆ S such that uu∗u u^*uu​∗​​ and vv∗v v^*vv​∗​​, then f(S,u∗,v∗)f(S, u^*, v^*)f(S,u​∗​​,v​∗​​) is that point of S that maximizes (u - u*)(v - v*) among points of S such that u≥u∗u \\geq u^*u≥u​∗​​ and v≥v∗v \\geq v^*v≥v​∗​​. (u−u∗)(v−v∗)(u - u^*)(v - v^*)(u−u​∗​​)(v−v​∗​​) is called the Nash product. Kalai-Smorodinsky solution: For any bargaining problem (S,(d1,d2))(S, (d_1, d_2))(S,(d​1​​,d​2​​)), define the Utopia Points I1,I2I_1, I_2I​1​​,I​2​​ for each player: I1=max{u: for some v,(u,v)∈S,d1≤u,d2≤v},I2=max{v: for some u,(u,v)∈S,d1≤u,d2≤v}I_1 = max\\{u:\\ for\\ some\\ v, (u, v)\\in S, d_1\\leq u, d_2\\leq v\\},I_2 = max\\{v:\\ for\\ some\\ u, (u, v)\\in S, d_1\\leq u, d_2\\leq v\\}I​1​​=max{u: for some v,(u,v)∈S,d​1​​≤u,d​2​​≤v},I​2​​=max{v: for some u,(u,v)∈S,d​1​​≤u,d​2​​≤v}. The Kalai-Smorodinsky solution (u1,u2)(u_1, u_2)(u​1​​,u​2​​), a compromise between the utopia and the disagreement points, is on the Pareto optimal boundary such that (u1−d1)/(I1−u1)=(u2−d2)/(I2−u2)(u_1 - d_1)/(I_1 - u_1) = (u_2 - d_2) / (I_2 - u_2)(u​1​​−d​1​​)/(I​1​​−u​1​​)=(u​2​​−d​2​​)/(I​2​​−u​2​​). Zeuthen's Principle: Suppose that, at a given stage of the bargaining process, Player 1's last offer corresponded to the payoff vector v=(v1,v2)v=(v_1, v_2)v=(v​1​​,v​2​​) whereas Player 2's last offer corresponded to the payoff vector w=(w1,w2)w=(w_1, w_2)w=(w​1​​,w​2​​) such that v and w belong to the Pareto Optimal boundary of the cooperative feasible set, with v1>w1v_1>w_1v​1​​>w​1​​ but v2w2v_2v​2​​w​2​​. Then r1,r2r_1, r_2r​1​​,r​2​​ are the highest probability of a disagreement that Player 1 and Player 2, respectively, would face rather than accept the last offer of the other player, where r1=(v1−w1)/(v1−d1),r2=(w2−v2)/(w2−d2)r_1 = (v_1-w_1) / (v_1-d_1), r_2 = (w_2-v_2) / (w_2-d_2)r​1​​=(v​1​​−w​1​​)/(v​1​​−d​1​​),r​2​​=(w​2​​−v​2​​)/(w​2​​−d​2​​). We will call r1,r2r_1, r_2r​1​​,r​2​​ the two players' risk limits expressed as ratio of difference in payoffs. Zeuthen suggests that the next concession must always come from the player with a smaller risk limit (except that if the two players' risk limits are equal then both of them must make concessions to avoid a conflict). We call this suggestion Zeuthen's Principle. Theorem: If the two players follow Zeuthen's Principle then the next concession will always made by the player whose last offer is associated with a smaller Nash product (unless both are associated with equal Nash product, in which case both of them have to make concessions). Corollary: If the two players act according to Zeuthen's Principle then they will tend to reach the Nash solution as their agreement point. Games in Coalitional Form Many-Person TU Games: In many-person cooperative games, there are no restrictions on the agreements that may be reached among the players. In addition, we assume that all payoffs are measured in the same units and that there is a transferable utility which allows side payments to be made among the players. Coalition: Let n \\geq 2 denote the number of players in the game, numbered from 1 to n, and let N denote the set of players, N = {1, 2, . . . , n}. A coalition, S, is defined to be a subset of N, S⊆NS\\subseteq NS⊆N, and the set of all coalitions is denoted by 2N2^N2​N​​. We also speak of the empty set, Ø, as a coalition, the empty coalition. The set N is also a coalition, called the grand coalition. Definition: The coalitional form of an n-person game is given by the pair (N, v), where N = {1, 2, . . . , n} is the set of players and v is a realvalued function, called the characteristic function of the game, defined on the set, 2N2^N2​N​​, of all coalitions (subsets of N), and satisfying (i) v(Ø) = 0, and (ii) (superadditivity) if S and T are disjoint coalitions (S ∩ T = Ø), then v(S) + v(T) ≤ v(S ∪ T). Relation to Strategic Form: Transforming a game from strategic form to coalitional form entails specifying the value, v(S), for each coalition S∈2NS \\in 2^NS∈2​N​​. We define v(S) for each S∈2NS \\in 2^NS∈2​N​​ as the value of the 2-person zero-sum game obtained when the coalition S acts as one player and the complementary coalition, SC=N−SS^C = N-SS​C​​=N−S, acts as the other player, and where the payoff to S is ∑i∈Sui(x1,...,xn)\\sum\\limits_{i\\in S} u_i(x_1, ... , x_n)​i∈S​∑​​u​i​​(x​1​​,...,x​n​​), the total of the payoffs to the players in S. Theorem: Given any game in coalition form (N, v), one can find a strategic form game whose reduction to coalition form has v as its characteristic function. Definition: A payoff vector, x=(x1,x2,...,xn)x = (x_1, x_2, . . . , x_n)x=(x​1​​,x​2​​,...,x​n​​), is said to be group rational or efficient if x1+...+xn=v(N)x_1+...+x_n = v(N)x​1​​+...+x​n​​=v(N). Definition: A payoff vector, x, is said to be individually rational if xi≥v({i})x_i \\geq v(\\{i\\})x​i​​≥v({i}) for all i = 1, ... , n. Definition: An imputation is a payoff vector that is group rational and individually rational. The set of imputations may be written {x=(x1,...,xn):∑i∈Nxi=v(N)\\{ x = (x_1, . . . , x_n) : \\sum\\limits_{i\\in N} x_i = v(N){x=(x​1​​,...,x​n​​):​i∈N​∑​​x​i​​=v(N), and xi≥v({i})x_i \\geq v(\\{i\\})x​i​​≥v({i}) for all i \\in N}\\}}. Theorem: The set of all imputations is a nonempty convex set. Definition: An imputation x is said to be unstable through a coalition S if v(S)>∑i∈Sxiv(S) > \\sum\\limits_{i\\in S} x_iv(S)>​i∈S​∑​​x​i​​. We say x is unstable if there is a coalition S such that x is unstable through S, and we say x is stable otherwise. Definition: The set, C, of stable imputations is called the core, C = {x=(x1,...,xn):∑i∈Nxi=v(N),∑i∈Sxi≥v(S)\\{ x = (x_1,. . ., x_n):\\sum\\limits_{i\\in N} x_i = v(N), \\sum\\limits_{i\\in S} x_i \\geq v(S){x=(x​1​​,...,x​n​​):​i∈N​∑​​x​i​​=v(N),​i∈S​∑​​x​i​​≥v(S), for all S⊂N}S\\subset N\\}S⊂N}. Definition: A game in coalitional form is said to be constant-sum, if v(S) + v(SCS^CS​C​​) = v(N) for all coalitions S ⊆ 2N2^N2​N​​. It is said to be zero-sum if, in addition, v(N) = 0. Definition: A game in coalitional form is said to be inessential if ∑iv({i})=v(N)\\sum\\limits_i v(\\{i\\}) = v(N)​i​∑​​v({i})=v(N), and essential if ∑iv({i})≠v(N)\\sum\\limits_i v(\\{i\\}) \\neq v(N)​i​∑​​v({i})≠v(N). Theorem: The core of an essential n-person constant-sum game is empty. Definition: A game in coalition form (N, v) is convex iff for any coalitions S,T⊆N,v(S)+v(T)≤v(S∪T)+v(S∩T)S, T \\subseteq N, v(S) + v(T) \\leq v(S\\cup T) + v(S\\cap T)S,T⊆N,v(S)+v(T)≤v(S∪T)+v(S∩T). Theorem: Let (N, v) be a convex game. Denote N={1,...,n}. Define x1=v(1)x_1 = v(1)x​1​​=v(1) x2=v(1,2)−v(1)x_2 = v(1,2) - v(1)x​2​​=v(1,2)−v(1) ⋮\\vdots⋮ ⋮\\vdots⋮ xn=v(1,2,...,n)−v(1,2,...,n−1)x_n = v(1,2,...,n) - v(1,2,...,n-1)x​n​​=v(1,2,...,n)−v(1,2,...,n−1) Then, x=(x1,...,xn)x = (x_1,...,x_n)x=(x​1​​,...,x​n​​) is an imputation and is in the core of (N, v). Consequently, the core of a convex game is nonempty. Theorem: A bankruptcy game is a convex game. The Shapley Value The Shapley Value is to assign to each game in coalitional form a UNIQUE vector of payoffs, called the Shapley Value. The ithi^{th}i​th​​ entry of the value vector may be considered as a measure of the value or power of the ithi^{th}i​th​​ player in the game. A value function, φ, is function that assigns to each possible set function of an n-person game, v, an n tuple, ϕ(v)=(ϕ1(v),ϕ2(v),...,ϕn(v))\\phi(v) = (\\phi_1(v), \\phi_2(v), ... , \\phi_n(v))ϕ(v)=(ϕ​1​​(v),ϕ​2​​(v),...,ϕ​n​​(v)) of real numbers. ϕi(v)\\phi_i(v)ϕ​i​​(v) represents the worth or value of player i in the game with characteristic function v. The Shapley Axioms for φ(v): Efficiency. ∑iϕi(v)=v(N)\\sum\\limits_i \\phi_i(v) = v(N)​i​∑​​ϕ​i​​(v)=v(N). Symmetry. If i and j are such that v(S∪{i})=v(S∪{j})v(S\\cup\\{i\\}) = v(S\\cup\\{j\\})v(S∪{i})=v(S∪{j}) for every coalition S not containing i and j, then ϕi(v)=ϕj(v)\\phi_i (v) = \\phi_j (v)ϕ​i​​(v)=ϕ​j​​(v). Dummy Axiom. If i is such that v(S)=v(S∪{i})v(S) = v(S\\cup\\{i\\})v(S)=v(S∪{i}) for every coalition S not containing i, then ϕi(v)=0\\phi_i (v) = 0ϕ​i​​(v)=0. Additivity. If u and v are characteristic functions, then φ(u + v) = φ(u) + φ(v). Theorem: There exists a unique function φ on the set of all set functions satisfying the Shapley axioms. For a given nonempty set S⊆NS\\subseteq NS⊆N, let wSw_Sw​S​​ be defined for all T⊆NT\\subseteq NT⊆N such that wS(T)w_S (T)w​S​​(T) = 1 if S⊆TS\\subseteq TS⊆T, wS(T)w_S (T)w​S​​(T) = 0 otherwise. Claim: Any v may be written as v=∑S⊆NcSwSv = \\sum\\limits_{S\\subseteq N} c_Sw_Sv=​S⊆N​∑​​c​S​​w​S​​, then ϕi(v)=∑S⊆N,i∈ScS∣S∣\\phi_i(v)= \\sum\\limits_{S\\subseteq N, i\\in S}\\frac{c_S}{|S|}ϕ​i​​(v)=​S⊆N,i∈S​∑​​​∣S∣​​c​S​​​​. Theorem(Shapley Value): There exists a unique value function satisfying the Shapley axioms. Indeed, the Shapley value is given by an explicit formula: ϕi(v)=∑S⊆N,i∈S[(∣S∣−1)!(n−∣S∣)!][v(S)−v(S−{i})]/n!\\phi_i(v) = \\sum\\limits_{S\\subseteq N,i\\in S}[(|S|-1)!(n-|S|)!] [v(S)-v(S -\\{i\\})]/n!ϕ​i​​(v)=​S⊆N,i∈S​∑​​[(∣S∣−1)!(n−∣S∣)!][v(S)−v(S−{i})]/n!, for i = 1, ... , n. Theorem: The Shapley value of a convex game lies in the core. Definition: A game (N, v) is simple if for every coalition S⊂NS\\subset NS⊂N, either v(S) = 0 or v(S) = 1. In a simple game, a coalition S is said to be a winning coalition if v(S) = 1 and a losing coalition if v(S) = 0.ϕi(v)=∑S winning,S−{i} losing(∣S∣−1)!(n−∣S∣)!/n!\\phi_i(v) = \\sum\\limits_{S\\ winning ,S-\\{i\\}\\ losing} (|S| - 1)!(n - |S|)!/n!ϕ​i​​(v)=​S winning,S−{i} losing​∑​​(∣S∣−1)!(n−∣S∣)!/n!. The Nucleolus Definition of Excess: As a measure of the inequity of an imputation x for a coalition S is defined as the excess, e(x,S)=v(S)−∑j∈Sxje(x, S) = v(S) - \\sum\\limits_{j\\in S}x_je(x,S)=v(S)−​j∈S​∑​​x​j​​. The concept of the nucleolus: On the principle that the one who yells loudest gets served first, we look first at those coalitions S whose excess, for a fixed allocation x, is the largest. Then we adjust x, if possible, to make this largest excess smaller. Note that as x1+...+xn=v(N)x_1+...+x_n = v(N)x​1​​+...+x​n​​=v(N) is fixed, making one coalition happy will be at the expenses of other coalitions. When the largest excess has been made as small as possible, we concentrate on the next largest excess, and adjust x to make it as small as possible, and so on. When we cannot improve further, the imputation we get is called the nucleolus. Define O(x) as the vector of excesses arranged in decreasing (non-increasing) order for {e(x,S):S⊆N,S≠N,S≠ϕ}\\{e(x, S): S\\subseteq N, S\\neq N, S\\neq \\phi\\}{e(x,S):S⊆N,S≠N,S≠ϕ}. We say a vector y=(y1,...,yk)y = (y_1, . . . , y_k)y=(y​1​​,...,y​k​​) is lexicographically less than a vector z=(z1,...,zk)z = (z_1, . . . , z_k)z=(z​1​​,...,z​k​​), and write yLzy y​L​​z, if y1z1y_1 y​1​​z​1​​, or y1=z1y_1 = z_1y​1​​=z​1​​ and y2z2y_2 y​2​​z​2​​, or y1=z1,y2=z2y_1 = z_1, y_2 = z_2y​1​​=z​1​​,y​2​​=z​2​​ and y3z3y_3 y​3​​z​3​​, ... , or y1=z1,...,yk−1=zk−1y_1 = z_1, . . ., y_{k-1} = z_{k-1}y​1​​=z​1​​,...,y​k−1​​=z​k−1​​ and ykzky_k y​k​​z​k​​. The nucleolus is an imputation that minimizes O(x) in the lexicographic ordering. Definition: Let (N, v) be a game in coalition form. Let X={x:∑jxj=v(N),xi≥v{i},i=1,...,n}X = \\{x :\\sum\\limits_j x_j = v(N), x_i\\geq v\\{i\\}, i=1,...,n\\}X={x:​j​∑​​x​j​​=v(N),x​i​​≥v{i},i=1,...,n} be the set of imputations. We say that a vector ν ⊆ X is a nucleolus if for every x ⊆ X we have O(v)≤LO(x)O(v) \\leq_L O(x)O(v)≤​L​​O(x). Theorem : The nucleolus of a game in coalitional form exists and is unique. The nucleolus is group rational, individually rational, and satisfies the symmetry axiom and the dummy axiom. If the core is not empty, the nucleolus is in the core. Gately Point When Player i threatens to quit, the credibility of his threat is measured by the Propensity of Player i to disrupt the grand coalition defined as follows: di=−e(x,N\\{i})−e(x,{i})=v(N)−v(N\\{i})−v({i})xi−v({i})−1,did_i = \\frac{-e(x,N \\backslash \\{i\\})}{-e(x,\\{i\\})}=\\frac{v(N) - v(N\\backslash \\{i\\})-v(\\{i\\})}{x_i -v(\\{i\\})} - 1, d_id​i​​=​−e(x,{i})​​−e(x,N\\{i})​​=​x​i​​−v({i})​​v(N)−v(N\\{i})−v({i})​​−1,d​i​​ is the ratio of the loss of the rest of the coalition against the loss of Player i. Definition: The Gately point is the imputation such that it minimizes max{di:1≤i≤n}max\\{d_i:1\\leq i \\leq n\\}max{d​i​​:1≤i≤n} among all imputations. Therefore, the Gately point is the imputation such that the maximum of −e(x,N\\{1})−e(x,{1}),...,−e(x,N\\{n})−e(x,{n})\\frac{-e(x,N \\backslash \\{1\\})}{-e(x,\\{1\\})}, ... ,\\frac{-e(x,N \\backslash \\{n\\})}{-e(x,\\{n\\})}​−e(x,{1})​​−e(x,N\\{1})​​,...,​−e(x,{n})​​−e(x,N\\{n})​​ is smallest. Theorem: At the Gately point we have −e(x,N\\{1})−e(x,{1})=...=−e(x,N\\{n})−e(x,{n})\\frac{-e(x,N \\backslash \\{1\\})}{-e(x,\\{1\\})}= ... = \\frac{-e(x,N \\backslash \\{n\\})}{-e(x,\\{n\\})}​−e(x,{1})​​−e(x,N\\{1})​​=...=​−e(x,{n})​​−e(x,N\\{n})​​. Ordinal Matching Games Characteristics of an Ordinal Matching Game: • Absence of numerical payoffs. • Players have preferences. • We cannot perform arithmetic operations on the payoffs. • We will deal with rankings such as 1st choice, 2nd choice etc. • The core concept can be applied. The core is the set of all feasible outcomes that no coalitions can improve upon. The Marriage Game: • Players are of two types, Boys and Girls. • Any boy/girl can marry if they wish. • Polygamy is frowned upon. • The possible outcomes are matchings, consisting of the different sets of marriages that the players might enter into. • All “side payments” are not allowed. • The essential data for a marriage game is a double list of preference orderings. • Core Principle: A matching will not be stable if some coalition is not satisfied. Definition: A matching μ is said to be stable if no boy and girl not matched in μ prefer each other to their μ -mates. The deferred acceptance algorithm: A: b a d c B: c d a b C: c d b a D: d a b c a: C B A D b: B C A D c: A D C B d: A C D B Boy Propose: 1st Day 2nd Day 3rd Day a: B b: A A A c: B,C C C d: D D,B D rej: B B Ans: Girl Propose: 1st Day 2nd Day A: c,d d B: b b C: a a D: c rej: c Ans: Theorem: The matchings obtained by the deferred acceptance algorithm are stable. Definition: Call a boy (girl) feasible for a girl (boy) if there exists a stable matching in which they are matched. Theorem: In a girl-propose algorithm, no girl is ever rejected by a boy feasible for her. Similarly, in a boy-propose algorithm, no boy is ever rejected by a girl feasible for him. Corollary: In the girl-propose algorithm, the girls are matched to optimal feasible boys. Therefore, girl-propose algorithm is girl-optimal. In the boy-propose algorithm, the boys are matched to optimal feasible girls. Therefore, boy-propose algorithm is boy-optimal. Set of Stable Matchings: Let B be the set of boys and G be the set of girls. We suppose that each boy has a rank list of girls and each girl has a rank list of boys. Let S be the set of all stable matchings according to the rank lists. For a matching μ, and a given boy b, we denote the girl matched to b to be μ(b). We will define a partial order in the set of matchings. (A partial order is a relation that is reflexive, antisymmetric and transitive.) For any two matchings μ, λ, we write μ≥Mλ\\mu \\geq_M \\lambdaμ≥​M​​λ whenever b prefers μ(b) over λ(b). Now, let μ, λ be two stable matchings. For a given boy b, denote γ(b) be the preferred girl between μ(b) and λ(b). Claim: If b ≠ m, then γ(b) ≠ γ(m). Claim: γ is a stable matching. Theorem: γ≥Mμ,γ≥Mλ\\gamma \\geq_M \\mu, \\gamma \\geq_M \\lambdaγ≥​M​​μ,γ≥​M​​λ. This means that (S,≥M)(S, \\geq_M)(S,≥​M​​) is a lattice. Theorem: The maximal element in (S,≥M)(S, \\geq_M)(S,≥​M​​) is boy-propose matching. The minimal element in (S,≥M)(S, \\geq_M)(S,≥​M​​) is girl-propose matching. One-sided Matching: One type of agents, each has a preference over some indivisible, heterogeneous goods. Let N={A, B, C, ...} be the set of traders who are homeowners. Suppose A owns house a, B owns house b, C owns house c, etc. The traders can transfer ownership amongst themselves in any way they please, except that at the end no one is allowed to own more than one house. Each trader has strict preference over the houses: A: c e f a b d B: b a c e f d C: e f c a d b D: c a b e d f E: d c b f e a F: b d e f a c Top Trading Cycle algorithm: Step1: Make a directed graph, with each trader represented by a vertex from which an edge points to the owner of his/her topranked house. Step 2: Find top trading cycles. Step 3: Let the traders in the top trading cycles trade amongst themselves. Delete them from the preference table. Repeat Step 1 if any traders left. Step 4: When every trader has been assigned to a top trading cycle, execute all the indicated trades. Then, we get the following allocation. Theorem: The TTC algorithm produces a stable allocation in the sense that no coalition of traders trading only with each other, could have achieved any allocation in which all members would be better off. "},"notes/计算机系统结构.html":{"url":"notes/计算机系统结构.html","title":"计算机系统结构","keywords":"","body":"计算机系统结构 计算机系统结构的基础知识 计算机系统结构的概念 第一台通用电子计算机诞生于1946年 计算机技术的飞速发展受益于两个方面：制造技术的发展、系统结构的创新 经历了四个发展过程 引起性能增长速度减缓的主要原因：大功耗问题、可进一步有效开发的指令级并行已经很少、存储器访问速度提高缓慢 系统结构的重大转折：从单纯依靠指令级并行转向线程级并行和数据级并行 计算机系统的层次结构 计算机系统 = 硬件 + 软件 计算机语言从低级向高级发展 从计算机语言的角度，把计算机系统按功能划分成多级层次结构 每一层以一种语言为特征 物理机：用硬件实现的机器 虚拟机：用软件实现的机器 各机器级的实现主要靠翻译或解释，或两者的结合，解释执行比编译后执行所花的时间多，但占用的存储空间少 计算机系统结构的定义 传统机器程序员所看到的计算机属性，即概念性结构与功能特性 按照计算机系统的多级层次结构，不同级程序员所看到的计算机具有不同的属性 透明性：本来存在的事物或属性，但从某种角度看又好像不存在的概念 功能特性：数据表示、寻址技术、寄存器定义、指令系统、存储系统、中断系统、输入输出系统、机器工作状态 计算机系统结构的实质 确定计算机系统中软硬件的界面，界面之上是软件实现的功能，界面之下是硬件和固件实现的功能 计算机系统结构是计算机系统结构抽象层的设计，使我们能够利用现有的制造技术有效地实现信息处理应用 计算机系统结构的6个伟大思想 层次结构 摩尔定律 局部性原理/存储器层次结构 并行 性能测量&提升 可信性 via 冗余 计算机系统结构的分类 Flynn分类法：按照指令流和数据流的多倍性进行分类 指令流：计算机执行的指令序列 数据流：由指令流调用的数据序列 多倍性：在系统最受限的部件上，同时处于同一执行阶段的指令或数据的最大数目 把计算机系统的结构分为4类 单指令流单数据流SISD 单指令流多数据流SIMD 多指令流单数据流MISD 多指令流多数据流MIMD 计算机系统的设计 计算机系统的定量原理 加快经常性事件速度 对经常发生的情况采用优化方法的原则进行选择，以得到更多的总体上的改进 优化是指分配更多的资源、达到更高的性能或者分配更多的电能等 阿姆达尔定律：系统中某一部件由于采用更快的执行方式，整个系统性能的提高与这种执行方式的使用频率或占总执行时间的比例有关 可改进部分的比例：Fe = 可改进部分的执行时间/改进前整个任务的执行时间 改进部分的加速比：Se = 改进前改进部分的执行时间/改进后改进部分的执行时间 改进后整个任务的执行时间为：Tn=T0⋅(1−Fe+FeSe)T_n=T_0\\cdot(1-Fe+\\frac{Fe}{Se})T​n​​=T​0​​⋅(1−Fe+​Se​​Fe​​) 改进后整个系统的加速比达到：Sn=T0Tn=11−Fe+FeSeS_n=\\frac{T_0}{T_n}=\\frac{1}{1-Fe+\\frac{Fe}{Se}}S​n​​=​T​n​​​​T​0​​​​=​1−Fe+​Se​​Fe​​​​1​​ 一种性能改进的递减规则：如果仅仅对计算任务中的一部分做性能改进，则改进越多，所得到的总体性能的提升就越有限，加速比不超过11−Fe\\frac{1}{1-Fe}​1−Fe​​1​​ CPU性能公式 执行一个程序所需的CPU时间=执行程序所需的时钟周期数×时钟周期时间 每条指令执行的平均时钟周期数CPI=执行程序所需的时钟周期数/IC（IC：所执行的指令条数） 程序执行的CPU时间可以写成CPU时间=IC×CPI×时钟周期时间 CPU的性能取决于三个参数 时钟周期时间：取决于硬件实现技术和计算机组成 CPI：取决于计算机组成和指令系统的结构 IC：取决于指令系统的结构和编译技术 对CPU性能公式进行进一步细化 CPIiCPI_iCPI​i​​：第i种指令的处理时间 ICiIC_iIC​i​​：在程序中第i种指令出现的次数 CPU平均时钟周期数=∑i=1n(CPIi×ICi)\\sum^n_{i=1}(CPI_i \\times IC_i)∑​i=1​n​​(CPI​i​​×IC​i​​) CPI=时钟周期数/IC=∑i=1nCPIi×ICiIC=∑i=1n(CPIi×ICiIC)\\frac{\\sum\\limits^n_{i=1}CPI_i\\times IC_i}{IC}=\\sum\\limits^n_{i=1}(CPI_i\\times\\frac{IC_i}{IC})​IC​​​i=1​∑​n​​CPI​i​​×IC​i​​​​=​i=1​∑​n​​(CPI​i​​×​IC​​IC​i​​​​)，其中ICiIC\\frac{IC_i}{IC}​IC​​IC​i​​​​反映了第i种指令在程序中所占的比例 程序的局部性原理：程序执行时所访问的存储器地址分布不是随机的，而是相对地簇聚 常用的一个经验准则：程序执行时间的90%都是在执行程序中10%的代码 时间局部性：程序即将用到的信息很可能就是目前正在使用的信息 空间局部性：程序即将用到的信息很可能与目前正在使用的信息在空间上相邻或者临近 计算机系统设计者的主要任务 计算机系统设计者的任务包括：指令系统的设计、数据表示的设计、功能的组织、逻辑设计以及其物理实现等 设计一个计算机系统大致要完成3个方面的工作： 确定用户对计算机系统的功能、价格和性能的要求 软硬件功能分配 设计出生命周期长的系统结构 计算机系统设计的主要方法 “由上往下”设计 从层次结构的最上面一级开始，逐层往下设计各层的机器 适用于专用机的设计，而不适合通用机的设计 “由下往上”设计 从层次结构的最下面一级开始，逐层往上设计各层的机器 采用这种方法时，软件技术完全处于被动状态，这会造成软件和硬件的脱节，使整个系统的效率降低 “从中间开始”设计 综合考虑软硬件的分工，从中间开始设计 计算机系统的性能评测 执行时间和吞吐率 执行时间 计算机完成某一任务所花费的全部时间，包括磁盘访问、存储器访问、输入/输出、操作系统开销等 CPU时间：CPU执行所给定的程序所花费的时间，不包含I/O等待时间以及运行其它程序的时间 用户CPU时间：用户程序所耗费的CPU时间 系统CPU时间：用户程序运行期间操作系统耗费的CPU时间 吞吐率：单位时间里能够完成的任务数量 基准测试程序 性能比较 总执行时间：机器执行所有测试程序的总时间 平均执行时间：各测试程序执行时间的算术平均值 加权执行时间：各测试程序执行时间的加权平均值 调和平均值 几何平均值 加权几何平均值 计算机系统结构的发展 经典冯诺依曼结构及其改进 存储程序原理的基本点：指令驱动 程序预先存放在计算机存储器中，机器一旦启动，就能按照程序指定的逻辑顺序执行这些程序，自动完成由程序所描述的处理工作 经典冯诺依曼结构的主要特点 计算机以运算器为中心 在存储器中，指令和数据同等对待 存储器是按地址访问、按顺序线性编址的一堆结构，每个单元的位数是固定的 指令的执行是顺序的 指令由操作码和地址码组成 指令和数据均以二进制编码表示，采用二进制运算 对系统结构进行的改进 输入输出方式的改进：程序控制、DMA、I/O处理机 采用并行处理技术 存储器组织结构的发展 指令系统的发展 软件对系统结构的影响 软件的可移植性：一个软件可以不经修改或者只需少量修改就可以由一台机器移植到另一台机器上正确地运行，差别只是执行时间的不同，我们称这两台机器是软件兼容的 实现可移植性的常用方法 统一高级语言 实现软件移植的一种理想方法 较难实现 系列机 由同一厂家生产的具有相同的系统结构，但具有不同组成和实现的一系列不同型号的机器 软件兼容 向上(下)兼容：按某档机器编制的程序，不加修改就能运行于比它高（低）档的机器 向前(后)兼容：按某个时期投入市场的某种型号机器编制的程序，不加修改地就能运行于在它之前（后）投入市场的机器 模拟与仿真 使软件能在具有不同系统结构的机器之间相互移植 模拟：用软件的方法在一台现有的机器(称为宿主机)上实现另一台机器(称为虚拟机)的指令集 仿真：用一台现有机器(宿主机)上的微程序去解释实现另一台机器(目标机)的指令集 器件发展对系统结构的影响 推动计算机系统结构不断发展的最活跃的因素 摩尔定律：集成电路芯片上所集成的晶体管数目每隔18月就翻一番 计算机的分代主要以器件作为划分标准 应用对系统结构的影响 不同的应用对计算机系统结构的设计提出了不同的要求 应用需求是促使计算机系统结构发展的最根本的动力 一些特殊领域：需要高性能的系统结构 计算机系统结构中并行性的发展 并行性的概念 并行性：计算机系统在同一时刻或者同一时间间隔内进行多种运算或操作 同时性：两个或两个以上的事件在同一时刻发生 并发性：两个或两个以上的事件在同一时间间隔内发生 从执行程序的角度来看，并行性等级从低到高可分为： 指令内部并行：单条指令中各微操作之间的并行 指令级并行：并行执行两条或两条以上的指令 线程级并行：并行执行两个或两个以上的线程 任务级或过程级并行：并行执行两个或两个以上的过程或任务（程序段） 作业或程序级并行：并行执行两个或两个以上的作业或程序 提高并行性的技术途径 时间重叠：引入时间因素，让多个处理过程在时间上相互错开，轮流重叠地使用同一套硬件设备的各个部分，以加快硬件周转而赢得速度 资源重复：引入空间因素，以数量取胜，通过重复设置硬件资源，大幅度地提高计算机系统的性能 资源共享：这是一种软件方法，它使多个任务按一定时间顺序轮流使用同一套硬件设备 单机系统中并行性的发展 在发展高性能单处理机过程中，起主导作用的是时间重叠原理 实现时间重叠的基础：部件功能专用化 在单处理机中，资源重复原理的运用也已经十分普遍 多体交叉存储器 多操作部件 阵列处理机（并行处理机） 在单处理机中，资源共享的概念实质上是用单处理机模拟多处理机的功能，形成所谓虚拟机的概念 多机系统中并行性的发展 多机系统遵循时间重叠、资源重复、资源共享原理，发展为3种不同的多处理机：同构型多处理机、异构型多处理机、分布式系统 耦合度：反映多机系统中各机器之间物理连接的紧密程度和交互作用能力的强弱 功能专用化（实现时间重叠）：专用外围处理机、专用处理机、异构型多处理机系统 机间互连：容错系统、可重构系统、同构型多处理机系统 并行机的发展变化 并行机的萌芽阶段（1964年～1975年） 向量机的发展和鼎盛阶段（1976年～1990年） MPP出现和蓬勃发展阶段（1990年～1995年） 各种体系结构并存阶段（1995年～2000年） 机群蓬勃发展阶段（2000年以后） 指令集体系结构 指令的组成 操作码 操作种类：加、减、乘、除、数据传送、移位、移、输入输出、程序控制、处理机控制等 操作数描述 数据的类型：定点数、浮点数、复数、字符、字符串、逻辑数、向量 进位制：2进制、10进制、16进制 数据字长：字、半字、双字、字节 地址码 地址：地址码、立即数、寄存器、变址寄存器 地址的附加信息：偏移量、块长度、跳距 寻址方式：直接寻址、间接寻址、立即数寻址、变址寻址、相对寻址、寄存器寻址 ISA：指令集、指令格式 硬件和软件的接口 设计规范 不是微架构 不仅仅是指令集 指令 信息处理的原子单位 改变机器状态 Architecture ISA对软件可见 地址空间，寻址技术 操作码，数据类型，寻址方式 权限，优先级 多处理器的支持 多程序设计支持 μArchitecture：根据指令，改变处理器状态 对软件不可见 Cache 分支预测 指令周期 流水线 数据表示 数据表示与数据类型 数据表示：计算机硬件能够直接识别，可以被指令系统直接调用的那些数据类型 数据类型：由软件进行处理和实现的各种数据类型 确定数据表示的原则 一是缩短程序的运行时间 二是减少CPU与主存储器之间的通信量 三是这种数据表示的通用性和利用率 数据表示在不断发展 用软件和硬件结合的方法实现新的数据表示 用字节编址支持字符串数据表示 用变址寻址支持向量数据表示 自定义数据表示 一般处理机中的数据表示方法 数据存储单元(寄存器、主存储器、外存储器)只存放纯数据，数据的属性通过指令中的操作码来解释 在高级语言和应用软件中，数据的属性由数据自己定义，在高级语言与机器语言中间的语义差距，要靠编译器等填补 带标志符的数据表示法 指令系统结构的分类 根据CPU中用来存储操作数的存储单元的类型，将指令系统的结构分为三种类型： 堆栈结构 累加器结构 通用寄存器结构 根据操作数的来源不同，又可进一步分为： 存储器-存储器结构(MM结构) 寄存器-存储器结构(RM结构) 寄存器-寄存器结构(RR结构) 现代指令系统结构的主流 在灵活性和提高性能方面有明显的优势 根据ALU指令的操作数的两个特征对通用寄存器型结构进一步细分 对于不同类型的结构，操作数的位置、个数以及操作数的给出方式也会不同 显式给出：用指令字中的操作数字段给出 隐式给出：使用事先约定好的单元 寻址技术 寻找操作数及其地址的技术称为寻址技术 编址方式 寻址方式 定位方式 编址方式 对各种存储设备进行编码的方法： 编址单位 常用的编址单位：字编址、字节编址、位编址、块编址等 编址单位与访问字长 一般：字节编址，字访问 部分：位编址，字访问 辅助存储器：块编址，位访问 字节编址字访问的优点：有利于符号处理 字节编址字访问的问题： 地址信息浪费：32位机器浪费最低2位地址 存储空间浪费：信息宽度不超过主存宽度的信息必须存放在一个存储字内，不能跨边界 读写逻辑复杂 大端与小端问题 零地址空间个数 三个零地址空间：通用寄存器、主存储器、输入输出设备独立编址 两个零地址空间：主存储器与输入输出设备统一编址 一个零地址空间：最低端是通用寄存器，最高端是输入输出设备，中间为主存储器 隐含编址方式：堆栈、Cache等 并行存储器的编址 高位交叉编址：主要用来扩大存储器容量 低位交叉编址：主要是提高存储器速度 输入输出设备的编址 一台设备一个地址：通过指令来区分地址 一台设备两个地址：数据寄存器、状态或控制寄存器 多个编址寄存器共用一个地址 一台设备多个地址 寻址方式 立即数寻址方式和偏移寻址方式的使用频度最高 采用多种寻址方式可以显著地减少程序的指令条数，但可能增加计算机的实现复杂度以及指令的CPI 两种表示寻址方式的方法 将寻址方式编码于操作码中，由操作码描述相应操作的寻址方式，适合：处理及采用load-store结构，寻址方式只有很少几种 在指令字中设置专门的寻址字段，用以直接指出寻址方式，适合：处理机具有多种寻址方式，且指令有多个操作数 定位方式 程序需要定位的主要原因 程序的独立性 程序的模块化设计 数据结构在程序运行过程中，其大小往往是变化的 有些程序本身很大，大于分配给它的主存物理空间(虚存) 主要的定位方式 直接定位方式：在程序装入主存储器之前，程序中的指令和数据的主存物理就已经确定了的称为直接定位方式 静态定位：在程序装入主存储器的过程中随即进行地址变换，确定指令和数据的主存物理地址的称为静态定位方式 动态定位：在程序执行过程中，当访问到相应的指令或数据时才进行地址变换，确定指令和数据的主存物理地址的称为动态定位方式 指令系统的设计与优化 指令系统的设计 指令系统设计的基本原则 指令系统的设计 指令的功能设计 指令格式的设计 在确定哪些基本功能用硬件来实现时，主要考虑3个因素：速度、成本、灵活性 硬件实现的特点：速度快、成本高、灵活性差 软件实现的特点：速度慢、价格便宜、灵活性好 对指令系统的基本要求 完整性：在一个有限可用的存储空间内，对于任何可解的问题，编制计算程序时，指令系统所提供的指令足够使用 规整性：主要包括对称性和均匀性 对称性：所有与指令系统有关的存储单元的使用、操作码的设置等都是对称的 均匀性：指对于各种不同的操作数类型、字长、操作种类和数据存储单元，指令的设置都要同等对待 正交性： 每个指令执行一个特定操作，而不是复制或者重叠其他指令功能 在指令中各个不同含义的字段，如操作类型、数据类型、寻址方式字段等，在编码时应互不相关、相互独立 高效率：指指令的执行速度快、使用频度高 兼容性：主要是要实现向后兼容，指令系统可以增加新指令，但不能删除指令或更改指令的功能 在设计指令系统时，有两种截然不同的设计策略 CISC(复杂指令系统计算机)：增强指令功能，把越来越多的功能交由硬件来实现，并且指令的数量也是越来越多 RISC(精简指令系统计算机)：尽可能地把指令系统简化，不仅指令的条数少，而且指令的功能也比较简单 指令系统的优化 指令格式的优化 哈夫曼编码 操作码优化的程度可以用信息熵来衡量：H=−∑i=1npilog2piH=-\\sum\\limits^n_{i=1}p_ilog_2p_iH=−​i=1​∑​n​​p​i​​log​2​​p​i​​ 优缺点：可以减少操作码的平均位数，但所获得的编码是变长度的，不规整，不利于硬件处理 扩展操作码：位于定长二进制编码和哈夫曼编码之间的一种编码方案 等长扩展码 为了便于分级译码，一般都采用等长扩展码 15/15/15法和8/64/512法 定长操作码 固定长度的操作码：所有指令的操作码都是同一的长度 保证操作码的译码速度、减少译码的复杂度 以程序的存储空间为代价来换取硬件实现上的好处 缩短地址码长度的方法：用一个短地址码表示一个大地址空间 用间址寻址方式缩短地址码长度 用变址寻址方式缩短地址码长度 用寄存器间接寻址方式缩短地址码长度 指令字格式的优化 如果指令字的宽度固定，地址码的长度和个数固定，则操作码的缩短并不能带来好处，只是使指令字中出现空白浪费 采用地址个数可变和/或地址码长度可变的方案 利用操作码缩短带来的好处 最常用的操作码最短，其地址字段个数最多 考虑因素 计算机中寄存器个数和寻址方式的数目对机器的指令字长有很大的影响 指令字的平均长度增加了，程序的平均长度也就增加了 在指令系统的设计之中，要在指令字长与寄存器个数以及寻址方式的个数之间进行折中 指令系统的3种编码格式 可变编码格式 固定长度编码格式 混合型编码格式 指令系统的发展和改进 沿CISC方向发展和改进指令系统 CISC指令系统的一大特点：指令数量多、功能多样 增强指令功能主要是从以下3个方面着手： 面向目标程序增强指令功能 对大量的目标程序及其执行情况进行统计分析，找出那些使用频度高、执行时间长的指令或指令串。对于使用频度高的指令，用硬件加快其执行；对于使用频度高的指令串，用一条新的指令来替代 既能减少目标程序的执行时间，也能有效地缩短程序的长度 可以从以下几个方面来改进： 增强运算型指令的功能 增强数据传送指令的功能 增强程序控制指令的功能 面向高级语言的优化实现来改进指令系统 增强对高级语言和编译器的支持 高级语言计算机 采用“比较简单的系统结构＋软件”的做法能够在较低成本和复杂度的前提下，提供更高的性能和灵活性 面向操作系统的优化实现改进指令系统 操作系统和计算机系统结构是紧密联系的，操作系统的实现在很大程度上取决于系统结构的支持 指令系统对操作系统的支持主要有： 处理机工作状态和访问方式的切换 进程的管理和切换 存储管理和信息保护 进程的同步与互斥，信号灯的管理等 沿RISC方向发展和改进指令系统 CISC指令系统结构存在的问题 各种指令的使用频度相差悬殊，许多指令很少用 指令系统庞大，指令条数很多，许多指令的功能又很复杂，使得控制器硬件非常复杂 许多指令由于操作繁杂，其CPI值比较大，执行速度慢，采用这些复杂指令有可能使整个程序的执行时间反而增加 由于指令功能复杂，规整性不好，不利于采用流水技术来提高性能 设计RISC机器遵循的原则 指令条数少、指令功能简单，只选取使用频度很高的指令，在此基础上补充一些最有用的指令 采用简单而又统一的指令格式，并减少寻址方式，指令字长都为32位或64位 指令的执行在单个机器周期内完成 只有load和store指令才能访问存储器，其它指令的操作都是在寄存器之间进行 大多数指令都采用硬连逻辑来实现 强调优化编译器的作用，为高级语言程序生成优化的代码 充分利用流水技术来提高性能 早期的RISC微处理器 1981年，Berkeley分校的Patterson等人的32位微处理器RISC I 1981年，Stanford大学Hennessy等人的MIPS IBM的801 共同特点： 采用load-store结构 指令字长为32位 采用高效的流水技术 MIPS指令系统结构 MIPS的寄存器 32个64位通用寄存器（GPRs） 32个64位浮点数寄存器（FPRs） 一些特殊寄存器 MIPS的数据表示 MIPS的数据表示：整数、浮点数 字节、半字或者字在装入64位寄存器时，用零扩展或者用符号位扩展来填充该寄存器的剩余部分。装入以后，对它们将按照64位整数的方式进行运算 MIPS的数据寻址方式 立即数寻址与偏移量寻址 寄存器间接寻址是通过把0作为偏移量来实现的 16位绝对寻址是通过把R0（其值永远为0）作为基址寄存器来完成的 MIPS的存储器是按字节寻址的，地址为64位 所有存储器访问都必须是边界对齐的 MIPS的指令格式 寻址方式编码到操作码中 所有的指令都是32位的 操作码占6位 3种指令格式：I类指令、R类指令、J类指令 MIPS的操作 MIPS指令可以分为四大类：load和store、ALU操作、分支与跳转、浮点操作 符号的意义 load和store指令 ALU指令 MIPS的控制指令 由一组跳转和一组分支指令来实现控制流的改变 典型的MIPS控制指令 跳转指令 分支指令 MIPS的浮点操作 由操作码指出操作数是单精度（SP）或双精度（DP） 浮点操作 浮点数比较指令 存储系统 存储系统的层次架构 存储系统的层次结构概述 程序访问的局部性原理：程序访问的局部性原理是指，对于绝大多数程序来说，程序所访问的指令和数据在地址上不是均匀分布的，而是相对簇聚的 存储系统的多级层次架构 存储系统的性能参数 存储容量S 存储单位的平均每位价格C 命中率H 平均访存时间：T=T1+FTMT=T_1+FT_MT=T​1​​+FT​M​​ 当命中时，访问时间即为T1T_1T​1​​，常称为命中时间 当不命中时，访问时间为T1+TMT_1+T_MT​1​​+T​M​​，TMT_MT​M​​为不命中开销 三级存储系统 Cache-主存层次 主存-辅存层次 两者的比较 存储层次的4个问题 映像规则：当把一个块调入高一层存储器时，可以放到哪些位置上？ 查找算法：当所要访问的块在高一级存储器中时，如何找到该块？ 替换算法：当发生不命中而且高一层存储器已经满时，应替换哪一块？ 写策略：当进行写访问时，应进行哪些操作？ Cache的基本知识 基本结构和原理 映像规则 全相联映像 直接映像 组相联映像 查找方法 替换算法 随机法(Random) 先进先出法(FIFO) 最近最少使用法(LRU) Not Least Recently Used(NLRU) Most Recently Used(MRU) 写策略 写命中 写直达(Write Through)：在执行写操作时，不仅把数据写入Cache相应的块，而且也写入下一级存储器 写回法(Write Back)：只把数据写入Cache中相应的块，不写入下一级存储器，只有在修改过的块被替换时，才会写回下一级存储器 写缺失 按写分配法(Write Allocate)：写不命中时，先把所写单元所在的块从主存调入Cache，然后再进行写入 不按写分配法(No-write Allocate)：写不命中时，直接写入下一级存储器而不将相应的块调入Cache Cache性能分析 平均访存时间 = 命中时间 + 缺失率 × 不命中开销 CPU时间 = (CPU执行周期数 + 存储器停顿周期数) × 时钟周期时间 = IC × (CPI + 访存次数/指令数 × 缺失率 × 不命中开销) × 时钟周期时间 改进Cache性能 降低缺失率 减少不命中开销 减少命中时间 降低Cache的缺失率 三种类型的缺失 强制缺失：当第一次访问一个块时，该块不在Cache中，需从下一级存储器中调入Cache，也称为冷启动缺失 容量缺失：如果程序执行时所需的块不能全部调入Cache中，则当某些块被替换后，若又重新被访问，就会发生不命中 冲突缺失：在组相联或直接映像Cache中，若太多的块映像到同一组中，则会出现该组中某个块被别的块替换，然后又被重新访问的情况 增加Cache块大小 减少强制缺失 增加冲突缺失和不命中开销 增加Cache的容量 减少了容量缺失 增加成本和命中时间 提高相联度 减少冲突缺失 增加访存时间 伪相联Cache 首先按照与直接映像相同的方式进行访问，如果命中，则从相应的块中取出所访问的数据，如果缺失，检查Cache另一位置，看是否匹配，确定“另一块”的方法是将索引字段的最高位取反，按照新索引去寻找对应块 伪相联具有一快一慢两种命中时间，分别对应正常命中和伪命中的情况，这会使CPU流水线的设计复杂化，因此伪相联技术往往应用于离处理器较远的Cache上 硬件预取 指令和数据都可以在处理器提出访问请求之前进行预取，预取内容可以直接放入Cache中，也可以放在一个访问速度比主存快的外部缓冲器中 编译器控制的预取 按照预取数据所放的位置，可把预取分为以下两种类型： 寄存器预取 Cache预取 按照预取的处理方式不同，可把预取分为以下两种： 故障性预取 非故障性预取 编译优化 内外循环交换 分块 数组合并 减少Cache的缺失开销 采用两级Cache 平均访存时间 = 命中时间L1 + 缺失率L1 × (命中时间L2 + 不命中率L2 × 不命中开销L2) 多级Cache包含性：包含/互斥 请求字处理技术 尽早重启动：在请求字没有到达时，CPU处于等待状态，一旦请求字到达，就立即发送给CPU，让等待的CPU尽早重启动，继续执行 关键字优先：调块时，让存储器首先提供CPU所要的请求字，请求字一旦到达，就立即发送给CPU，让CPU继续执行，同时从存储器调入该块的其余部分 读缺失优先于写缺失 在读缺失时检查写缓冲器的内容，如果没有冲突而且存储器可访问，就可继续处理读缺失，否则直接从缓冲器中读取数据 写缓冲合并 牺牲Cache 在Cache和其下一级存储器的数据通路上增设一个全相联的小Cache，存放因冲突而被替换出去的那些块，每当发生缺失时，在访问下一级存储器之前，先检查牺牲Cache中是否包含有所需的块，如果有，就将该块与Cache中的某个块交换，把所需的块调入Cache 减少命中时间 小而简单的Cache 避免地址变换 Cache访问流水化 踪迹Cache 并行主存系统 内存的组织 单体单字存储器 字长与CPU的字长相同 每一次只能访问一个存储字，假设该存储器的访问周期是T，字长为W位，则其带宽为B=WT\\frac{W}{T}​T​​W​​ 单体多字存储器 一个单体m字存储器 B=m×WT\\frac{W}{T}​T​​W​​ 并行访问存储器 方法：把L字W位的存储器改变成L/n字n×W位的存储器 逻辑实现：把地址码分成两个部分，一部分作为存储器的地址，另一部分负责选择数据 主要缺点：访问冲突大 取指令冲突(分支) 读操作数冲突 写数据冲突 读写冲突(读写同一存储字) 多体交叉存储器 多体交叉存储器：由多个单字存储体构成，每个体都有自己的地址寄存器以及地址译码和读/写驱动等电路 高位交叉访问存储器 主要目的：扩大存储器容量 实现方法：用地址码的高位部分区分存储体号 参数计算方法： m：每个存储体的容量 n：总共的存储体个数 j：存储体的体内地址 k：存储体的体号 存储器的地址：A=m×k+j 存储器的体内地址：Aj=A mod mA_j=A\\ mod\\ mA​j​​=A mod m 存储器的体号：Ak=⌊Am⌋A_k=\\lfloor\\frac{A}{m}\\rfloorA​k​​=⌊​m​​A​​⌋ 低位交叉访问存储器 主要目的：提高存储器访问速度 实现方法：用地址码的低位部分区分存储体号 参数计算方法： m：每个存储体的容量 n：总共的存储体个数 j：存储体的体内地址 k：存储体的体号 存储器的地址：A=n×j+k 存储器的体内地址：Aj=⌊An⌋A_j=\\lfloor\\frac{A}{n}\\rfloorA​j​​=⌊​n​​A​​⌋ 存储器的体号：Ak=A mod nA_k=A\\ mod\\ nA​k​​=A mod n 无冲突访问存储器 一维数组(向量)的无冲突访问存储器 具体方法：存储体的个数取质数，且n≥向量长度 原因：变址位移量必然与存储体个数互质 二维数组的无冲突访问存储器 要求：一个n×n的二维数组，按行、列、对角线和反对角线访问，并且在不同的变址位移量情况下，都能实现无冲突访问 顺序存储：按列访问有冲突 错位存储：按对角线访问有冲突 并行存储体的个数m≥n，并且取质数，同时还要在行、列方向上错开一定的距离存储数组元素 虚拟存储器 虚拟存储器是“主存—辅存”层次进一步发展的结果 虚拟存储器可以分为两类：页式和段式 页式虚拟存储器把空间划分为大小相同的块(页面) 段式虚拟存储器则把空间划分为可变长的块(段) 快速地址转换技术 地址变换缓冲器TLB TLB是一个专用的高速缓冲器，用于存放近期经常使用的页表项 TLB中的内容是页表部分内容的一个副本 TLB利用了局部性原理 TLB中的项由两部分组成：标识和数据 标识中存放的是虚地址的一部分 数据部分存放的是物理页帧号、有效位、存储保护信息、使用位、修改位等 一般TLB比Cache的标识存储器更小、更快 基本流水线技术 流水线工作原理 流水线锁存器 流水线的每一个阶段称为流水段，在每一个流水段的末尾或开头必须设置一个(多个)寄存器，称为流水寄存器，流水寄存器会增加每条指令的执行时间，但采用流水线之后整个程序的执行时间会缩短 流水线的表示方法 流水线的连接图表示方法：表示流水线的逻辑关系 流水线的时空图表示方法：表示流水线的时间关系 流水线的预约表表示方法 流水线的时空图 流水线的主要特点 只有连续提供同类任务才能充分发挥流水线的效率 在流水线的每一个流水段中都要设置一个流水锁存器 各流水段的时间应尽量相等 流水线的分类 线性流水线与非线性流水线 线性流水线：每一个流水段都流过一次，而且仅流过一次 非线性流水线：在流水线的某些流水段之间有反馈电路或前馈电路 按照流水线的级别来分 处理机级流水线，又称为指令流水线 部件级流水线(操作流水线) 处理机之间的流水线称为宏流水线，每个处理机对同一个数据流的不同部分分别进行处理 单功能流水线与多功能流水线 单功能流水线：只能完成一种固定功能的流水线 多功能流水线：流水线的各段通过不同的连接实现不同的功能 静态流水线与动态流水线 静态流水线：同一段时间内，多功能流水线中的各个功能段只能按照一种固定的方式连接，实现一种固定的功能，只有连续出现同一种运算时，流水线的效率才能得到充分的发挥 动态流水线：在同一段时间内，多功能流水线中的各段可以按照不同的方式连接，同时执行多种功能 流水线的其它分类方法 按照数据表示方式：标量流水线和向量流水线 按照控制方式：同步流水线和异步流水线 线性流水线的性能分析 吞吐率 计算流水线吞吐率的最基本公式：TP=nTkTP=\\frac{n}{T_k}TP=​T​k​​​​n​​，其中n为任务数，TkT_kT​k​​为完成n个任务所用的时间 各段执行时间相等，输入连续任务情况下，完成n个任务需要的总时间为：Tk=(k+n−1)ΔtT_k=(k+n-1)\\Delta tT​k​​=(k+n−1)Δt，其中k为流水线的段数，Δt\\Delta tΔt为时钟周期 吞吐率为：TP=n(k+n−1)ΔtTP=\\frac{n}{(k+n-1)\\Delta t}TP=​(k+n−1)Δt​​n​​ 最大吞吐率为：TPmax=limn→∞n(k+n−1)Δt=1ΔtTP_{max}=\\lim\\limits_{n\\rightarrow \\infty}\\frac{n}{(k+n-1)\\Delta t}=\\frac{1}{\\Delta t}TP​max​​=​n→∞​lim​​​(k+n−1)Δt​​n​​=​Δt​​1​​ 各段执行时间不等，输入连续任务情况下 吞吐率为：TP=n∑i=1kΔti+(n−1)max(Δt1,Δt2,...,Δtk)TP=\\frac{n}{\\sum\\limits^k_{i=1}\\Delta t_i+(n-1)max(\\Delta t_1,\\Delta t_2,..., \\Delta t_k)}TP=​​i=1​∑​k​​Δt​i​​+(n−1)max(Δt​1​​,Δt​2​​,...,Δt​k​​)​​n​​ 最大吞吐率为：TP=1max(Δt1,Δt2,...,Δtk)TP=\\frac{1}{max(\\Delta t_1,\\Delta t_2,...,\\Delta t_k)}TP=​max(Δt​1​​,Δt​2​​,...,Δt​k​​)​​1​​ 流水线各段执行时间不相等的解决办法 将流水线的“瓶颈”部分再细分 “瓶颈”流水段重复设置：增加分配器和收集器 加速比 计算流水线加速比的基本公式：S = 顺序执行时间T_0/流水线执行时间T_k 各段执行时间相等，输入连续任务情况下 加速比为：S=k⋅n⋅Δt(k+n−1)Δt=k⋅nk+n−1S=\\frac{k\\cdot n\\cdot \\Delta t}{(k+n-1)\\Delta t}=\\frac{k\\cdot n}{k+n-1}S=​(k+n−1)Δt​​k⋅n⋅Δt​​=​k+n−1​​k⋅n​​ 最大加速比为：Smax=limn→∞k⋅nk+n−1=kS_{max}=\\lim\\limits_{n \\rightarrow \\infty}\\frac{k\\cdot n}{k+n-1}=kS​max​​=​n→∞​lim​​​k+n−1​​k⋅n​​=k 各段执行时间不相等，输入连续任务情况下 实际加速比为：S=n⋅∑i=1kΔti∑i=1kΔti+(n−1)⋅max(Δt1,Δt2,...,Δtk)S=\\frac{n\\cdot\\sum\\limits^k_{i=1}\\Delta t_i}{\\sum\\limits^k_{i=1}\\Delta t_i+(n-1)\\cdot max(\\Delta t_1,\\Delta t_2,...,\\Delta t_k)}S=​​i=1​∑​k​​Δt​i​​+(n−1)⋅max(Δt​1​​,Δt​2​​,...,Δt​k​​)​​n⋅​i=1​∑​k​​Δt​i​​​​ 当流水线段数增加时，需要连续输入的任务数也必须增加 效率 计算流水线效率的一般公式：E = n个任务占用的时空区/k个流水段的总的时空区 = T0k⋅Tk\\frac{T_0}{k\\cdot T_k}​k⋅T​k​​​​T​0​​​​ 各流水段执行时间相等，输入n个连续任务 流水线的效率为：E=k⋅n⋅Δtk⋅(k+n−1)⋅Δt=nk+n−1E=\\frac{k\\cdot n\\cdot \\Delta t}{k\\cdot (k+n-1)\\cdot\\Delta t}=\\frac{n}{k+n-1}E=​k⋅(k+n−1)⋅Δt​​k⋅n⋅Δt​​=​k+n−1​​n​​ 流水线的最高效率为：Emax=limn→∞nk+n−1=1E_{max}=\\lim\\limits_{n\\rightarrow \\infty}\\frac{n}{k+n-1}=1E​max​​=​n→∞​lim​​​k+n−1​​n​​=1 各段流水线执行时间不等，输入n个连续任务 流水线效率为：E=n⋅∑i=1kΔtik⋅[∑i=1kΔti+(n−1)⋅max(Δt1,Δt2,...,Δtk)]E=\\frac{n\\cdot\\sum\\limits^k_{i=1}\\Delta t_i}{k\\cdot[\\sum\\limits^k_{i=1}\\Delta t_i+(n-1)\\cdot max(\\Delta t_1,\\Delta t_2,...,\\Delta t_k)]}E=​k⋅[​i=1​∑​k​​Δt​i​​+(n−1)⋅max(Δt​1​​,Δt​2​​,...,Δt​k​​)]​​n⋅​i=1​∑​k​​Δt​i​​​​ 流水线各段的设备量或者各段的价格不相等时 流水线效率为：E = n个任务占用的加权时空区/k个流水段的总的加权时空图 流水线的吞吐率、加速比与效率的关系 E=TP⋅Δt, S=k⋅EE=TP\\cdot \\Delta t,\\ S=k\\cdot EE=TP⋅Δt, S=k⋅E 流水线最佳段数的选择 流水线的总价格估计为：C=a+bk，其中a为所有功能段本身的总价格，b为每个锁存器的价格 使流水线的价格比PCR最大时：k=a⋅tb⋅d\\sqrt{\\frac{a\\cdot t}{b\\cdot d}}√​​b⋅d​​a⋅t​​​​​，其中d为流水线锁存器的延迟时间 非线性流水线的调度技术 非线性流水线调度的任务是要找出一个最小循环周期，按照这周期向流水线输入新任务，流水线各个功能段都不会发生冲突，而且流水线的吞吐率和效率最高 1.非线性流水线的预约表表示方法 非线性流水线的冲突 流水线的启动距离：连续两个任务之间的时间间隔 流水线的冲突：几个任务争用同一个流水段 无冲突调度方法 非线性流水线的禁止启动集合F：预约表中每一行任意两个“×”之间的距离都计算出来，去掉重复的，上例中F={3，4，6} 由禁止启动集合得到冲突向量：C=(CmCm−1...C2C1C_mC_{m-1}... C_2C_1C​m​​C​m−1​​...C​2​​C​1​​)，其中m是禁止集合中的最大值，如果i在禁止集合F中，则Ci=1C_i=1C​i​​=1，否则Ci=0C_i=0C​i​​=0，上例中C=(101100) 由冲突向量构造状态图：把冲突向量送入一个m位逻辑右移移位器，如果移位器移出0，用移位器中的值与初始冲突向量作“按位或”运算，得到一个新的冲突向量；否则不作任何处理；如此重复m次。对于中间形成的每一个新的冲突向量，也要按照这一方法进行处理 简单循环：状态图中各种冲突向量只经过一次的启动循环 优化调度方法 流水线最小平均启动距离的限制范围 下限是预约表中任意一行里“×”的最多个数 小于或等于状态图中任意一个简单循环的平均启动距离 最小平均启动距离的上限是冲突向量中1的个数再加上1 采用预留算法来调度非线性流水线，可以达到最优调度 确定最小平均启动距离(MAL)：预约表任一行中“×”的最多个数 确定最小启动循环，一般恒定循环作为最小启动循环 通过插入非计算延迟段——修改预约表实现最小启动循环 高级流水线 超标量流水线 多条指令流水线 超标量处理机：一个时钟周期能同时发射多条指令的处理机 超标量处理机的指令并行度(ILP)大于1 目前的指令调度技术，每个周期发射2至4条指令比较合理 先行指令窗口：能够从指令Cache中预取多条指令，能够对窗口内的指令进行数据相关性分析和功能部件冲突检测 多流水线的调度主要有三种方法 顺序发射顺序完成 顺序发射乱序完成 乱序发射乱序完成 普通标量处理机，希望相同操作连续出现；超标量处理机则正好相反，希望相同操作不要连续出现，这种要求正好符合一般标量程序的特点 超标量处理机性能 在每个周期发射m条指令的超标量处理机上执行的时间为：T(m,1)=(k+N−mm)ΔtT(m,1)=(k+\\frac{N-m}{m})\\Delta tT(m,1)=(k+​m​​N−m​​)Δt 超标量处理机相对于单流水线标量处理机的加速比为：S(m,1)=T(1,1)T(m,1)=m(k+N+1)N+m(k−1)S(m,1)=\\frac{T(1,1)}{T(m,1)}=\\frac{m(k+N+1)}{N+m(k-1)}S(m,1)=​T(m,1)​​T(1,1)​​=​N+m(k−1)​​m(k+N+1)​​ 超标量处理机的加速比的最大值为：S(m,1)max=mS(m,1)_{max}=mS(m,1)​max​​=m 超流水线 超流水线处理机 两种定义 在一个周期内能够分时发射多条指令的处理机 指令流水线的功能段数为8段或超过8段的流水线处理机 提高处理机性能的不同方法 超标量处理机：通过增加硬件资源来提高处理及性能 超流水线处理机：通过各部分硬件的重叠工作来提高处理机性能 两种不同并行性 超标量处理机采用的是空间并行性 超流水线处理机采用的是时间并行性 指令执行时序 每隔1/n个时钟周期发射一条指令 在超标量处理机中，流水线的有些功能段还可以进一步细分 超流水线处理机性能 指令级并行度(1,n)的超流水线处理机，执行N条指令所用的时间为：T(1,n)=(k+N−1n)ΔtT(1,n)=(k+\\frac{N-1}{n})\\Delta tT(1,n)=(k+​n​​N−1​​)Δt 超流水线处理机相对于单流水线普通标量处理机的加速比为：S(1,n)=T(1,1)T(1,n)=n(k+N−1)nk+N−1S(1,n)=\\frac{T(1,1)}{T(1,n)}=\\frac{n(k+N-1)}{nk+N-1}S(1,n)=​T(1,n)​​T(1,1)​​=​nk+N−1​​n(k+N−1)​​ 超标量超流水线 把超标量与超流水线技术结合在一起，就成为超标量超流水线处理机 超标量超流水线处理机在一个时钟周期内分时发射指令n次，每次同时发射m条 超标量超流水线处理机每个时钟周期总共发射指令mn条 超标量处理机性能 指令级并行度为(m,n)的超标量超流水线处理机，连续执行N条指令所需要的时间为：T(m,n)=(k+N−mm⋅n)ΔtT(m,n)=(k+\\frac{N-m}{m\\cdot n})\\Delta tT(m,n)=(k+​m⋅n​​N−m​​)Δt 超标量超流水线处理机相对于单流水线标量处理机的加速比为：S(m,n)=S(1,1)S(m,n)=m⋅n⋅(k+N−1)m⋅n⋅k+N−mS(m,n)=\\frac{S(1,1)}{S(m,n)}=\\frac{m\\cdot n\\cdot (k+N-1)}{m\\cdot n\\cdot k+N-m}S(m,n)=​S(m,n)​​S(1,1)​​=​m⋅n⋅k+N−m​​m⋅n⋅(k+N−1)​​ 理想情况下，超标量超流水线处理机加速比的最大值为：S(m,n)max=mnS(m,n)_{max}=mnS(m,n)​max​​=mn 指令级并行及其开发——硬件方法 指令级并行的概念 指令级并行：指指令之间存在的一种并行性，利用它，计算机可以并行执行两条或两条以上的指令 开发ILP的方法可以分为两大类 主要基于硬件的动态开发方法 基于软件的静态开发方法 流水线处理机的实际CPI 理想流水线的CPI加上各类停顿的时钟周期数：CPI流水线 = CPI理想 + 停顿结构冲突 + 停顿数据冲突 + 停顿_控制冲突 IPC：每个时钟周期完成的指令条数 基本程序块：一串连续的代码除了入口和出口以外，没有其它的分支指令和转入点 循环级并行：使一个循环中的不同循环体并行执行，开发循环的不同迭代之间存在的并行性 最基本的开发循环级并行的技术：循环展开技术、采用向量指令和数据向量表示 相关与指令级并行 相关与流水线冲突 相关有三种类型：数据相关、名相关、控制相关 流水线冲突是指对于具体的流水线来说，由于相关的存在，使得指令流中的下一条指令不能在指定的时钟周期执行 流水线冲突有三种类型：结构冲突、数据冲突、控制冲突 相关是程序固有的一种属性，它反映了程序中指令之间的相互依赖关系，具体的一次相关是否会导致实际冲突的发生以及该冲突会带来多长的停顿，则是流水线的属性 可以从两个方面来解决相关问题 保持相关，但避免发生冲突 通过代码变换，消除相关 程序顺序：由原来程序确定的在完全串行方式下指令的执行顺序 控制相关：由分支指令引起的相关，控制相关并不是一个必须严格保持的关键属性，有时不遵守控制相关既不影响中断行为，也不改变数据流，可以大胆地进行指令调度，把失败分支中的指令调度到分支指令之前 对于正确地执行程序来说，必须保持的最关键的两个属性是：数据流和中断行为 数据流：指数据值从其生产者指令到其消费者指令的实际流动 保持中断行为是指：无论怎么改变指令的执行顺序，都不能改变程序中中断的发生情况 指令的动态调度 静态调度 依靠编译器对代码进行静态调度，以减少相关和冲突 它不是在程序执行的过程中、而是在编译期间进行代码调度和优化 通过把相关的指令拉开距离来减少可能产生的停顿 动态调度 在程序的执行过程中，依靠专门硬件对代码进行调度，减少数据相关导致的停顿 能够处理一些在编译时情况不明的相关（比如涉及到存储器访问的相关），并简化了编译器 能够使本来是面向某一流水线优化编译的代码在其它的流水线（动态调度）上也能高效地执行 以硬件复杂性的显著增加为代价 动态调度的基本思想 到目前为止我们所使用流水线的最大的局限性：指令是按序发射和按序执行的 将5段流水线的译码阶段再分为两个阶段： 发射：指令译码，检测是否存在结构冲突 读操作数：等待数据冲突消失，然后读操作数 动态调度的流水线支持多条指令同时处于执行当中 要求：具有多个功能部件、或者功能部件流水化、或者兼而有之 指令乱序完成带来的最大问题：中断处理比较复杂 动态调度的处理机要保持正确的中断行为：对于一条会产生中断的指令来说，只有当处理机确切地知道该指令将被执行时，才允许它产生中断 即使保持了正确的中断行为，动态调度处理机仍可能发生不精确中断：当执行指令i导致发生中断时，处理机的现场(状态)与严格按程序顺序执行时指令i的现场不同 发生不精确中断的原因：当发生中断(设为指令i)时，流水线可能已经执行完按程序顺序是位于指令i之后的指令，或流水线可能还没完成按程序顺序是指令i之前的指令 记分牌动态调度算法 基本思想 该机器用一个称为记分牌的硬件实现了对指令的动态调度 该硬件中维护着3张表，分别用于记录指令的执行状态、功能部件状态、寄存器状态以及数据相关关系等 它把前述5段流水线中的译码段ID分解成了两个段：发射和读操作数，以避免当某条指令在ID段被停顿时挡住后面无关指令的流动 没有Cache，没有采用Forwarding技术 记分牌的目标：在没有结构冲突时，尽可能早地执行没有数据冲突的指令，实现每个时钟周期执行一条指令 每条指令的执行过程分为4段(主要考虑浮点操作) 发射：如果当前指令所需的功能部件空闲，并且所有其它正在执行的指令的目的寄存器与该指令的不同，记分牌就向功能部件发射该指令，并修改记分牌内部的记录表(解决WAW冲突) 读操作数：记分牌监测源操作数的可用性，如果数据可用，它就通知功能部件从寄存器中读出源操作数并开始执行(解决RAW冲突) 执行：取到操作数后，功能部件开始执行，当产生出结果后，就通知记分牌它已经完成执行，在浮点流水线中，这一段可能要占用多个时钟周期 写结果：记分牌一旦知道执行部件完成了执行，就检测是否存在WAR冲突，如果不存在，或者原有的WAR冲突已消失，记分牌就通知功能部件把结果写入目的寄存器，并释放该指令使用的所有资源；如果检测到WAR冲突，就不允许该指令将结果写到目的寄存器，记分牌必须等待，直到该冲突消失 记分牌中记录的信息由3部分构成 指令状态表：记录正在执行的各条指令已经进入到了哪一段 功能部件状态表：记录各个功能部件的状态，每个功能部件有一项，每一项由以下9个字段组成： Busy：忙标志，指出功能部件是否忙，初值为“no” Op：该功能部件正在执行或将要执行的操作 Fi：目的寄存器编号 Fj，Fk：源寄存器编号 Qj，Qk：指出向源寄存器Fj、Fk写数据的功能部件 Rj，Rk：标志位，为“yes”表示Fj，Fk中的操作数就绪且还未被取走，否则就被置为“no” 结果寄存器状态表Result：每个寄存器在该表中有一项，用于指出哪个功能部件(编号)将把结果写入该寄存器，如果当前正在运行的指令都不以它为目的寄存器，则其相应项置为“no”，Result各项的初值为“no”(全0) 记分牌的性能受限于以下几个方面 程序代码中可开发的并行性，即是否存在可以并行执行的不相关的指令 记分牌的容量，记分牌的容量决定了流水线能在多大范围内寻找不相关指令，流水线中可以同时容纳的指令数量称为指令窗口 功能部件的数目和种类，功能部件的总数决定了结构冲突的严重程度 反相关和输出相关，它们引起计分牌中WAR和WAW冲突 Tomasulo算法 核心思想 记录和检测指令相关，操作数一旦就绪就立即执行，把发生RAW冲突的可能性减少到最小 通过寄存器重命名来消除WAR冲突和WAW冲突 保留站 每个保留站中保存一条已经发射并等待到本功能部件执行的指令(相关信息)：包括：操作码、操作数以及用于检测和解决冲突的信息 在一条指令发射到保留站的时候，如果该指令的源操作数已经在寄存器中就绪，则将之取到该保留站中；如果操作数还没有计算出来，则在该保留站中记录将产生这个操作数的保留站的标识 每个保留站都有一个标识字段，唯一地标识了该保留站 公共数据总线CDB 所有功能部件的计算结果都是送到CDB上，由它把这些结果直接送到(播送到)各个需要该结果的地方 在具有多个执行部件且采用多发射(即每个时钟周期发射多条指令)的流水线中，需要采用多条CDB load缓冲器和store缓冲器 存放读/写存储器的数据或地址 load缓冲器的作用有3个： 存放用于计算有效地址的分量 记录正在进行的load访存，等待存储器的响应 保存已经完成了的load的结果(即从存储器取来的数据)，等待CDB传输 store缓冲器的作用有3个： 存放用于计算有效地址的分量 保存正在进行的store访存的目标地址，该store正在等待存储数据的到达 保存该store的地址和数据，直到存储部件接收 浮点寄存器FP 共有16个浮点寄存器：F0，F2，F4，…，F30 它们通过一对总线连接到功能部件，并通过CDB连接到store缓冲器 指令队列 指令部件送来的指令放入指令队列 指令队列中的指令按先进先出的顺序发射 运算部件 浮点加法器完成加法和减法操作 浮点乘法器完成乘法和除法操作 在Toamsulo算法中，寄存器重命名是通过保留站和发射逻辑来共同完成的 当指令发射时，如果其操作数还没有计算出来，则将该指令中相应的寄存器号重命名为将产生这个操作数的保留站的标识 指令发射到保留站后，其操作数寄存器号或者换成了数据本身(如果该数据已经就绪)，或者换成了保留站的标识，不再与寄存器有关系 Tomasulo算法具有以下两个特点 冲突检测和指令执行控制是分布的，每个功能部件的保留站中的信息决定了什么时候 指令可以在该功能部件开始执行，计算结果通过CDB直接从产生它的保留站传送到所有需要它的功能部件，而不用经过寄存器 指令执行的步骤：使用Tomasulo算法的流水线需3段 发射：从指令队列的头部取一条指令 如果该指令的操作所要求的保留站有空闲的，就把该指令送到该保留站(设为r) 如果其操作数在寄存器中已经就绪，就将这些操作数送入保留站r 如果其操作数还没有就绪，就把将产生该操作数的保留站的标识送入保留站r 一旦被记录的保留站完成计算，它将直接把数据送给保留站r(消除WAR冲突) 完成对目标寄存器的预约工作(消除WAW冲突) 如果没有空闲的保留站，指令就不能发射(结构冲突) 执行：当两个操作数都就绪后，本保留站就用相应的功能部件开始执行指令规定的操作 写结果：功能部件计算完毕后，就将计算结果放到CDB上，所有等待该计算结果的寄存器和保留站(包括store缓冲器)都同时从CDB上获得所需要的数据 每个保留站有以下7个字段 Qp：要对源操作数进行的操作 Qj，Qk：将产生源操作数的保留站号，等于0表示操作数已经就绪且在Vj或Vk中，或者不需要操作数 Vj，Vk：对于每一个操作数来说，V或Q字段只有一个有效；对于load来说，Vk字段用于保存偏移量 Busy：为“yes”表示本保留站或缓冲单元“忙” A：仅load和store缓冲器有该字段，开始是存放指令中的立即数字段，地址计算后存放有效地址 Qi：寄存器状态表，每个寄存器在该表中有对应的一项，用于存放将把结果写入该寄存器的保留站的站号，为0表示当前没有正在执行的指令要写入该寄存器，也即该寄存器中的内容就绪 动态分支预测技术 分支预测技术 软件方法 总是taken/not taken 基于操作码Opcode 基于偏移量(forward not taken，backward taken) 编译指导 硬件方法：动态分支预测 分支预测错误代价 在预测错误时，要作废已经预取和分析的指令，恢复现场，并从另一条分支路径重新取指令 最大代价：~进入流水线循环长度 × 流水线宽度 减少分支预测错误代价的手段 软件 减少分支：循环展开 提前形成条件码 延迟转移 硬件 延迟转移 前瞻执行 动态分支预测 动态分支预测：在程序运行时，根据分支指令过去的表现来预测其将来的行为 如果分支行为发生了变化，预测结果也跟着改变 有更好的预测准确度和适应性 分支预测的有效性取决于 预测的准确性 预测正确和不正确两种情况下的分支开销 决定分支开销的因素 流水线的结构 预测的方法 预测错误时的恢复策略等 采用动态分支预测技术的目的 预测分支是否成功 尽快找到分支目标地址(或指令) 需要解决的关键问题 如何记录分支的历史信息，要记录哪些信息 如何根据这些信息来预测分支的去向，甚至提前取出分支目标处的指令 动态分支预测模型 采用分支历史表BHT 分支历史表BHT 最简单的动态分支预测方法 用BHT来记录分支指令最近一次或几次的执行情况(成功还是失败)，并据此进行预测 只有1个预测位的分支预测：记录分支指令最近一次的历史，BHT中只需要1位二进制位(最简单) 采用2位移位器 采用2位饱和计数器 两位分支预测中的操作有两个步骤 分支预测 状态修改 BHT方法只在以下情况下才有用：判定分支是否成功所需的时间 ＞ 确定分支目标地址所需的时间 BHT可以跟分支指令一起存放在指令Cache中，也可以用一块专门的硬件来实现 采用分支目标缓冲器BTB 目标：将分支的开销降为0 方法：分支目标缓冲 将分支成功的分支指令的地址和它的分支目标地址都放到一个缓冲区中保存起来，缓冲区以分支指令的地址作为标识 这个缓冲区就是分支目标缓冲器，简记为BTB，或者分支目标Cache 看成是专门的硬件实现的一张表格，表格中的每一项至少有两个字段 执行过的成功分支指令的地址 预测的分支目标地址 采用BTB后，在流水线各个阶段所进行的相关操作 采用BTB后，各种可能情况下的延迟 BTB的另一种形式 在分支目标缓冲器中增设一个至少是两位的“分支历史表”字段 更进一步，在表中对于每条分支指令都存放若干条分支指令目标处的指令，就形成了分支目标指令缓冲器 基于硬件的前瞻执行 前瞻执行的基本思想：对分支指令的结果进行猜测，并假设这个猜测总是对的，然后按这个猜测结果继续取、发射和执行后续的指令，只是执行指令的结果不是写回到寄存器或存储器，而是写入一个称为重定位缓冲器ROB中，等到相应的指令得到“确认提交”(即确实是应该执行的)之后，才将结果写入寄存器或存储器 基于硬件的前瞻执行结合了3种思想 动态分支预测，用来选择后续执行的指令 在控制相关的结果尚未出来之前，前瞻地执行后续指令 用动态调度对基本块的各种组合进行跨基本块调度 对Tomasulo算法加以扩充，就可以支持前瞻执行：把Tomasulo算法的写结果和指令完成加以区分，分成两个不同的段 写结果 把前瞻执行的结果写到ROB中 通过CDB在指令之间传送结果，供需要用到这些结果的指令使用 指令提交：在分支指令的结果出来后，对相应指令的前瞻执行给予确认提交 如果前面所做的猜测是对的，把在ROB中的结果写到寄存器或存储器 如果发现前面对分支结果的猜测是错误的，那就不予以确认，并从那条分支指令的另一条路径开始重新执行 控制相关的动态解决技术 控制相关：由条件转移或程序中断引起的相关，也称全局相关，控制相关对流水线的吞吐率和效率影响相对于数据相关要大得多 条件指令在一般程序中所占的比例相当大 中断虽然在程序中所占的比例不大，但中断发生在程序中的哪一条指令，发生在一条指令执行过程中的哪一个功能段都是不确定的 处理好条件转移和中断引起的控制相关是很重要的 关键问题 要确保流水线能够正常工作 减少因断流引起的吞吐率和效率的下降 硬件支持精确中断/例外与分支预测 Issue：如果RS和ROB有空闲单元就发射指令，如果寄存器或ROB中源操作数可用，就将其发送到RS，目的地址的ROB编号也发送给RS，否则，指令发射停顿 Execution：当操作数就绪后，开始执行，如果没有就绪，监测CDB，检查RAW相关 Write result：将运算结果通过CDB传送给所有等待结果的FU以及ROB单元，标记RS可用 Commit：按ROB表中顺序，如果结果已有，就更新寄存器(或存储器)，并将该指令从ROB表中删除，预测失败或有中断时，刷新ROB 多指令发射技术 在每个时钟周期内发射多条指令，CPI 多发射处理机有两种基本风格 超标量 在每个时钟周期发射的指令条数不固定，依代码的具体情况而定(有上限) 设这个上限为n，就称该处理机为n-发射 可以通过编译器进行静态调度，也可以基于Tomasulo算法进行动态调度 超长指令字VLIW 在每个时钟周期发射的指令条数是固定的，这些指令构成一条长指令或者一个指令包 指令包中，指令之间的并行性是通过指令显式地表示出来的 指令调度是由编译器静态完成的 超标量处理机与VLIW处理机相比有两个优点 超标量结构对程序员是透明的，处理机能自己检测下一条指令能否发射，不需要由编译器或专门的变换程序对程序中的指令进行重新排列 即使是没有经过编译器针对超标量结构进行调度优化的代码或是旧的编译器生成的代码也可以运行，当然运行的效果不会很好 基于静态调度的多发射技术 在典型的超标量处理器中，每个时钟周期可发射1到8条指令 指令按序发射，在发射时进行冲突检测，由硬件检测当前发射的指令之间是否存在冲突以及当前发射的指令与正在执行的指令是否有冲突 基于动态调度的多发射技术 扩展Tomasulo算法：支持双发射超标量流水线 每个时钟周期发射两条指令 一条是整数指令，另一条是浮点指令 采用一种比较简单的方法 指令按顺序流向保留站，否则会破坏语义 将整数所用的表结构与浮点用的表结构分离开，分别进行处理，这样就可以同时地发射一条浮点指令和一条整数指令到各自的保留站 上述双发射动态调度流水线的性能受限于以下3个因素 整数部件和浮点部件的工作负载不平衡，没有充分发挥出浮点部件的作用 每个循环叠代中的控制开销太大 控制相关使得处理机必须等到分支指令的结果出来后才能开始下一条L.D指令的执行 超长指令字技术 把能并行执行的多条指令组装成一条很长的指令 设置多个功能部件 指令字被分割成一些字段，每个字段称为一个操作槽，直接独立地控制一个功能部件 在VLIW处理机中，在指令发射时不需要进行复杂的冲突检测，而是依靠编译器全部安排好了 VLIW存在的一些问题 程序代码长度增加了 提高并行性而进行的大量的循环展开 指令字中的操作槽并非总能填满 解决：采用指令共享立即数字段的方法，或者采用指令压缩存储、调入Cache或译码时展开的方法 采用了锁步机制：任何一个操作部件出现停顿时，整个处理机都要停顿 机器代码兼容性不好 多发射处理器受到的限制 主要受以下3个方面的影响 程序所固有的指令级并行性 硬件实现上的困难 超标量和超长指令字处理器固有的技术限制 指令级并行的开发——软件方法 基本指令调度及循环展开 指令调度的基本方法 指令调度：找出不相关的指令序列，让它们在流水线上重叠并行执行 制约编译器指令调度的因素 程序固有的指令级并行 流水线功能部件的延迟 循环展开 循环展开 把循环体的代码复制多次并按顺序排放，然后相应调整循环的结束条件 开发循环级并行的有效方法 循环展开的注意事项 保证正确性(循环控制、偏移量) 注意有效性(循环体之间无关) 使用不同的寄存器 删除多余的测试指令和分支指令，并对循环结束代码和新的循环体代码进行相应的修正 注意对存储器数据的相关性分析 注意新的相关性 跨越基本块的静态指令调度 全局指令调度 概述 目标：在保持原有数据相关和控制相关不变的前提下，尽可能地缩短包含分支结构的代码段的总执行时间 基本思想：在循环体内的多个基本块间移动指令，扩大那些执行频率较高的基本块的体积 多指令发射 超标量流水线的静态调度——循环展开 静态多指令发射技术：VLIW技术 VLIW vs. 超标量 在动态调度的超标量处理器中，相关检测和指令调度基本都由硬件完成 在静态调度的超标量处理器中，部分相关检测和指令调度工作交由编译器完成 在VLIW处理器中，相关检测和指令调度工作全部由编译器完成，它需要更“智能”的编译器 显示并行指令计算EPIC 什么是EPIC 指令级并行主要由编译器负责开发，处理器为保证代码正确执行提供必要的硬件支持，只有在这些硬件机制的辅助下这些优化技术才能高效完成 系统结构必须提供某种通信机制，使得流水线硬件能够了解编译器“安排”好的指令执行顺序 EPIC编译器的高级优化技术 非绑定分支 谓词执行 前瞻执行 开发更多的指令级并行 循环携带相关 循环携带相关是指一个循环的某个叠代中的指令与其他叠代中的指令之间的数据相关 软件流水 软流水技术的核心思想是从循环不同的叠代中抽取一部分指令(循环控制指令除外)拼成一个新的循环叠代 目的 将同一叠代中的相关指令分布到不同的叠代中 将不同叠代中的相关指令封装到同一叠代中 软件流水 vs. 循环展开 循环展开主要减少由分支指令和修改循环索引变量的指令所引起的循环控制开销 软流水使叠代内的指令级并行达到最大 向量处理机 向量处理概念 向量由一组有序、具有相同类型和位数的元素组成 在流水线处理机中，设置向量数据表示和相应的向量指令，称为向量处理机 不具有向量数据表示和相应的向量指令的流水线处理机，称为标量处理机 向量指令集的优点 精简 表示能力强，告诉硬件 N 个操作 可扩展 向量与标量性能的平衡 实际的应用问题中通常既有向量计算又有标量计算，而且两类计算有一定的比例 向量平衡点：为了使向量硬件设备和标量硬件设备的利用率相等，一个程序中向量代码所占的百分比 向量平衡点必须与用户程序的向量化程度相匹配 向量数据表示 向量处理机是解决数值计算问题的一种高性能计算机结构 向量处理机一般都采用流水线结构，有多条流水线并行工作 向量处理机通常属大型或巨型机，也可以用微机加一台向量协处理器组成 一般向量计算机中包括有一台高性能标量处理机 必须把问题转化为向量运算，向量处理机才能发挥作用 等间距向量表示法 三个参数表示一个等间距向量 向量起始地址：A 向量长度：L 向量间距：f 带位移量的向量表示法 用三个参数表示一个向量 向量基地址：A 向量长度：L 向量位移量：f 向量有效长度：L－f ，向量起始地址：A＋f 优点：每个向量可以带有位移，通过控制向量实现可变增量，能够表示稀疏向量 稀疏向量表示法 定义：0元素很多，非0元素很少的向量称为稀疏向量 采用压缩方法存储稀疏向量可以节省存储空间 可以还原之后进行运算，也可以用压缩方法直接进行运算 向量处理方式 横向(水平)处理方式 向量计算是按行的方式从左到右横向地进行 不适合于向量处理机的并行处理 纵向(垂直)处理方式 向量计算是按列的方式从上到下纵向地进行 纵横处理方式 又称为分组处理方式 把向量分成若干组，组内按纵向方式处理，依次处理 各组 向量处理机结构 向量处理机的结构因具体机器不同而不同，由所采用的向量处理方式决定 有两种典型的结构 存储器-存储器型结构：纵向处理方式采用，向量长度不受限制 寄存器-寄存器型结构：分组处理方式采用，速度快 “存储器-存储器”结构 采用纵向处理方式的向量处理机对处理机结构的要求 向量指令的源向量和目的向量都是存放在存储器中，运算的中间结果需要送回存储器 流水线运算部件的输入和输出端都直接(或经过缓冲器)与存储器相联，从而构成存储器-存储器型操作的运算流水线 要充分发挥这种结构的流水线效率，存储器要不断地提供源操作数，并不断地从运算部件接收结果(每拍从存储器读取两个数据，并向存储器写回一个结果) 对存储器的带宽以及存储器与处理部件的通信带宽提出了非常高的要求 解决方法：一般是通过采用多体交叉并行存储器 和缓冲器技术 “寄存器-寄存器”结构 在向量的分组处理方式中，对向量长度N没有限制，但组的长度n却是固定不变的 设置能快速访问的向量寄存器，用于存放源向量、目的向量及中间结果，让运算部件的输入、输出端都与向量寄存器相联，就构成了“寄存器－寄存器”型操作的运算流水线 只要不出现Vi冲突和功能部件冲突，各Vi之间和各功能部件之间都能并行工作，大大加快了向量指令的处理 Vi冲突：并行工作的各向量指令的源向量或结果向量使用了相同的Vi 功能部件冲突：并行工作的各向量指令要使用同一个功能部件 提高向量处理机性能的常用技术 设置多个功能部件 设置多个独立的功能部件，这些部件能并行工作，并各自按流水方式工作，从而形成了多条并行工作的运算操作流水线 向量链接技术 两条向量指令占用功能流水线和向量寄存器的4种情况 指令不相关 功能部件冲突 源寄存器冲突 结果寄存器冲突 当前一条指令的结果寄存器是后一条指令的源寄存器、且不存在任何其他冲突时，就可以用链接技术来提高性能 向量流水线链接：具有先写后读相关的两条指令，在不出现功能部件冲突和源向量冲突的情况下，可以把功能部件链接起来进行流水处理，以达到加快执行的目的 进行向量链接的要求：保证无向量寄存器冲突和无功能部件冲突 只有在前一条指令的第一个结果元素送入结果向量寄存器的那一个时钟周期才可以进行链接 当一条向量指令的两个源操作数分别是两条先行指令的结果寄存器时，要求先行的两条指令产生运算结果的时间必须相等，即要求有关功能部件的通过时间相等 要进行链接执行的向量指令的向量长度必须相等，否则无法进行链接 分段开采技术 当向量的长度大于向量寄存器的长度时，必须把长向量分 成长度固定的段，然后循环分段处理，每一次循环只处理 一个向量段 由系统硬件和软件控制完成，对程序员是透明的 采用多处理机系统 许多新型向量处理机系统采用了多处理机系统结构 向量处理机的性能评价 向量指令的处理时间 执行一条向量长度为n的向量指令所需的时间为：Tvp=Ts+Te+(n−1)TcT_{vp}=T_s+T_e+(n-1)T_cT​vp​​=T​s​​+T​e​​+(n−1)T​c​​ Ts：向量处理部件流水线的建立时间(向量启动时间) 为了使处理部件流水线能开始工作(即开始流入数据)所需要的准备时间 向量的启动延迟 功能部件延迟 Dead Time Te：向量流水线的通过时间 第一对向量元素通过流水线并产生第一个结果所获的时间 Tc：流水线的时钟周期时间 把上式中的参数都折算成时钟周期个数：Tvp=[s+e+(n−1)]TcT_{vp}=[s+e+(n-1)]T_cT​vp​​=[s+e+(n−1)]T​c​​ s：Ts所对应的时钟周期数 e：Te所对应的时钟周期数 不考虑Ts，并令TstartT_{start}T​start​​=e-1，则Tvp=(Tstart+n)TcT_{vp}=(T_{start}+n)T_cT​vp​​=(T​start​​+n)T​c​​ TstartT_{start}T​start​​：从一条向量指令开始执行到还差一个时钟周期就产生第一个结果所需的时钟周期数，可称之为该向量指令的启动时间，此后，便是每个时钟周期流出一个结果，共有n个结果 一组向量指令的处理时间 对于一组向量指令而言，其执行时间主要取决于三个因素： 向量的长度 向量操作之间是否存在流水功能部件的使用冲突 数据的相关性 把能在同一个时钟周期内一起开始执行的几条向量指令称为一个编队 可以看出：同一个编队中的向量指令之间一定不存在流水向量功能部件的冲突和数据的冲突 编队后，这个向量指令序列的总的执行时间为各编队的执行时间的和：Tall=∑i=1mTvp(i)T_{all}=\\sum\\limits^m_{i=1}T_{vp}^{(i)}T​all​​=​i=1​∑​m​​T​vp​(i)​​ Tvp(i)T_{vp}^{(i)}T​vp​(i)​​：第i个编队的执行时间 m：编队的个数 当一个编队是由若干条指令组成时，其执行时间就应该由该编队中各指令的执行时间的最大值来确定 Tall=∑i=1mTvp(i)=∑i=1m(Tstart(i)+n)Tc=(Tstart+mn)TcT_{all}=\\sum\\limits^m_{i=1}T_{vp}^{(i)}=\\sum\\limits_{i=1}^m(T_{start}^{(i)}+n)T_c=(T_{start}+mn)T_cT​all​​=​i=1​∑​m​​T​vp​(i)​​=​i=1​∑​m​​(T​start​(i)​​+n)T​c​​=(T​start​​+mn)T​c​​ Tstart(i)T_{start}^{(i)}T​start​(i)​​：第i编队中各指令的启动时间的最大值 Tstart=∑i=1mTstart(i)T_{start}=\\sum\\limits^m_{i=1}T_{start}^{(i)}T​start​​=​i=1​∑​m​​T​start​(i)​​：该组指令总的启动时间(时钟周期个数) 表示成时钟周期个数：Tall=Tstart+mnT_{all}=T_{start}+mnT​all​​=T​start​​+mn(拍) 最大性能R∞R_{\\infty}R​∞​​和半性能向量长度n12n_{\\frac12}n​​2​​1​​​​ 向量处理机的峰值性能R∞R_{\\infty}R​∞​​ R∞R_{\\infty}R​∞​​表示当向量长度为无穷大时，向量处理机的最高性能，也称为峰值性能 R∞=limn→∞R_{\\infty}=\\lim\\limits_{n\\rightarrow\\infty}R​∞​​=​n→∞​lim​​向量指令序列中浮点运算次数 × 时钟频率 / 向量指令序列执行所需的时钟周期数 半性能向量长度n12n_{\\frac12}n​​2​​1​​​​ 半性能向量长度n12n_{\\frac12}n​​2​​1​​​​是指向量处理机的性能为其最大性能的一半时所需的向量长度 评价向量流水线的建立时间对性能影响的重要参数 向量长度临界值nvn_vn​v​​ 向量长度临界值nvn_vn​v​​是指：对于某一计算任务而言，向量方式的处理速度优于标量串行方式处理速度时所需的最小向量长度 向量处理机的发展 向量计算机系统结构的发展趋势是 提供多种向量运算指令 除具有向量处理功能外还有其它功能 采用多层次的存储器系统 流水线技术与并行技术相结合 向量计算机系统结构要解决的六个技术问题 处理机带宽 存储器带宽 输入输出带宽 通信带宽 同步系统 多用途 "}}